<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Billowkiller's Blog</title>
  <meta name="author" content="wutao">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://billowkiller.github.io">
  <link href="/favicon.png" type="image/png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="Billowkiller's Blog" type="application/atom+xml">

  <link href="/javascripts/libs/bootstrap-3.0.0/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/javascripts/libs/bootstrap-3.0.0/dist/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">


  <script src="/javascripts/libs/jquery/jquery-2.0.3.min.js"></script>
  

</head>

  <body   >
    <div id="wrap">
      <header role="banner">
        <nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Billowkiller's Blog</a>
        </div>

        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a href="/">Blog</a>
                </li>
                <li >
                    <a href="/blog/archives">Archives</a>
                </li>
				<li >
                    <a href="/blog/tags">Tags</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="subscribe-rss" href="/atom.xml" title="subscribe via RSS">
                        <span class="visible-xs">RSS</span>
                        <img class="hidden-xs" src="/images/rss.png" alt="RSS">
                    </a>
                </li>
                
            </ul>
            
                <form class="search navbar-form navbar-right" action="http://google.com/search" method="GET">
                    <input type="hidden" name="q" value="site:billowkiller.github.io">
                    <div class="form-group">
                        <input class="form-control" type="text" name="q" placeholder="Search">
                    </div>
                </form>
            
        </div>
    </div>
</nav>


      </header>
      <div id="main" class="container">
        <div id="content">
          <div class="row">
  <div class="page-content col-md-9">
    <div class="blog-index">
      
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-07-12T02:18:00+08:00" pubdate data-updated="true">Jul 12<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/07/12/c%2B%2B-string-copy-on-write/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2014/07/12/c%2B%2B-string-copy-on-write/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/07/12/c%2B%2B-string-copy-on-write/">C++ String Copy-on-write</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>不同版本的C++ string实现时不同的，sizeof(string)得出来的结果也不尽相同，其中有种实现采用copy-on-write的方式来共享内存。</p>

<p>引用计数就是string类中写时才拷贝的原理！当第一个类构造时，string的构造函数会根据 传入的参数从堆上分配内存，当有其它类需要这块内存时，这个计数为自动累加，当有类析构时，这个计数会减一，直到最后一个类析构时，此时的RefCnt为1或是0，此时，程序才会真正的Free这块从堆上分配的内存。</p>

<p>string类的内存是在堆上动态分配的，共享内存的各个类指向的是同一个内存区。这块内存区域还包括引用计数，其位于字符串内存区域的上方，通过<code>_Ptr[-1]</code>来访问。这样所有共享这块内存的类都可以访问到引用计数，也就知道这块内存的引用者有多少了。</p>

<p>于是，有了这样一个机制，每当我们为string分配内存时，我们总是要多分配一个空间用来存放这个引用计数的值，只要发生拷贝构造可是赋值时，这个内存的值就会加一。而在内容修改时，string类为查看这个引用计数是否为0，如果不为零，表示有人在共享这块内存，那么自己需要先做一份拷贝，然后把引用计数减去一，再把数据拷贝过来。</p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2014/07/12/c%2B%2B-string-copy-on-write/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-06-28T04:18:00+08:00" pubdate data-updated="true">Jun 28<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/06/28/signal-and-forkmarkdown/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2014/06/28/signal-and-forkmarkdown/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/signal-and-forkmarkdown/">Signal and Fork</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>当线程调用fork时，就为子进程创建了整个进程地址空间的副本。子进程与父进程是完全不同的进程，只要两者都没有对内存作出改动，父进程和子进程之间还可以共享内存副本。注意一下几个情况：</p>

<ol>
  <li>子进程通过继承整个地址空间的副本，<strong>从父进程那里继承了所有互斥量、读写锁和条件变量的状态</strong>。也就是说，如果它在父进程中被锁住，则它在子进程中也是被锁住的。</li>
  <li>只有调用fork()的线程被复制到子进程（子进程中线程的ID），如果子进程中包含占有锁的线程的副本，那么子进程就没有办法知道它占有了那些锁并且需要释放那些锁，<strong>容易造成死锁</strong>。</li>
  <li>thread-specific data的销毁函数和清除函数都不会被调用。在多线程中调用fork()可能会引起内存泄露。比如在其他线程中创建的thread-specific data，在子进程中将没有指针来存取这些数据，<strong>造成内存泄露</strong>。</li>
</ol>

<p>因为以上这些问题，<strong>在线程中调用fork()的后，我们通常都会在子进程中调用exec()</strong>。因为exec()能让父进程中的所有互斥量，条件变量（pthread objects）在子进程中统统消失（用新数据覆盖所有的内存）。对于那些要使用fork()但不使用exec()的程序，pthread API提供了一个新的函数</p>

<pre><code>pthread_atfor(void (*prepare_func)(void), void(*parent_func)(void), void (*child_func)(void))
</code></pre>

<p>prepare_func在父进程调用fork之前调用，parent_func在fork执行后在父进程内被调用，child_func在fork执行后子进程内被调用。除非你打算很快的exec一个新程序，否则应该避免在一个多线程的程序中使用fork。</p>
</div>
  
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-06-28T03:18:00+08:00" pubdate data-updated="true">Jun 28<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/06/28/signal-and-thread/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2014/06/28/signal-and-thread/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/signal-and-thread/">Signal and Thread</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>类UNIX信号以前是专为进程设计的，它比线程的出现早了很多年。当线程模型出现后，专家们试图也在线程上实现信号，这导致了一个问题：即使是在基于进程的编程模式中，信号的处理也可能是很复杂的，因为它打断了正在运行的thread of control， 在signal handler中只能调用可重入函数，修改全局变量的类型必须是<code>sig_atomic_t</code>类型，防止内存访问优化； 而把线程引入编程范型，就使信号的处理变得更加复杂。</p>

<p><strong>避免信号和线程一起使用是明智的选择。</strong>但是，将他们分开又是不可能或不实际的。只要有可能的话，仅仅在主线程内使用<code>pthread_sigmask()</code>来屏蔽信号，然后同步地在专用线程中使用<code>sigwait()</code>来处理信号。</p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2014/06/28/signal-and-thread/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-06-28T02:18:00+08:00" pubdate data-updated="true">Jun 28<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/06/28/signal-status-and-lifecycle/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2014/06/28/signal-status-and-lifecycle/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/signal-status-and-lifecycle/">Signal Status and Lifecycle</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p><i><strong>modified from</strong> <a href="http://blog.csdn.net/sunyubo458/article/details/4484957">http://blog.csdn.net/sunyubo458/article/details/4484957</a></i></p>

<p><em>Lost original source</em></p>

<hr />

<h3 id="section">信号状态</h3>

<p>信号的”未决“是一种状态，指的是从信号的产生到信号被处理前的这一段时间；信号的”阻塞“是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 </p>

<p>每个进程都有一个信号屏蔽字，它规定了当前要阻塞地送到该进程的信号集，对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应为已设定，则它当前是被阻塞的。进程可以调用<code>sigprocmask</code>来检测和更改当前信号屏蔽字。</p>

<p>APUE例题在<code>sleep</code>前用<code>sigprocmask</code>阻塞了退出信号，然后<code>sleep</code>,然后在<code>sleep</code>的过程中产生一个退出信号，但是此时退出信号被阻塞过，（中文的”阻塞”在这里容易被误解为一种状态，实际上是一种类似于开关的动作，所以说“被阻塞过”，而不是“被阻塞”）所以处于“未决”状态，在 <code>sleep</code>后又用<code>sigprocmask</code>关掉退出信号的阻塞开关，因为之前产生的退出信号一直处于未决状态，当关上阻塞开关后，马上退出“未决”状态，得到处理，这一切发生在<code>sigprocmask</code>返回之前。 </p>

<h3 id="section-1">信号生命周期</h3>

<p>对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个重要的阶段，这三个阶段由四个重要事件来刻画：1.信号诞生；2. 信号在进程中注册完毕；3.信号在进程中的注销完毕；4.信号处理函数执行完毕。相邻两个事件的时间间隔构成信号生命周期的一个阶段。</p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2014/06/28/signal-status-and-lifecycle/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-12-31T18:09:00+08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2013</time>
        
           | <a href="/blog/2013/12/31/large-site-technical-architecture/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2013/12/31/large-site-technical-architecture/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2013/12/31/large-site-technical-architecture/">Large Site Technical Architecture</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>本文是李智慧的<a href="http://book.douban.com/subject/25723064/">《大型网站技术架构》</a>的读书笔记。</p>

<p>何为架构，要有大局观，大局观就是提前预防掉那些通用的问题：高可用，工程化，伸缩性，扩展性。对应需要的能力：了解分布式的一些东西，了解项目的业务和流程和运维使之工程化，了解负载均衡，能够对业务的分割和代码的分层。 </p>

<p><img src="http://img3.douban.com/lpic/s27040583.jpg" height="250px" /></p>

<p>本书并没有什么特别的东西，且都比较泛，但是都是很实在的东西，而且能很好的组织起来，也不失为互联网架构的一张蓝图。另外本书还处处透露着一些为人处世的人生哲学，这也是我喜欢的。</p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2013/12/31/large-site-technical-architecture/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-12-31T18:07:00+08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2013</time>
        
           | <a href="/blog/2013/12/31/gcc-summary/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2013/12/31/gcc-summary/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2013/12/31/gcc-summary/">Gcc Summary</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>本文介绍在Linux平台下应用程序的编译过程，以及编译程序<a href="http://gcc.gnu.org/">GCC</a>在编译应用程序的过程的具体用法，同时详细说明了GCC的常用选项、模式和警告选项。</p>

<center>![gcc](http://gcc.gnu.org/img/gccegg-65.png)</center>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2013/12/31/gcc-summary/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-11-26T16:52:00+08:00" pubdate data-updated="true">Nov 26<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/11/26/nginx-architecture-4-modularity/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2013/11/26/nginx-architecture-4-modularity/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2013/11/26/nginx-architecture-4-modularity/">Nginx architecture(4)&#8211;Modularity</a></h1>
    
  </header>


  <div class="entry-content clearfix"><h2 id="section">1. 概述</h2>

<p>这章的题目说的有些不对，nginx的模块化只是模块化编程的一个案例，我用它来分析所谓的模块化编程，接下来在其他的例子中也有体现模块化，但是为了形成nginx架构这一系列文章，我还是把它命名为nginx架构——模块化。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/nginx-logo_zpsabde8e46.png" /></p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2013/11/26/nginx-architecture-4-modularity/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-11-14T15:12:00+08:00" pubdate data-updated="true">Nov 14<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/11/14/nginx-architecture-3-memory-pool/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2013/11/14/nginx-architecture-3-memory-pool/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2013/11/14/nginx-architecture-3-memory-pool/">Nginx Architecture(3)&#8211;memory Pool</a></h1>
    
  </header>


  <div class="entry-content clearfix"><h2 id="section">1. 概述</h2>

<p>Nginx里内存的使用大都十分有特色：申请了永久保存，抑或伴随着请求的结束而全部释放，还有写满了缓冲再从头接着写。这么做的原因也主要取决于Web Server的特殊的场景，内存的分配和请求相关，一条请求处理完毕，即可释放其相关的内存池，降低了开发中对内存资源管理的复杂度，也减少了内存碎片的存在。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/nginx_zps7d735b88.jpg" alt="Nginx logo" /></p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2013/11/14/nginx-architecture-3-memory-pool/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-11-14T00:16:00+08:00" pubdate data-updated="true">Nov 14<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/11/14/nginx-architecture-2-event-driven/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2013/11/14/nginx-architecture-2-event-driven/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2013/11/14/nginx-architecture-2-event-driven/">Nginx architecture(2)&#8211;Event Driven</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>Nginx是一个事件驱动架构的Web服务器。在Linux中，<code>epoll</code>是目前最强大的事件管理机制(I/O多路复用)，定时器事件也是由<code>epoll</code>等事件模块触发的，它是由红黑树实现的。并且Nginx很好的解决多个<code>worker</code>子进程监听同一个端口引起的惊群问题，以及对<code>worker</code>进行负载平衡。最后会讨论下linux内核中的文件异步I/O。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/nginx-logo_zpsabde8e46.png" /></p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2013/11/14/nginx-architecture-2-event-driven/">Read on &rarr;</a>
    </footer>
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-10-13T00:28:00+08:00" pubdate data-updated="true">Oct 13<span>th</span>, 2013</time>
        
           | <a href="/blog/2013/10/13/nginx-architecture-1-overview/#disqus_thread"
             data-disqus-identifier="http://billowkiller.github.io/blog/2013/10/13/nginx-architecture-1-overview/">Comments</a>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2013/10/13/nginx-architecture-1-overview/">Nginx architecture(1)&#8211;Overview</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>从04年发布以来，Nginx已经成为多个国内外互联网具体首选的高性能Web服务器。其特点是占有内存少，并发能力强，并且由于Nginx使用基于事件驱动的架构能够最有效的利用多核CPU的处理能力，进程可以无阻塞的运行。</p>

<p>特别是Nginx可以利用当前操作系统特有的一些高校API来提高自己的性能，例如Linux上的<code>epoll</code>、Solaris上的event ports和Free BSD上的kqueue。又如对于Linux，Nginx支持其独有的sendfile系统调用，可以高效的讲硬盘中的数据发送到网络上（无需将硬盘数据先复制到用户态内存中）。</p>

<p>所以通过分析Nginx的架构设计，可以怎样充分利用服务器上的硬件资源，以及学习到更为先进的理念。下面就来分析和学习Nginx的架构设计。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/nginx_zps7d735b88.jpg" alt="Nginx logo" /></p>

</div>
  
  
    <footer>
      <a class="btn btn-default" rel="full-article" href="/blog/2013/10/13/nginx-architecture-1-overview/">Read on &rarr;</a>
    </footer>
  


        </article>
      
    </div>

    <ul class="pager">
      
        <li class="previous"><a href="/blog/page/2/">&larr;&nbsp;Older</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
        <li class="next disabled"><a href="#">Newer&nbsp;&rarr;</a></li>
      
    </ul>
  </div>

  
    <aside class="sidebar col-md-3">
      
        <section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Recent Posts</h3>
  </div>
  
  <div id="recent_posts" class="list-group">
    
    <a class="list-group-item " href="/blog/2014/07/12/c%2B%2B-string-copy-on-write/">C++ String Copy-on-write</a>
    
    <a class="list-group-item " href="/blog/2014/06/28/signal-and-forkmarkdown/">Signal and Fork</a>
    
    <a class="list-group-item " href="/blog/2014/06/28/signal-and-thread/">Signal and Thread</a>
    
    <a class="list-group-item " href="/blog/2014/06/28/signal-status-and-lifecycle/">Signal Status and Lifecycle</a>
    
    <a class="list-group-item " href="/blog/2013/12/31/large-site-technical-architecture/">Large Site Technical Architecture</a>
    
  </div>
</section>
<section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Categories</h3>
  </div>
  <div class="list-group">
    
    
    <a class="list-group-item " href="/blog/categories/language/index.html">
        <span class="badge">4</span>
        language
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/tools/index.html">
        <span class="badge">6</span>
        tools
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/linux/index.html">
        <span class="badge">13</span>
        linux
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/book/index.html">
        <span class="badge">3</span>
        book
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/google/index.html">
        <span class="badge">4</span>
        google
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/rework/index.html">
        <span class="badge">8</span>
        rework
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/film/index.html">
        <span class="badge">3</span>
        film
      </a>
    
    
    <a class="list-group-item " href="/blog/categories/algorithm/index.html">
        <span class="badge">2</span>
        algorithm
      </a>
    
  </div>
</section>
<section class="panel panel-default clearfix">
  <div class="panel-heading">
      <h3 class="panel-title">GitHub Repos</h3>
  </div>
  
    <div class="gh-profile-link pull-right text-muted">
      <a href="https://github.com/billowkiller">@billowkiller</a> on GitHub
    </div>
  
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">On Delicious</h3>
  </div>
  <div class="panel-body">
    <div id="delicious"></div>
    <script type="text/javascript" src="http://feeds.delicious.com/v2/json/billowkiller?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
    <p><a href="http://delicious.com/billowkiller">My Delicious Bookmarks &raquo;</a></p>
  </div>
</section>


      
    </aside>
  
</div>

        </div>
      </div>
    </div>
    <footer role="contentinfo"><div class="container">
    <p class="text-muted credits">
  Copyright &copy; 2014 - wutao<br>
  <small>
      <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>,
      <span class="credit">customized with <a href="https://github.com/kAworu/octostrap3">octostrap3</a></span>.
  </small>
</p>

</div>
</footer>
    <script src="/javascripts/libs/bootstrap-3.0.0/dist/js/bootstrap.min.js"></script>
<script src="/javascripts/modernizr-2.0.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'billowkiller';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





  </body>
</html>
