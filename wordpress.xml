<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-billowkiller</title><link>http://www.cnblogs.com/billowkiller/</link><description /><language>zh-cn</language><lastBuildDate>Mon, 13 May 2013 01:26:04 GMT</lastBuildDate><pubDate>Mon, 13 May 2013 01:26:04 GMT</pubDate><ttl>60</ttl><item><title>python dict sorted 排序</title><link>http://www.cnblogs.com/billowkiller/archive/2013/05/08/3067914.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 08 May 2013 14:14:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/05/08/3067914.html</guid><description><![CDATA[<div id="cnblogs_post_body">
<p><em><strong>from</strong>&nbsp;<a href="http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html">http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html</a></em></p>
<hr />
<p>&nbsp;</p>
<p>我们知道Python的内置dictionary数据类型是无序的，通过key来获取对应的value。可是有时我们需要对dictionary中 的item进行排序输出，可能根据key，也可能根据value来排。到底有多少种方法可以实现对dictionary的内容进行排序输出呢？下面摘取了 一些精彩的解决办法。&nbsp;<br /><br />#最简单的方法，这个是按照key值排序：&nbsp;<br />def sortedDictValues1(adict):&nbsp;<br />items = adict.items()&nbsp;<br />items.sort()&nbsp;<br />return [value for key, value in items]&nbsp;<br /><br />#又一个按照key值排序，貌似比上一个速度要快点&nbsp;<br />def sortedDictValues2(adict):&nbsp;<br />keys = adict.keys()&nbsp;<br />keys.sort()&nbsp;<br />return [dict[key] for key in keys]&nbsp;<br /><br />#还是按key值排序，据说更快。。。而且当key为tuple的时候照样适用&nbsp;<br />def sortedDictValues3(adict):&nbsp;<br />keys = adict.keys()&nbsp;<br />keys.sort()&nbsp;<br />return map(adict.get, keys)&nbsp;<br /><br />#一行语句搞定：&nbsp;<br />[(k,di[k]) for k in sorted(di.keys())]&nbsp;<br /><br />#来一个根据value排序的，先把item的key和value交换位置放入一个list中，再根据list每个元素的第一个值，即原来的value值，排序：&nbsp;<br />def sort_by_value(d):&nbsp;<br />items=d.items()&nbsp;<br />backitems=[[v[1],v[0]] for v in items]&nbsp;<br />backitems.sort()&nbsp;<br />return [ backitems[i][1] for i in range(0,len(backitems))]&nbsp;<br /><br />#还是一行搞定：&nbsp;<br />[ v for v in sorted(di.values())]&nbsp;<br /><br />#用lambda表达式来排序，更灵活：&nbsp;<br />sorted(d.items(), lambda x, y: cmp(x[1], y[1])), 或反序：&nbsp;<br />sorted(d.items(), lambda x, y: cmp(x[1], y[1]), reverse=True)&nbsp;<br /><br />#用sorted函数的key= 参数排序：&nbsp;<br /># 按照key进行排序&nbsp;<br />print sorted(dict1.items(), key=lambda d: d[0])&nbsp;<br /># 按照value进行排序&nbsp;<br />print sorted(dict1.items(), key=lambda d: d[1])&nbsp;<br /><br />下面给出python内置sorted函数的帮助文档：&nbsp;<br />sorted(...)&nbsp;<br />sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list&nbsp;<br /><br />看了上面这么多种对dictionary排序的方法，其实它们的核心思想都一样，即把dictionary中的元素分离出来放到一个list中，对list排序，从而间接实现对dictionary的排序。这个&ldquo;元素&rdquo;可以是key，value或者item。&nbsp;<br /><br />#################################################################################&nbsp;<br /><br />一上转&nbsp;<br /><br />按照value排序可以用&nbsp;<br /><br />sorted(d.items, key=lambda d:d[1])&nbsp;<br /><br />若版本低不支持sorted&nbsp;<br /><br />将key,value 以tuple一起放在一个list中&nbsp;<br /><br />l = []&nbsp;<br /><br />l.append((akey,avalue))...&nbsp;<br /><br />用sort（）&nbsp;<br /><br />l.sort(lambda a,b :cmp(a[1],b[1]))(cmp前加&ldquo;-&rdquo;表示降序排序)</p>
<p>&nbsp;</p>

</div>
<div id="MySignature">&nbsp;</div>
<div class="clear">&nbsp;</div>
<div id="blog_post_info_block">&nbsp;</div>]]></description></item><item><title>Python特殊语法：filter、map、reduce、lambda [转]</title><link>http://www.cnblogs.com/billowkiller/archive/2013/05/08/3067629.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 08 May 2013 12:06:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/05/08/3067629.html</guid><description><![CDATA[<div id="cnblogs_post_body">
<p><em><strong>from</strong>&nbsp;<a href="http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html">http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html</a></em></p>
<hr />
<p>&nbsp;</p>
<p>Python内置了一些非常有趣但非常有用的函数，充分体现了Python的语言魅力！</p>
<p><br /><strong>filter(function, sequence)</strong>：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回：<br />&gt;&gt;&gt; def f(x): return x % 2 != 0 and x % 3 != 0&nbsp;<br />&gt;&gt;&gt; filter(f, range(2, 25))&nbsp;<br />[5, 7, 11, 13, 17, 19, 23]<br />&gt;&gt;&gt; def f(x): return x != 'a'&nbsp;<br />&gt;&gt;&gt; filter(f, "abcdef")&nbsp;<br />'bcdef'</p>
<p><br /><strong>map(function, sequence)</strong>&nbsp;：对sequence中的item依次执行function(item)，见执行结果组成一个List返回：<br />&gt;&gt;&gt; def cube(x): return x*x*x&nbsp;<br />&gt;&gt;&gt; map(cube, range(1, 11))&nbsp;<br />[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]<br />&gt;&gt;&gt; def cube(x) : return x + x&nbsp;<br />...&nbsp;<br />&gt;&gt;&gt; map(cube , "abcde")&nbsp;<br />['aa', 'bb', 'cc', 'dd', 'ee']<br />另外map也支持多个sequence，这就要求function也支持相应数量的参数输入：<br />&gt;&gt;&gt; def add(x, y): return x+y&nbsp;<br />&gt;&gt;&gt; map(add, range(8), range(8))&nbsp;<br />[0, 2, 4, 6, 8, 10, 12, 14]</p>
<p><br /><strong>reduce(function, sequence, starting_value)</strong>：对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：<br />&gt;&gt;&gt; def add(x,y): return x + y&nbsp;<br />&gt;&gt;&gt; reduce(add, range(1, 11))&nbsp;<br />55 （注：1+2+3+4+5+6+7+8+9+10）<br />&gt;&gt;&gt; reduce(add, range(1, 11), 20)&nbsp;<br />75 （注：1+2+3+4+5+6+7+8+9+10+20）</p>
<p><br /><strong>lambda</strong>：这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数，是从LISP借用来的，可以用在任何需要函数的地方：&nbsp;<br />&gt;&gt;&gt; g = lambda x: x * 2&nbsp;<br />&gt;&gt;&gt; g(3)&nbsp;<br />6&nbsp;<br />&gt;&gt;&gt; (lambda x: x * 2)(3)&nbsp;<br />6<br /><br /><br />我们也可以<strong>把filter map reduce 和lambda结合起来</strong>用，函数就可以简单的写成一行。<br />例如<br />kmpathes = filter(lambda kmpath: kmpath,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />map(lambda kmpath: string.strip(kmpath),<br />string.split(l, ':')))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />看起来麻烦，其实就像用语言来描述问题一样，非常优雅。<br />对 l 中的所有元素以':'做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被':'分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。</p>
<p>&nbsp;</p>
<p>[转]&nbsp;<a href="http://hi.baidu.com/black/item/307001d18715fc322a35c747">http://hi.baidu.com/black/item/307001d18715fc322a35c747</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>---------------------------------------------------------------</p>
<p>&nbsp;</p>
<div><strong>lambda表达式</strong>返回一个函数对象</div>
<div>例子：</div>
<div>func = lambda x,y:x+y</div>
<div>func相当于下面这个函数</div>
<div>def func(x,y):</div>
<div>&nbsp; &nbsp; return x+y</div>
<div>&nbsp;</div>
<div>注意def是语句而lambda是表达式</div>
<div>下面这种情况下就只能用lambda而不能用def</div>
<div>[(lambda x:x*x)(x) for x in range(1,11)]</div>
<div>&nbsp;</div>
<div>map，reduce，filter中的function都可以用lambda表达式来生成！</div>
<div>&nbsp;</div>
<div><strong>map(function,sequence)</strong></div>
<div>把sequence中的值当参数逐个传给function，返回一个包含函数执行结果的list。</div>
<div>如果function有两个参数，即map(function,sequence1,sequence2)。</div>
<div>&nbsp;</div>
<div>例子：</div>
<div>求1*1,2*2,3*3,4*4</div>
<div>map(lambda x:x*x,range(1,5))</div>
<div>返回值是[1,4,9,16]</div>
<div>&nbsp;</div>
<div><strong>reduce(function,sequence)</strong></div>
<div>function接收的参数个数只能为2</div>
<div>先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给</div>
<div>function，然后只返回一个结果。</div>
<div>&nbsp;</div>
<div>例子：</div>
<div>求1到10的累加</div>
<div>reduce(lambda x,y:x+y,range(1,11))</div>
<div>返回值是55。</div>
<div>&nbsp;</div>
<div><strong>filter(function,sequence)</strong></div>
<div>function的返回值只能是True或False</div>
<div>把sequence中的值逐个当参数传给function，如果function(x)的返回值是True，就把x加到filter的返回值里面。一般来说filter的返回值是list，特殊情况如sequence是string或tuple，则返回值按照sequence的类型。</div>
<div>&nbsp;</div>
<div>例子：</div>
<div>找出1到10之间的奇数</div>
<div>filter(lambda x:x%2!=0,range(1,11))</div>
<div>返回值</div>
<div>[1,3,5,7,9]</div>
<div>&nbsp;</div>
<div>如果sequence是一个string</div>
<div>filter(lambda x:len(x)!=0,'hello')返回'hello'</div>
<div>filter(lambda x:len(x)==0,'hello')返回''</div>
<div>&nbsp;</div>
<p>[转]&nbsp;<a href="http://blog.csdn.net/myzhan/article/details/7269471">http://blog.csdn.net/myzhan/article/details/7269471</a></p>
</div>
<div id="blog_post_info_block">&nbsp;</div>]]></description></item><item><title>sublime text2 说明</title><link>http://www.cnblogs.com/billowkiller/archive/2013/05/08/3067545.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 08 May 2013 11:43:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/05/08/3067545.html</guid><description><![CDATA[<p><strong><em><span style="font-size: 16px;">Infomation Included：</span></em></strong></p>
<ol>
<li>快捷键</li>
<li>插件</li>
</ol><hr />
<h3>&nbsp;</h3>
<h3>快捷键</h3>
<table style="border-collapse: collapse; border: solid #C0504D 1.0pt; mso-border-alt: solid #C0504D 1.0pt; mso-border-themecolor: accent2; mso-yfti-tbllook: 1184; mso-padding-alt: 0cm 5.4pt 0cm 5.4pt;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+L</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; background: #F8eDeD; mso-background-themecolor: accent2; mso-background-themetint: 25; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><strong><span style="font-family: 宋体;">选择整行</span></strong><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span></strong><strong><span style="font-family: 宋体;">按住</span></strong><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">-</span></strong><strong><span style="font-family: 宋体;">继续选择下行</span></strong><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></strong></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+KK</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">从光标处删除至行尾</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+K</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">删除整行</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+D</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">复制光标所在整行，插入在该行之前</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+J</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">合并行</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span><span style="font-family: 宋体;">已选择需要合并的多行时</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+KU</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">改为大写</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+KL</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">改为小写</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+D</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">选词</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span><span style="font-family: 宋体;">按住</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">-</span><span style="font-family: 宋体;">继续选择下个相同的字符串</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+M</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">光标移动至括号内开始或结束的位置</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+M</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">选择括号内的内容</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span><span style="font-family: 宋体;">按住</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">-</span><span style="font-family: 宋体;">继续选择父括号</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+/</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">注释整行</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span><span style="font-family: 宋体;">如已选择内容，同</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">&ldquo;Ctrl+Shift+/&rdquo;</span><span style="font-family: 宋体;">效果</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+/</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">注释已选择内容</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Space</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">自动完成</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(win</span><span style="font-family: 宋体;">与系统快捷键冲突，需修改</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Z</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">撤销</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Y</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">恢复撤销</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+V</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">粘贴并自动缩进</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span><span style="font-family: 宋体;">其它兄弟写的，实测</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">win</span><span style="font-family: 宋体;">系统自动缩进无效</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">)</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+M</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">光标跳至对应的括号</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Alt+.</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">闭合当前标签</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+A</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">选择光标位置父标签对儿</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+[</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">折叠代码</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+]</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">展开代码</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+KT</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">折叠属性</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+K0</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">展开所有</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+U</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">软撤销</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+T</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">词互换</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Enter</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">插入行后</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift Enter</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">插入行前</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+K Backspace</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">从光标处删除至行首</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+UP</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">与上行互换</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Ctrl+Shift+DOWN</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">与下行互换</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Shift+Tab</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">去除缩进</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">Tab</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; mso-border-alt: solid #C0504D 1.0pt; mso-border-left-alt: solid #C0504D .75pt; mso-border-left-themecolor: accent2; background: #DFA7A6; mso-background-themecolor: accent2; mso-background-themetint: 127; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">缩进</span></p>
</td>
</tr>
<tr>
<td style="width: 85.45pt; border: solid #C0504D 1.0pt; border-top: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: white; mso-background-themecolor: background1; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="114">
<p><strong><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">F9</span></strong></p>
</td>
<td style="width: 340.65pt; border: solid #C0504D 1.0pt; mso-border-themecolor: accent2; border-top: none; mso-border-top-alt: solid #C0504D 1.0pt; mso-border-top-themecolor: accent2; background: #eFD3D2; mso-background-themecolor: accent2; mso-background-themetint: 63; padding: 0cm 5.4pt 0cm 5.4pt;" valign="top" width="454">
<p><span style="font-family: 宋体;">行排序</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">(</span><span style="font-family: 宋体;">按</span><span style="font-family: Cambria, serif;" lang="EN-US" xml:lang="EN-US">a-z)</span></p>
</td>
</tr>
</tbody>
</table>
<p><span lang="EN-US" xml:lang="EN-US">&nbsp;</span></p>]]></description></item><item><title>google论文：Percolator</title><link>http://www.cnblogs.com/billowkiller/archive/2013/04/24/3041426.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 24 Apr 2013 15:41:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/04/24/3041426.html</guid><description><![CDATA[<p><span>论文：</span><a href="http://static.usenix.org/event/osdi10/tech/full_papers/Peng.pdf" target="_blank">英文版</a></p>
<hr />
<p><span>&nbsp;</span></p>]]></description></item><item><title>google论文：MapReduce</title><link>http://www.cnblogs.com/billowkiller/archive/2013/04/15/3022035.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Mon, 15 Apr 2013 08:28:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/04/15/3022035.html</guid><description><![CDATA[<p>论文：<a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank">英文版</a>，<a href="http://blademaster.ixiezi.com/2010/03/27/google-mapreduce%E4%B8%AD%E6%96%87%E7%89%88/" target="_blank">中文版</a></p>
<hr />
<h2>1. 导论</h2>
<h3>1.1 定义</h3>
<p>先给个定义： MapReduce是一个<span style="color: #ff0000;">编程模型</span>，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于key/value pair的数据集合，输出中间的基于key/value pair的数据集合；然后再创建一个Reduce函数用来合并所有的具有相同中间key值的中间value值。</p>
<p>使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面。设计这个抽象模型的灵感来自<span style="color: #ff0000;">Lisp</span>和许多其他函数式语言的Map和Reduce的原语。</p>
<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/mr2_zps9c617225.png" alt="" width="385" height="438" /></p>
<h3>1.2 概述</h3>
<ul>
<li>Programmers must specify:
<ul>
<li><span style="color: #ff0000;">map</span> (k, v) &rarr; &lt;k&rsquo;, v&rsquo;&gt;*</li>
<li><span style="color: #ff0000;">reduce</span> (k&rsquo;, v&rsquo;) &rarr; &lt;k&rsquo;, v&rsquo;&gt;*
<ul>
<li>All values with the same key are reduced together</li>
</ul>
</li>
</ul>
</li>
<li>Optionally, also:
<ul>
<li><span style="color: #ff0000;">partition</span> (k&rsquo;, number of partitions) &rarr; partition for k&rsquo;
<ul>
<li>Often a simple hash of the key, e.g., hash(k&rsquo;) mod n</li>
<li>Divides up key space for parallel reduce operations</li>
</ul>
</li>
<li><span style="color: #ff0000;">combine</span> (k&rsquo;, v&rsquo;) &rarr; &lt;k&rsquo;, v&rsquo;&gt;*
<ul>
<li>Mini-reducers that run in memory after the map phase</li>
<li>Used as an optimization to reduce network traffic</li>
</ul>
</li>
</ul>
</li>
<li>The execution framework handles everything else&hellip;
<ul>
<li>Scheduling: assigns workers to map and reduce tasks</li>
<li>&ldquo;Data distribution&rdquo;: moves processes to data</li>
<li><span style="color: #ff0000;">Synchronization</span>: gathers, sorts, and shuffles intermediate data</li>
<li>Errors and faults: detects worker failures and restarts</li>
</ul>
</li>
<li>Limited control over data and execution flow
<ul>
<li>All algorithms must expressed in m, r, c, p</li>
</ul>
</li>
<li>You don&rsquo;t know:
<ul>
<li>Where mappers and reducers run</li>
<li>When a mapper or reducer begins or finishes</li>
<li>Which input a particular mapper is processing</li>
<li>Which intermediate key a particular reducer is processing</li>
</ul>
</li>
</ul>
<h2>2. 实现</h2>
<h3>2.1 流程</h3>
<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/mr1_zps85dad9ca.png" alt="" width="548" height="453" /></p>
<p>上图展示了我们的MapReduce实现中操作的全部流程。</p>
<ol>
<li>用户程序首先调用的MapReduce库将输入文件分成M个<span style="color: #ff0000;">数据片段</span>，每个数据片段的大小一般从16MB到64MB。然后用户程序在机群中创建大量的程序副本。</li>
<li>这些程序副本中的有一个特殊的程序&ndash;<span style="color: #ff0000;">master</span>。副本中其它的程序都是<span style="color: #ff0000;">worker</span>程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。</li>
<li>被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的<span style="color: #ff0000;">中间key/value pair</span>，并缓存在内存中。</li>
<li>缓存中的key/value pair通过<span style="color: #ff0000;">分区函数</span>分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</li>
<li>当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用<span style="color: #ff0000;">RPC</span>从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据<span style="color: #ff0000;">聚合</span>在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行<span style="color: #ff0000;">排序</span>。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li>
<li>Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</li>
<li>当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</li>
</ol>
<h3>2.2 map和Reduce的同步</h3>
<ul>
<li>Cleverly-constructed data structures
<ul>
<li>Bring partial results together</li>
</ul>
</li>
<li>Sort order of intermediate keys
<ul>
<li>Control order in which reducers process keys</li>
</ul>
</li>
<li>Partitioner
<ul>
<li>Control which reducer processes which keys</li>
</ul>
</li>
<li>Preserving state in mappers and reducers
<ul>
<li>Capture dependencies across multiple keys and values</li>
</ul>
</li>
</ul>
<p>&nbsp;<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/mr3_zps5ead0c7b.png" alt="" width="473" height="266" /></p>
<h3>2.3 本地聚合</h3>
<ul>
<li>Ideal&nbsp;scaling characteristics:
<ul>
<li>Twice the data, twice the running time</li>
<li>Twice the resources, half the running time</li>
</ul>
</li>
<li>Why can&rsquo;t we achieve this?
<ul>
<li>Synchronization requires communication</li>
<li>Communication kills performance</li>
</ul>
</li>
<li>Thus&hellip; <span style="color: #ff0000;">avoid communication</span>!
<ul>
<li>Reduce intermediate data via <span style="color: #ff0000;">local aggregation</span></li>
<li>Combiners can help</li>
</ul>
</li>
</ul>
<h3>2.4 Shuffle and Sort</h3>
<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/mr4_zps7ee59e35.png" alt="" width="568" height="342" /></p>
<h3>2.5 Master</h3>
<p>Master持有一些数据结构，它存储每一个<span style="color: #ff0000;">Map和Reduce任务的状态</span>（空闲、工作中或完成)，以及<span style="color: #ff0000;">Worker机器</span>(非空闲任务的机器)的标识。</p>
<p>Master就像一个<span style="color: #ff0000;">数据管道</span>，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。</p>
<p>master周期性的<span style="color: #ff0000;">ping</span>每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，master将把这个worker标记为失效。所有由这个失效的worker完成的Map任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。</p>
<p>master周期性的将数据写入磁盘，即检查点（<span style="color: #ff0000;">checkpoint</span>）。如果这个master任务失效了，可以从最后一个检查点开始启动另一个master进程。然而，由于只有一个master进程，master失效后再恢复是比较麻烦的，因此我们现在的实现是如果master失效，就中止MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。</p>
<h2>3. 性能优化</h2>
<h3>3.1 straggler</h3>
<p>影响一个MapReduce的总执行时间最通常的因素是straggler(落伍者)：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。</p>
<p>当一个MapReduce操作接近完成的时候，master调度备用（backup）任务进程来执行剩下的、处于处理中状态（in-progress）的任务。无论是最初的执行进程、还是备用（<span style="color: #ff0000;">backup</span>）任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。</p>
<h3>3.2 分区函数(partitioning function)</h3>
<p>我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。</p>
<p>使用&ldquo;hash(Hostname(urlkey)) mod R&rdquo;作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。</p>
<h3>3.3 顺序保证</h3>
<p>在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。</p>
<h3>3.4 Combiner函数</h3>
<p>用户指定一个可选的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</p>
<p>一般情况下，Combiner和Reduce函数是一样的。Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。</p>
<h3><span style="color: #ff0000;">3.5 跳过损坏的记录</span></h3>
<ul>
<li>Map/Reduce functions sometimes fail for particular inputs
<ul>
<li>Best solution is to debug &amp; fix
<ul>
<li>Not always possible ~ third-party source libraries</li>
</ul>
</li>
<li>On segmentation fault:
<ul>
<li>Send UDP packet to master from signal handler</li>
<li>Include sequence number of record being processed</li>
</ul>
</li>
<li>If master sees two failures for same record:
<ul>
<li>Next worker is told to skip the record</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>4. 要点和例子</h2>
<h3>4.1 Points need to be emphasized</h3>
<ul>
<li>No reduce can begin <span style="color: #ff0000;">until</span> map is complete</li>
<li>Master must communicate locations of intermediate files</li>
<li>Tasks scheduled based on location of data</li>
<li>If map worker fails any time before reduce finishes, task must be completely rerun</li>
<li>MapReduce library does most of the hard work for us!</li>
</ul>
<h3>4.2 例子</h3>
<ol>
<li>分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</li>
<li>计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。</li>
<li>倒转网络链接图：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</li>
<li>每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。</li>
<li>倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</li>
<li>分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。</li>
</ol>
<h2>5. Hadoop</h2>
<p><strong><span lang="HI">术语对照</span></strong></p>
<p>&nbsp;</p>
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="109">
<p class="TableContents" align="center"><span style="font-size: 14px;"><strong>翻译</strong></span></p>
</td>
<td width="136">
<p class="TableContents" align="center"><span style="font-size: 14px;"><strong>Hadoop</strong><strong>术语</strong></span></p>
</td>
<td width="142">
<p class="TableContents" align="center"><span style="font-size: 14px;"><strong>Google</strong><strong>术语</strong></span></p>
</td>
<td width="277">
<p class="TableContents" align="center"><span style="font-size: 14px;"><strong>相关解释</strong></span></p>
</td>
</tr>
<tr>
<td width="109">
<p class="TableContents" align="center"><span style="font-size: 14px;">作业</span></p>
</td>
<td width="136">
<p class="TableContents" align="center"><span style="font-size: 14px;">Job</span></p>
</td>
<td width="142">
<p class="TableContents" align="center"><span style="font-size: 14px;">Job</span></p>
</td>
<td width="277">
<p class="TableContents"><span style="font-size: 14px;">用户的每一个计算请求，就称为一个作业。</span></p>
</td>
</tr>
<tr>
<td width="109">
<p class="TableContents" align="center"><span style="font-size: 14px;">作业服务器</span></p>
</td>
<td width="136">
<p class="TableContents" align="center"><span style="font-size: 14px;">JobTracker</span></p>
</td>
<td width="142">
<p class="TableContents" align="center"><span style="font-size: 14px;">Master</span></p>
</td>
<td width="277">
<p class="TableContents"><span style="font-size: 14px;">用户提交作业的服务器，同时，它还负责各个作业任务的分配，管理所有的任务服务器。</span></p>
</td>
</tr>
<tr>
<td width="109">
<p class="TableContents" align="center"><span style="font-size: 14px;">任务服务器</span></p>
</td>
<td width="136">
<p class="TableContents" align="center"><span style="font-size: 14px;">TaskTracker</span></p>
</td>
<td width="142">
<p class="TableContents" align="center"><span style="font-size: 14px;">Worker</span></p>
</td>
<td width="277">
<p class="TableContents"><span style="font-size: 14px;">任劳任怨的工蜂，负责执行具体的任务。</span></p>
</td>
</tr>
<tr>
<td width="109">
<p class="TableContents" align="center"><span style="font-size: 14px;">任务</span></p>
</td>
<td width="136">
<p class="TableContents" align="center"><span style="font-size: 14px;">Task</span></p>
</td>
<td width="142">
<p class="TableContents" align="center"><span style="font-size: 14px;">Task</span></p>
</td>
<td width="277">
<p class="TableContents"><span style="font-size: 14px;">每一个作业，都需要拆分开了，交由多个服务器来完成，拆分出来的执行单位，就称为任务。</span></p>
</td>
</tr>
<tr>
<td width="109">
<p class="TableContents" align="center"><span style="font-size: 14px;">备份任务</span></p>
</td>
<td width="136">
<p class="TableContents" align="center"><span style="font-size: 14px;">Speculative Task</span></p>
</td>
<td width="142">
<p class="TableContents" align="center"><span style="font-size: 14px;">Buckup Task</span></p>
</td>
<td width="277">
<p class="TableContents"><span style="font-size: 14px;">每一个任务，都有可能执行失败或者缓慢，为了降低为此付出的代价，系统会未雨绸缪的实现在另外的任务服务器上执行同样一个任务，这就是备份任务。</span></p>
</td>
</tr>
</tbody>
</table>
<p>具体可以看博文<a href="http://www.cnblogs.com/duguguiyu/archive/2009/02/28/1400278.html">http://www.cnblogs.com/duguguiyu/archive/2009/02/28/1400278.html</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>google论文：GFS</title><link>http://www.cnblogs.com/billowkiller/archive/2013/04/10/3012085.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 10 Apr 2013 04:26:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/04/10/3012085.html</guid><description><![CDATA[<p>论文：<a href="http://www.cs.rochester.edu/meetings/sosp2003/papers/p125-ghemawat.pdf" target="_blank">英文版</a>，<a href="http://blademaster.ixiezi.com/2010/03/27/the-google-file-system%E4%B8%AD%E6%96%87%E7%89%88/" target="_blank">中文版</a></p>
<hr />
<h2>1. 导论</h2>
<p>&nbsp;<span style="line-height: 1.5;">先给个定义：GFS是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，但可以提供容错功能。它可以给大量的用户提供总体性能较高的服务。</span></p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/GoogleFileSystemGFS.svg/500px-GoogleFileSystemGFS.svg.png" alt="" width="500" height="297" /></p>
<p><em>Google File System. Designed for system-to-system interaction, and not for user-to-system interaction. The chunk servers replicate the data automatically.</em></p>
<p><strong>Assumptions in Google File System (GFS)</strong></p>
<ul>
<li>GFS should be built with commodity hardware
<ul>
<li>Inexpensive disks and machines</li>
</ul>
</li>
<li>GSF stores a modest number of large files
<ul>
<li>GSF stores a modest number of large files
<ul>
<li>e.g. Big-table, Map-Reduce records</li>
</ul>
</li>
<li>Do not optimize for small files</li>
</ul>
</li>
<li>Workloads
<ul>
<li>Large streaming reads (1MB or more) and small random reads (a few KBs)</li>
<li>Sequential appends to files by hundreds of data producers
<ul>
<li>Utilizing the fact that files are seldom modified again</li>
</ul>
</li>
</ul>
</li>
<li>High sustained bandwidth is more important than latency
<ul>
<li>Response time for individual read and write is not critical</li>
</ul>
</li>
</ul>
<p><strong>Prerequisite</strong></p>
<ol>
<li>组件失效被认为是常态事件，而不是意外事件。</li>
<li>以通常的标准衡量，我们的文件非常巨大。</li>
<li>绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。</li>
<li>应用程序和文件系统API的协同设计提高了整个系统的灵活性。e.g.
<ul>
<li>&nbsp;放松了在GFS一致性模型的要求</li>
<li>引入了原子性的记录追加操作</li>
<li>三个冗余的数据可以不是位一致，但是要求校验和验证</li>
</ul>
</li>
<li>系统的工作负载
<ul>
<li><span style="color: #ff0000;">读操作</span>
<ul>
<li>大规模的流式读取</li>
<li>小规模的随机读取</li>
</ul>
</li>
<li><span style="color: #ff0000;">写操作</span>
<ul>
<li>许多大规模的、顺序的、数据追加方式的写操作</li>
</ul>
</li>
</ul>
</li>
<li>系统必须高效的、行为定义明确的实现多客户端并行追加数据到同一个文件里
<ul>
<li>使用最小的同步开销来实现的原子的多路追加数据操作是必不可少的</li>
<li>文件可以在稍后读取，或者是消费者在追加的操作的同时读取文件</li>
</ul>
</li>
<li>高性能的稳定网络带宽远比低延迟重要
<ul>
<li>高速率的、大批量的处理数据</li>
<li>极少有程序对单一的读写操作有严格的响应时间要求</li>
</ul>
</li>
</ol>
<h2><strong>2. 架构</strong></h2>
<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/ache_zps14a9a2bc.png" alt="" /></p>
<ul>
<li>Files are divided into chunks</li>
<li>Fixed-size chunks (64MB)</li>
<li>Replicated over chunkservers, called <span style="color: #ff0000;">replicas</span></li>
<li>Unique 64-bit chunk handles</li>
<li>
<p>Chunks as Linux files</p>
</li>
<li>
<p>Single master</p>
</li>
<li>Multiple chunkservers
<ul>
<li>Grouped into Racks</li>
<li>Connected through switches</li>
</ul>
</li>
<li>Multiple clients</li>
<li>Master/chunkserver coordination
<ul>
<li><span style="color: #ff0000;">HeartBeat </span>messages</li>
</ul>
</li>
</ul>
<p><span style="color: #000000;"><strong><em>注意逻辑的Master节点和物理的Master服务器的区别</em></strong></span></p>
<h3>Master节点</h3>
<p>Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。Master节点还管理着系统范围内的活动，比如，Chunk租用管理、失效Chunk的回收、以及Chunk在Chunk服务器之间的迁移。</p>
<p>单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，我们必须减少对Master节点的读写，避免Master节点成为系统的瓶颈。客户端并不通过Master节点读写文件数据。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和Chunk服务器进行数据读写操作。</p>
<h3>Master服务器</h3>
<p>Master服务器存储3种主要类型的元数据，包括：<span style="color: #ff0000;">文件和Chunk的命名空间</span>、<span style="color: #ff0000;">文件和Chunk的对应关系</span>、<span style="color: #ff0000;">每个Chunk副本的存放地点</span>。所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。Master服务器不会持久保存Chunk位置信息。Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。</p>
<p>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。Master服务器能够保证它持有的信息始终是最新的，因为它控制了所有的Chunk位置的分配，而且通过周期性的心跳信息监控Chunk服务器的状态。</p>
<ul>
<li>简化了在有Chunk服务器加入集群、离开集群、更名、失效、以及重启的时候，Master服务器和Chunk服务器数据同步的问题。</li>
<li>只有Chunk服务器才能最终确定一个Chunk是否在它的硬盘上。Master服务器无需维护一个这些信息的全局视图</li>
</ul>
<h3>操作日志</h3>
<p>操作日志包含了关键的元数据变更历史记录。这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线。文件和Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。</p>
<p>必须确保日志文件的完整，确保只有在元数据的变化被持久化后，日志才对客户端是可见的。把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求。</p>
<p>为了缩短Master启动的时间，我们必须使日志足够小。Master服务器在日志增长到一定量时对系统状态做一次<span style="color: #ff0000;">Checkpoint</span>，将所有的状态数据写入一个Checkpoint文件。在灾难恢复的时候，Master服务器就通过从磁盘上读取这个Checkpoint文件，以及重演Checkpoint之后的有限个日志文件就能够恢复系统。</p>
<p>由于创建一个Checkpoint文件需要一定的时间，所以Master服务器的内部状态被组织为一种格式，这种格式要确保在Checkpoint过程中不会阻塞正在进行的修改操作。</p>
<h3><strong>一致性模型</strong></h3>
<ul>
<li><span style="color: #ff0000;">Relaxed</span> consistency model</li>
<li>
<p>Two types of mutations</p>
<ul>
<li>Writes
<ul>
<li>Cause data to be written at an application-specified file offset</li>
</ul>
</li>
<li>Record appends
<ul>
<li>Operations that append data to a file</li>
<li>Cause data to be appended <span style="color: #ff0000;">atomically at least once</span></li>
<li>Offset chosen by GFS, not by the client</li>
</ul>
</li>
</ul>
</li>
<li>
<p>States of a file region after a mutation</p>
<ul>
<li>Consistent
<ul>
<li>All clients see the same data, regardless which replicas they read from</li>
</ul>
</li>
<li>Defined
<ul>
<li>consistent + all clients see what the mutation writes in its entirety</li>
</ul>
</li>
<li>Undefined
<ul>
<li>consistent +but it may not reflect what any one mutation has written</li>
</ul>
</li>
<li>Inconsistent
<ul>
<li>Clients see different data at different times</li>
<li>The client retries the operation</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>经过了一系列的成功的修改操作之后，GFS确保被修改的文件region是已定义的，并且包含最后一次修改操作写入的数据。GFS通过以下措施确保上述行为：（a） 对Chunk的所有副本的修改操作顺序一致，（b）使用Chunk的版本号来检测副本是否因为它所在的Chunk服务器宕机而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master服务器也不再返回这个Chunk副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。</p>
<p>使用GFS的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：</p>
<ul>
<li>尽量采用追加写入而不是覆盖</li>
<li>Checkpoint
<ul>
<li>to verify how much data has been successfully written</li>
</ul>
</li>
<li>自验证的写入操作
<ul>
<li><span style="color: #ff0000;">Checksums </span>to detect and remove <em>padding</em></li>
</ul>
</li>
<li>自标识的记录。
<ul>
<li><span style="color: #ff0000;">Unique Identifiers</span> to identify and discard <em>duplicates</em></li>
</ul>
</li>
</ul>
<h2><strong>3. 系统交互</strong></h2>
<ul>
<li>Master uses leases to maintain a consistent mutation order among replicas</li>
<li>Primary is the chunkserver who is granted a chunk lease</li>
<li>All others containing replicas are secondaries</li>
<li>Primary defines a mutation order between mutations</li>
<li>
<p>All secondaries follows this order</p>
</li>
<li>
<p>数据流和控制流分开</p>
</li>
<li>数据以<span style="color: #ff0000;">管道</span>的方式，顺序的沿着一个精心选择的Chunk服务器链推送
<ul>
<li>Data transfer is pipelined over TCP connections</li>
<li>Each machine forwards the data to the &ldquo;closest&rdquo; machine</li>
<li>全双工的交换网络</li>
</ul>
</li>
<li><strong>Benefits</strong>：Avoid bottle necks and minimize latency</li>
</ul>
<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/c_zps5923b611.png" alt="" /></p>
<ol>
<li>客户机向Master节点询问哪一个Chunk服务器持有当前的租约，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约。</li>
<li>Master节点将主Chunk的标识符以及其它副本（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</li>
<li>客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的内部LRU缓存中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会哪个Chunk服务器保存了主Chunk。</li>
<li>当所有的副本都确认接收到了数据，客户机发送写请求到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户机，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中。</li>
<li>主Chunk把写请求传递到所有的二级副本。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</li>
<li>所有的二级副本回复主Chunk，它们已经完成了操作。</li>
<li>主Chunk服务器回复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</li>
</ol>
<h3>记录追加的原子性</h3>
<ul>
<li>The client specifies only the data (not file offset)</li>
<li>Similar to writes
<ul>
<li>Mutation order is determined by the primary</li>
<li>All secondaries use the same mutation order</li>
</ul>
</li>
<li>GFS appends data to the file <span style="color: #ff0000;">at least once atomically</span>
<ul>
<li>The chunk is padded if appending the record exceeds the maximum size --&gt; <em>padding</em></li>
<li>If a record append fails at any replica, the client retries the operation --&gt; <em>record duplicates</em></li>
<li>File region may be defined but interspersed with <em>inconsistent</em></li>
</ul>
</li>
</ul>
<h3>快照</h3>
<ul>
<li>Goals
<ul>
<li>To quickly create branch copies of huge data sets</li>
<li>To easily checkpoint the current state</li>
</ul>
</li>
<li><span style="color: #ff0000;">Copy-on-write</span> technique
<ul>
<li>Metadata for the source file or directory tree is duplicated</li>
<li>Reference count for chunks are incremented</li>
<li>Chunks are copied later at the first write</li>
</ul>
</li>
</ul>
<h3><strong>Master Operation</strong></h3>
<ul>
<li>Namespaces are represented as a lookup table mapping full pathnames to metadata</li>
<li>Use locks over regions of the namespace to ensure proper serialization</li>
<li>
<p>Each master operation acquires a set of locks before it runs</p>
</li>
<li>
<p>GFS has no directory (i-node) structure</p>
<ul>
<li>Simply uses directory-like file names: /foo, /foo/bar
<ul>
<li>Thus listing files in a directory is slow</li>
</ul>
</li>
</ul>
</li>
<li>Concurrent Access
<ul>
<li>Read lock on a parent path, write lock on the leaf file name
<ul>
<li>protect delete, rename and snapshot of in-use files</li>
</ul>
</li>
</ul>
</li>
<li>Rebalancing
<ul>
<li>Places new replicas on chunk servers with below-average disk space utilizations</li>
</ul>
</li>
<li>Re-replication
<ul>
<li>When the number of replicas falls below 3 (or user-specified threshold)
<ul>
<li>The master assigns the highest priority to copy (clone) such chunks</li>
</ul>
</li>
<li>Spread replicas of a chunk across racks</li>
</ul>
</li>
</ul>
<p><strong>Example of Locking Mechanism</strong></p>
<p>Preventing /home/user/foo from being created while /home/user is being snapshotted to /save/user</p>
<ul>
<li>Snapshot operation
<ul>
<li>Read locks on /home and /save</li>
<li>Write locks on <span style="color: #ff0000;">/home/user </span>and /save/user</li>
</ul>
</li>
<li>File creation
<ul>
<li>read locks on /home and <span style="color: #ff0000;">/home/user</span></li>
<li>write locks on /home/user/foo</li>
</ul>
</li>
<li>Conflict locks on /home/user</li>
</ul>
<h2>4. 其他细节</h2>
<h3><strong>垃圾回收</strong></h3>
<ul>
<li>Deleted files
<ul>
<li>Deletion operation is logged</li>
<li>File is renamed to a hidden name(<span style="color: #ff0000;">deferred deletion</span>)， then may be removed later or get recovered</li>
<li>The master regularly scans and removes hidden files, existed more than three days
<ul>
<li>HeartBeat messages inform chunk servers of deleted chunks</li>
</ul>
</li>
</ul>
</li>
<li>Orphaned chunks (unreachable chunks)
<ul>
<li>Identified and removed during a regular scan of the chunk namespace</li>
</ul>
</li>
<li>Stale replicas
<ul>
<li><span style="color: #ff0000;">Chunk version numbering</span>
<ul>
<li>increases when the master grants a new lease of the chunk</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Replica Operations</h3>
<ul>
<li>Creation
<ul>
<li>Disk space utilization</li>
<li>Number of recent creations on each chunkserver</li>
<li>Spread across many racks</li>
</ul>
</li>
<li>Re-replication
<ul>
<li><span style="color: #ff0000;">Prioritized</span>: How far it is from its replication goal&hellip;</li>
<li>The highest priority chunk is cloned first by copying the chunk data directly from an existing replica</li>
</ul>
</li>
<li>Rebalancing
<ul>
<li>Periodically</li>
</ul>
</li>
</ul>
<h3>Fault Tolerance</h3>
<ul>
<li>Fast Recovery
<ul>
<li>The master and the chunk server are designed to restore their state in seconds no matter how they terminated.</li>
<li>Servers are routinely shut down just by killing the process</li>
</ul>
</li>
<li>Master Replications
<ul>
<li>Master has the maps from file names to chunks</li>
<li>One (primary) master manages chunk mutations
<ul>
<li>Several shadow masters are provided for read-only accesses
<ul>
<li>Snoop operation logs and apply these operations exactly as the primary does</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Data Integrity
<ul>
<li>Corruption of stored data
<ul>
<li>High temperature of storage devices causes such errors</li>
</ul>
</li>
<li>Checksums for each 64KB in a chunk
<ul>
<li>chunk servers verifies the checksum of data before sending it to the client or other chunk servers</li>
</ul>
</li>
</ul>
</li>
</ul>]]></description></item><item><title>Design Pattern--Principle</title><link>http://www.cnblogs.com/billowkiller/archive/2013/03/31/2991769.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sun, 31 Mar 2013 07:02:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/03/31/2991769.html</guid><description><![CDATA[<p>Head First Design Patterns</p>
<hr />
<p>&nbsp;</p>
<p>1. Identify the aspects of your application that vary and separate them from what stays the same.</p>
<p>　　Take the parts that vary and encapsulate them, so that later you can alter or extend the parts that vary without affecting those that don't.</p>
<p>&nbsp;</p>
<p>2. Program to an interface, not an implementation.</p>
<p>　　Our intuition to solve problems is relying on an implementation, either in the superclass or in the subclass itself. We were locked into using that specific implementation and there was no room for changing out the behavior other than writing more code.</p>
<p>　　With a new design, the subclasses will use a behavior represented by an interface, so that the actual implementation of the behavior won't be locked.</p>
<p>　　ps: <em>program to an interface&nbsp;</em>really means <em>program to a supertype.&nbsp;</em>In JAVA, it means interface or abstract class.</p>
<p>　　　　Even better, you can assign the concrete implementation object at runtime.</p>
<p>&nbsp;</p>
<p>3. Favor composition over inheritance.</p>
<p>　　Creating systems using composition gives you a lot more flexibility. Not only does it let you encapsulate a family of algorithms into their own set of classes, but it also lets you change behaviror at runtime.</p>
<p>&nbsp;</p>
<p>4. Strive for loosely coupled designs between objects that interact.</p>
<p>　　When two objects are loosely coupled, they can interact, but have very little knowledge of each other.</p>
<p>　　Loosely coupled designs allow us to build flexible OO systems that can handle change because they minimize the interdependency between objects.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>google论文：big table</title><link>http://www.cnblogs.com/billowkiller/archive/2013/03/30/2991008.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sat, 30 Mar 2013 14:02:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/03/30/2991008.html</guid><description><![CDATA[<p>论文：<a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en//archive/bigtable-osdi06.pdf" target="_blank">英文版</a>， <a href="http://dblab.xmu.edu.cn/sites/default/files/20120508_172346_207.pdf" target="_blank">中文版</a></p>
<hr />
<h3>&nbsp;1. 导论</h3>
<p><span style="font-family: arial, helvetica, sans-serif;">BigTable is a compressed, high performance, and proprietary data storage system built on Google File System, Chubby Lock Service, SSTable (log-structured storage like LevelDB) and a few other Google technologies.（这句是wikipedia摘抄的定义）</span></p>
<p>&nbsp;构成：</p>
<ul>
<li><span>Scheduler</span></li>
<li><a href="http://www.cnblogs.com/billowkiller/archive/2013/04/10/3012085.html" target="_blank"><span>GFS</span></a></li>
<li><span>Chubby Lock service</span></li>
<li><span>Sawzall</span></li>
<li><a href="http://www.cnblogs.com/billowkiller/archive/2013/04/15/3022035.html" target="_blank"><span>MapReduce</span></a></li>
<li><span>SSTable</span></li>
<li><span>some compression algorithms</span></li>
</ul>
<p><span>先通俗几个名词：</span></p>
<p><span><span>Google File System</span></span></p>
<div>　　&bull;&nbsp;Large-scale distributed &ldquo;file system&rdquo;</div>
<div>　　&bull; <span style="color: #ff0000;">Master</span>: responsible for metadata</div>
<div>　　&bull;<span style="color: #ff0000;"> Chunk servers</span>: responsible for reading and writing large chunks of data</div>
<div>　　&bull; Chunks replicated on 3 machines, master responsible for ensuring replicas exist</div>
<div>&nbsp;</div>
<div>Chubby
<div><span style="color: #ff0000;">　　&bull; {lock/file/name} service</span></div>
<div>　　&bull; Coarse-grained locks, can store small amount of data in a lock</div>
<div>　　&bull; 5 replicas, need a majority vote to be active</div>
</div>
<div>
<div>&nbsp;</div>
<div><span>SSTable</span>
<div>　<span style="color: #ff0000;">　&bull; Immutable, sorted file of key-value pairs</span></div>
<div>　　&bull; Chunks of data plus an index</div>
<div class="O1">　　　　&ndash; Index is of block ranges, not values</div>
<div class="O1">　　　　&ndash; Index loaded into memory when SSTable is opened</div>
<div class="O1">　　　　&ndash; Lookup is a single disk seek</div>
<div>　　&bull; Alternatively, client can load SSTable into mem</div>
<div><img src="http://images.cnitblog.com/blog/434023/201303/30210501-5a1c2d5da5104b979ea6d2567f37edfb.png" alt="" /></div>
<div>&nbsp;</div>
<div><span style="line-height: 1.5;">Tablet&nbsp;</span></div>
<div>
<div><span>　　&bull;&nbsp;</span><span>Contains some range of rows of the table</span></div>
<div><span>　　&bull;&nbsp;</span><span>Unit of distribution &amp; load balance</span></div>
<div><span>　　&bull;&nbsp;</span><span>Built out of multiple </span><span>SSTables</span></div>
<div><span><img src="http://images.cnitblog.com/blog/434023/201303/30210659-c4b2010c6dee47f6a8f5c2c799ed1114.png" alt="" width="676" height="168" /></span></div>
<div>&nbsp;</div>
<div><span style="line-height: 1.5;">Table</span></div>
<div>
<div><span>　　&bull;&nbsp;</span><span>Multiple tablets make up the table</span></div>
<div><span>　　&bull;&nbsp;</span><span>SSTables</span><span> can be shared</span></div>
<div><span>　　&bull;&nbsp;</span><span>Tablets do not overlap, </span><span>SSTables</span><span> can overlap</span></div>
<div><span><img src="http://images.cnitblog.com/blog/434023/201303/30210828-a38c1e041a6d4add86c387cda95a24d2.png" alt="" width="509" height="234" /></span></div>
<div>&nbsp;</div>
<h3>&nbsp;2. 数据模型</h3>
</div>
</div>
</div>
</div>
<p><span>BigTable不能支持完整的关系型数据模型，只提供一个简单的数据模型，可以支持针对数据部署和格式的动态控制，允许用户区推理底层存储所展现的数据的位置属性。这句话有些玄乎，其实就是nosql的典型存储方式，不管你需要存储的数据有多大，是什么样的格式&mdash;&mdash;图片，音乐或者其他，bigtable都把它们当做字符串存储在GFS中。</span></p>
<p><span>这个数据模型世纪上市一个稀疏的、分布的、永久的多位排序图。采用row key，column key，timestamp对图进行索引。每个值都是未经解释的字节数组。</span><br />(row:string, column string, time:int64)&rarr;string</p>
<p>一个表中的行键，是任意的字符串(当前尺寸是64KB)， 对每一个行键所包含数据的读或写都是一个原子操作，而不管这个行中所包含的的列的数量多少。在行键上根据字典顺序对数据进行维护。对一个表而言，行区间是动态划分的，因为列的大小数量不确定。每一个行区间是一个Tablet，是负载均衡和数据分发的基本单位。</p>
<p>列键被分组为一个称为&ldquo;<span>Column family</span>&rdquo;的集合，是基本的访问控制单元。存储在一个列家族当中的所有数据通常都属于同一个数据类型。因为通常是对同一个列家族中的数据一起压缩。存储上也是面向列进行的。列键的命名方式为<span>Column&nbsp;</span><span style="line-height: 1.5;">family:qualifier。</span><span style="line-height: 1.5;">Family is heavyweight, qualifier lightweight，即为，列家族很少变化，基本上是固定的，但是修饰符可以是任意字符串。</span></p>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US">这里给出一个实际的例子。假设我们想要拷贝一个可能被很多项目都是用的、很大的网页集合以及相关的信息，让我们把这个特定的表称为Webtable。在Webtable当中，我们使用URL作为行键，网页的不同方面作为列键，并把网页的内容存储在contents:column中，如图所示。<span>通过对URL地址进行反转，属于同一个领域的网页都会被分组到连续的行中。例如，在键com.google.maps/index.html下面存储maps.google.com/index.html中包含的数据。把来自同一个领域的数据彼此临近存储，使得一些领域分析更加高效。</span></span></span></p>
<p><img src="http://dblab.xmu.edu.cn/sites/default/files/images/datamodel.jpg" alt="Google Bigtable，厦门大学，厦门大学计算机系，数据库实验室，林子雨" width="697" height="166" /></p>
<p><em><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US">&nbsp;</span><span>存储了网页数据的</span><span lang="EN-US" xml:lang="EN-US">Webtable</span><span>的一个片段。行名称是反转的</span><span lang="EN-US" xml:lang="EN-US">URL</span><span>，</span><span lang="EN-US" xml:lang="EN-US">contents</span><span>列家族包含了网页内容，</span><span lang="EN-US" xml:lang="EN-US">anchor</span><span>列家族包含了任何引用这个页面的</span><span lang="EN-US" xml:lang="EN-US">anchor</span><span>文本。</span><span lang="EN-US" xml:lang="EN-US">CNN</span><span>的主页被</span><span lang="EN-US" xml:lang="EN-US">Sports Illustrated</span><span>和</span><span lang="EN-US" xml:lang="EN-US">MY-look</span><span>主页同时引用，因此，我们的行包含了名称为</span><span lang="EN-US" xml:lang="EN-US">&rdquo;anchor:cnnsi.com&rdquo;</span><span>和</span><span lang="EN-US" xml:lang="EN-US">&rdquo;anchor:my.look.ca&rdquo;</span><span>的列。每个</span><span lang="EN-US" xml:lang="EN-US">anchor</span><span>单元格都只有一个版本，</span><span lang="EN-US" xml:lang="EN-US">contents</span><span>列有三个版本，分别对应于时间戳</span><span lang="EN-US" xml:lang="EN-US">t3,t5</span><span>和</span><span lang="EN-US" xml:lang="EN-US">t6</span><span>。</span></span></em></p>
<h3><span>3. 实现&nbsp;</span></h3>
<p><span>BigTable实现包括三个主要的功能组件：(1)库函数：链接到每个客户端，（2）一个主服务器，（3）许多Tablet服务器。</span>&nbsp;</p>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US">主服务器负责把Tablet分配到Tablet服务器，探测Tablet服务器的增加和过期，进行Table服务器的负载均衡，以及GFS文件系统中的垃圾收集。除此以外，它还处理模式变化，比如表和列家族创建。</span></span></p>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US">每个Tablet服务器管理一个Tablet集合，通常，在每个Tablet服务器上，会放置10到1000个Tablet。Tablet服务器处理针对那些已经加载的Tablet而提出的读写请求，并且会对过大的Tablet进行划分。</span></span></p>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US"><span>客户端并不是直接从主服务器读取数据，而是直接从Tablet服务器上读取数据。因为BigTable客户端并不依赖于主服务器来获得Tablet的位置信息，所以，大多数客户端从来不和主服务器通信。从而使得在实际应用中，主服务器负载很小。</span></span></span></p>
<p><img style="line-height: 1.5;" src="http://images.cnitblog.com/blog/434023/201303/30212406-a7b6fa2ced51443eb5d8660694dfae2d.png" alt="" width="620" height="392" /></p>
<h3>&nbsp;4. tablet查找</h3>
<div><span>因为tablet是从一个服务器到另外一个服务器移动的，那么怎么找到一个特定的row在哪个服务器上存储呢？</span></div>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US"><span><span>使用了一个类似于</span><span lang="EN-US" xml:lang="EN-US">&nbsp;B+</span><span>树的三层架构</span><span>，来存储</span><span lang="EN-US" xml:lang="EN-US">Tablet</span><span>位置信息。</span></span></span></span></p>
<p><img src="http://dblab.xmu.edu.cn/sites/default/files/images/Fig4(1).jpg" alt="" width="582" height="385" /></p>
<p>METADATA表中存储了二级信息，包括一个日志，它记载了和每个tablet有关的所有事件，比如，一个服务器什么时候开始提供这个tablet服务。这些信息对于性能分析和程序调试是非常有用的。&nbsp;</p>
<p>客户端函数库会缓存Tablet位置信息。如果客户端不知道一个Tablet的位置信息，或者它发现，它所缓存的Tablet位置信息部正确，那么，它就会在Tablet位置层次结构中依次向上寻找。如果客户端缓存是空的，那么定位算法就需要进行三次轮询，其中就包括一次从Chubby中读取信息。如果客户端的缓存是过期的，定位算法就要进行六次轮询，因为，只有在访问无效的时候才会发现缓存中某个entry是过期的（这里假设METADATA Tablets不会频繁移动）。虽然，Tablets位置信息是保存在缓存中，从而不需要访问GFS，但是，仍然通过让客户端库函数预抓取tablet位置信息，来进一步减少代价，具体方法是：每次读取METADATA表时，都要读取至少两条以上的Tablet位置信息。</p>
<p><span>每个Tablet只能被分配到一个tablet服务器。主服务器跟踪tablet服务器的情况，掌握当前tablet被分配到tablet服务器的情况，其中包括哪个tablet还没有被分配。当一个tablet没有被分配，并且一个具有足够空间可以容纳该tablet的tablet服务器是可用时，主服务器就把当前这个tablet分配给这个tablet服务器，主服务器会向tablet服务器发送一个tablet负载请求。</span></p>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US">&nbsp;BigTable使用Chubby来跟踪tablet服务器。当一个Tablet服务器启动的时候，它创建并且获得一个独占的排他锁，这个锁会锁住一个特定的Chubby目录中的一个唯一命名的文件。主服务器监视这个目录（服务器目录），来发现tablet服务器。如果一个tablet服务器停止服务，它就会丢失这个锁，比如，由于网络故障，导致这个tablet服务器丢失了这个Chubby会话。（Chubby提供了一个完善的机制，来允许一个tablet服务器检查自己是否已经丢失了这个独占排他锁）。如果丢失了锁，那么，只要目录中的这个文件还存在，那么一个tablet服务器就会努力去获得这个锁。如果文件不再存在，那么，这个tablet服务器就不再能够对外提供服务，因此，它就自杀。一旦一个tablet服务器终止了服务（比如，簇管理系统把这个tablet服务器从簇中移除），它就会努力释放锁，这样，主服务器就可以更快地重新分配这个tablet。</span></span></p>
<p><span style="color: #000000;"><span lang="EN-US" xml:lang="EN-US">主服务器需要探测，什么时候tablet服务器不再提供tablet服务，并且要负责尽快对这些tablet进行重新分配。为了探测什么时候tablet服务器不再提供tablet服务，主服务器会周期性地询问每个tablet服务器，了解他们的锁的状态。如果一个tablet服务器报告，它已经丢失了锁；或者，在最近的几次尝试中，主服务器都无法与tablet服务器取得联系，主服务器就会努力获得一个针对这个服务器文件的独占排他锁。如果主服务器可以获得这个锁，那么，Chubby就是可用的，相应地，这个tablet服务器或者已经死亡，或者有些故障导致它无法到达Chubby。因此，主服务器就从Chubby中删除这个tablet服务器的文件，从而确保这个tablet服务器不再能够提供服务。一旦一个服务器文件被删除，主服务器就可以把所有以前分配给该服务器的tablet，都移动到&ldquo;待分配&rdquo;tablet集合。为了保证一个BigTable簇不会轻易受到主服务器和Chubby之间的网络故障的影响，如果一个主服务器的Chubby会话过期了，这个主服务器就会自杀。但是，正如上所述，主服务器失效，不会改变tablet到table的分配。</span></span></p>
<h3>&nbsp;<span><span lang="EN-US" xml:lang="EN-US">5. 读写方式</span></span></h3>
<p>&nbsp;&nbsp;<img src="http://dblab.xmu.edu.cn/sites/default/files/images/Fig5.jpg" alt="" width="428" height="295" /></p>
<p>&nbsp;一个tablet的持久化存储是存在GFS当中，如图5所示。更新被提交到一个提交日志，日志中记录了redo记录。在这些更新当中，最近提交的更新被存放到内存当中的一个被称为memtable的排序缓冲区，比较老的更新被存储在一系列SSTable中。为了恢复一个tablet，tablet服务器从METADATA表当中读取这个tablet的元数据。这个元数据包含了SSTable列表，其中，每个SSTable都包括一个tablet和一个重做点（redo point）的集合，这些redo point是一些指针，它们指向那些可能包含tablet所需数据的重做日志。服务器把SSTable索引读入内存，并且重构memtable，方法是，执行重做点以后的所有已经提交的更新。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个写操作到达tablet服务器，服务器首先检查它是否是良好定义的，并且发送者是否被授权执行该操作。执行授权检查时，会从一个Chubby文件中读取具有访问权限的写入者的列表，这个Chubby文件通常总能够在Chubby客户端缓存中找到。一个有效的变化，会被写到提交日志中。分组提交是为了改进许多小更新[13,16]操作的吞吐量。在写操作已经被提交以后，它的内容就会被插入到memtable。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个读操作到达Tablet服务器，与写操作类似，服务器也会首先检查它是否是良好定义和得到授权的。一个有效地读操作是在以下二者的合并的基础上执行的，即一系列SSTable和memtable。由于SSTable和memtable是字典排序的数据结构，合并视图的执行是非常高效的。</p>
<p>&nbsp;<img style="line-height: 1.5;" src="http://images.cnitblog.com/blog/434023/201303/30213930-99817ed4d1154148869e43523bcc6f4b.png" alt="" width="438" height="314" /><span style="line-height: 1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="line-height: 1.5;">当tablet发生合并或分解操作时，正在到达的读写操作仍然可以继续进行。</span></p>
<h3>&nbsp;</h3>
<h3>6. 压缩</h3>
<p>压缩分为三种：</p>
<div><span style="color: #ff0000;">　　&bull;　　Minor compaction</span>&nbsp;<span style="line-height: 1.5;">&ndash; convert a full memtable into an SSTable, and start a new memtable</span></div>
<div class="O1">　　　　　　&ndash; Reduce memory usage</div>
<div class="O1">　　　　　　&ndash; Reduce log traffic on restart</div>
<div class="O1">&nbsp;</div>
<div><span style="color: #ff0000;">　　&bull;　　Merging compaction</span></div>
<div class="O1">　　　　　　&ndash; Reduce number of SSTables</div>
<div class="O1">　　　　　　&ndash; Good place to apply policy &ldquo;keep only N versions&rdquo;</div>
<div class="O1">&nbsp;</div>
<div><span style="color: #ff0000;">　　&bull;　　Major compaction</span></div>
<div class="O1">　　　　　　&ndash; Merging compaction that results in only one SSTable</div>
<div class="O1">　　　　　　&ndash; No deletion records, only live data</div>
<div class="O1">&nbsp;</div>
<h3 class="O1"><span>7. 完善措施</span></h3>
<ul>
<li><strong>locality group</strong>
</li>





</ul>
<div class="O1"><span><span>　　客户端可以把多个列家族一起分组到一个locality group中。我们会为每个tablet中的每个locality group大都创建一个单独的SSTable。把那些通常不被一起访问的列家族分割到不同的locality group，可以实现更高效的读。</span></span></div>
<div class="O1"><span><span><span>　　除此以外，一些有用的参数，可以针对每个locality group来设定。例如，一个locality group可以设置成存放在内存中。常驻内存的locality group的SSTable，采用被动加载的方式被加载tablet服务器的内存，即只有应用请求SSTable中的数据，而这些数据　　　又不在内存中时，才把SSTable加载到内存。一旦加载，属于这些locality group的列家族，就可以被应用直接访问，而不需要读取磁盘。这个特性对于那些被频繁访问的小量数据来说是非常有用的。</span></span></span></div>
<ul>
<li><strong>Compression</strong>
</li>





</ul>
<div class="O1">　　　客户端可以决定是否对相应于某个locality group的SSTable进行压缩，如果压缩，应该采用什么格式。用户自定义的压缩格式可以被应用到每个SSTable块中（块的尺寸可以采用与locality group相关的参数来进行控制）。虽然对每个块进行单独压缩会损失一些空间，但是，我们可以从另一个方面受益，当解压缩时，只需要对小部分数据进行解压，而不需要解压全部数据。许多客户端都使用&ldquo;两段自定义压缩模式&rdquo;。第一遍使用Bentley and McIlroy[6]模式，它对一个大窗口内的长公共字符串进行压缩。第二遍使用一个快速的压缩算法，这个压缩算法在一个16KB数据量的窗口内寻找重复数据。</div>
<ul>
<li><span><strong><span lang="EN-US" xml:lang="EN-US">Bloom filters</span></strong></span>
</li>





</ul>
<p><span lang="EN-US" xml:lang="EN-US"><span style="color: #000000;"><span>　　一个读操作必须从构成一个</span><span lang="EN-US" xml:lang="EN-US">tablet</span><span>的当前状态的所有</span><span lang="EN-US" xml:lang="EN-US">SSTable</span><span>中读取数据。如果这些</span><span lang="EN-US" xml:lang="EN-US">SSTable</span><span>不在内存中，我们就不得不需要很多磁盘访问。我们通过下面的方式来减少磁盘访问，即允许客户端来确定，为某个特定</span><span lang="EN-US" xml:lang="EN-US">locality group</span><span>中的</span><span lang="EN-US" xml:lang="EN-US">SSTable</span><span>创建</span><span lang="EN-US" xml:lang="EN-US">Bloom filter</span><span>。一个</span><span lang="EN-US" xml:lang="EN-US">Bloom filter</span><span>允许我们询问，一个</span><span lang="EN-US" xml:lang="EN-US">SSTabble</span><span>是否包含属于指定的&ldquo;行</span><span lang="EN-US" xml:lang="EN-US">-</span><span>列队&rdquo;的特定的数据。对于某个特定的应用，一个用来存储</span><span lang="EN-US" xml:lang="EN-US">Bloom filter</span><span>的很少量的</span><span lang="EN-US" xml:lang="EN-US">tablet</span><span>服务器内存空间，都可以极大减少读操作的磁盘访问次数。我们使用</span><span lang="EN-US" xml:lang="EN-US">Bloom filter</span><span>也意味着，许多针对目前不存在的行或列的查询，根本就不需要访问磁盘。</span></span></span></p>
<p>&nbsp;</p>]]></description></item><item><title>《看见》书摘</title><link>http://www.cnblogs.com/billowkiller/archive/2013/03/25/2980973.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Mon, 25 Mar 2013 08:17:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/03/25/2980973.html</guid><description><![CDATA[<div>
<div>隐隐有个感 觉，为了一个目的--哪怕是一个正义的 目的，就像车轮一样狠狠辗过人的心， 也是另一种戾气。<br /><br /></div>
<div>文战之前，明 知他腰里有银子，但被衣衫盖着，不知 道该怎么出剑，但经验告诉我，那就别 动。风动，树梢动，月光动，你别动， 就会看到端倪。</div>
<div>&nbsp;</div>
<div>阿甘是看见了什么，就走过去。别 的人，是看见一个目标，先订一个作战 计划，然后匍匐前进，往左闪，往右躲， 再弄个掩体&hellip;&hellip;一辈子就看他闪转腾挪 活得那叫一个花哨，最后哪儿也没到 达<br /><br />
当一个人表现得很有涵养， 其实是传递着不以为然的意思。</div>
<div>&nbsp;</div>

<span>一个过于主动甚至 积极坦白自己内心阴暗面的人，往往会 让原本想去挖掘他内心弱点的人感到尴 尬和一丝不安。</span><br /><br />
<div>雨下得又轻又细，深 青的群山全被濡湿了，去年的裂缝里青 草簌簌地拱动，湿黑的山坡上一层一层 墨绿的杉树林，梨花浅白，空气里都是 水滴和鸟叫。<br /><br />
你 有 自 己 认 识 事 物 的 坐 标 系<br /><br />
&ldquo;在市场经济中，有一条众所周知的 柴静 看见 678 规则：自由地买和卖，等价交换。在三 十年的改革开放之后，中国已经因为尊 重和适用这条规律，得到巨大的发展， 但是却在影响人口最多的土地问题上有 了一些例外。&rdquo; 多么寻常的一句话，我敝帚自珍， 看了又看。一个人从小到大拾人牙慧， 写日记的时候抄格言，做电台的时候念 别人文章，做电视了摸仿别人提问，像 是一直拄着拐杖的人，现在试着脱手， 踉踉跄跄，想站起来。<br /><br />
地拿过来了你去 发展市场经济，拿地的时候你是计划经 济，这事儿农民就吃亏了。<br /><br />
&ldquo;如果一方总占便宜，另一方总吃亏， 那么这样的商品交换，是不能持续下去 的。&rdquo; 不能持续下去的结果是什么？ 我握着笔，字歪歪斜斜写得飞快， 像扔了拐杖的人迈开打晃的腿往前跑。 &ldquo;不能持续下去的结果，就是中国大地 上，因此而起的各种冲突和群体性事件， 以至于&lsquo;征地&rsquo;这样一个普通的经济行 为，演变成为我们这个转型时代最重要 柴静 看见 680 的社会问题之一。&rdquo;<br /><br />
多读书。&rdquo;老爷子说，&ldquo;另外，存在即合理，你要接受。&rdquo;<br /><br />
听到自己经验之外或者与自己 观点相悖的意见，她脸上会流露出诧异、 惊奇、反感、不屑，想通过提问去评判 对方，刺激别人，想让对方纠正，那种 冷峻的正直里暗含着自负。<br /><br />
谓专制，就是坚信自己是不会错的想 法&rdquo;<br /><br />
日后工作上学，换了不少地方，去 哪儿都是拎箱子就走，不动感情，觉得 那样脆弱，认为独立就是脱离集体，不 依不附。亲近的人之间，一且触及自尊 心就会尖锐起来，绝不低头。<br /><br />
年底我生日，老郝开了瓶酒，做了 一大桌菜。吃完饭，灯忽然黑了，电视 上放出个片子，是老范瞒着我，拿只 DV 到处去采访人，片子配了我从小到大的 照片，还有音乐和烟花。我是真尴尬， 这么大了，没在私人生活里成为主角， 这么肉麻过。</div>

</div>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>]]></description></item><item><title>《蔡康永说话之道》书摘</title><link>http://www.cnblogs.com/billowkiller/archive/2013/03/25/2980154.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Mon, 25 Mar 2013 01:35:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/03/25/2980154.html</guid><description><![CDATA[<p>古古会说什么样的话，决定于她要在阿男的眼中，扮演什么样的人。她要扮的是欧巴桑，她就会说出欧巴桑爱说的话．她要扮未婚妻，就会说出未婚妻该说的话，她要扮美眉，就会说出美眉应说的话。 很多人以为你说什么样的话，透露出你是什么样的人。 但我觉得不只如此。我觉得：你说什么样的话，你就是什么样的人。 &ldquo;You are what you say.&rdquo; 你老是觉得你是可怜虫，别人都在欺负你，你确实就会常常说出可怜虫心态的话。但不只如此，反过来也一样你每句话都说可怜虫才会说的话，说久了，你就会是可怜虫。</p>
<p>&nbsp;</p>
<p>少给别人找麻烦的方法，就是把麻烦在自己手上就解决掉。</p>
<p>古古不必勉强自己吃日本料理，她只需要回答： &ldquo;喔，那我会吃饱再去餐厅跟你们会合，因为我不吃日本料理。&rdquo; 或者，&ldquo;我来帮大家订另外一家新开的泰国菜好不好?因为我不习惯吃日本料理。&rdquo;</p>
<p>&nbsp;</p>
<p>把无谓的胜利让给对方 懂得认输的人很懂说话&nbsp;</p>
<p>约会就是约会，就是要含情脉脉，吃喝点菜都是&ldquo;调情&rdquo;的好机会。面对外文菜单，你可以嘲笑自己在外文上闹过什么笑话，让对方觉得你好亲切；也可以趁机讲个自己去旅行时见识到的小风俗，让对方觉得你很见多识广。在这么做的时候，你当然要不时望着对方，带着点点观察，让对方充分感觉到，她在你眼中的存在。 讲到火锅要多辣的时候，看她有没有皱眉7看她有要起身的样子，虽然不用夸张到一个箭步移形换影去帮她拉椅子，但不妨贴心地告诉她，餐厅的化妆室在哪个方向。这些，都需要你保持&ldquo;眼角观察&rdquo;，但不必&ldquo;端详审视&rdquo;的。 很多人以为懂美食美酒，就是有品位的人，我一点都不同意。懂美食美酒的无聊蛋，我见多了。 跟这样的人聚会，你绝不会有&ldquo;如沐春风&rdquo;的感觉，因为他们没有&ldquo;以你为尊&rdquo;，而是&ldquo;以吃喝为尊&rdquo;。 一个人，如果能做到把对方&ldquo;看在眼里、放在心里&rdquo;，就算这个状态，只维持顿饭的时间，也能让对方觉得&ldquo;被重视&rdquo;，如沐春风。</p>
<p>&nbsp;</p>
<p>对篮球完全没兴趣，也不想听臭男生继续穷吹篮球经的古古，可以接什么呢? &ldquo;那小戈你一定常常熬夜看球赛啰？&rdquo;&mdash;&mdash;接下来就可以进一步聊他的生活作息了。 &ldquo;那小戈你都下多大的注&rdquo;&mdash;&mdash;接下来就可以进步聊他的金钱观了。 &ldquo;那你看球赛的时候，你以前的女朋友都不会抱怨喔？&rdquo;&mdash;&mdash;接下来就可以进一步聊他的感情史了。</p>
<p>谈话是发生在当下的事情，很少有人能同时听着你讲话，脑子里却一直惦记着三分钟前你讲了什么烂话题，这又不是期末考，教授在听你做报告，遇到会卡住的话题，就让它摔破在地上，用脚扫到沙发底下就结了。</p>
<p>&nbsp;</p>
<p>问的问题越具体， 回答的人越省力 问的问题越具体，回答的人越省力。回答的人越省力，他就越有力气和你聊下去。</p>
<p>问问题，最好有&ldquo;退路&rdquo;，也就是说，就算对方回答&ldquo;没有被骗过钱&rdquo;或者&ldquo;对王力宏那型的男人没有感觉&rdquo;的时候，你自己应该也有些相关的有趣的事可以讲，要不然，你的问题就应该是其他你有话可说的题目。如果你也没被骗过钱，那你比较适合改问&ldquo;你旅行时会乱买东西&rdquo;或&ldquo;有没有搭错车过&rdquo;等等你自己也有故事可说的题目。</p>
<p>喜欢什么样的国家、男生、衣服&hellip;&rdquo; 这种题目，其实也很不错，起码是很友善、也很安全的问题，但这类问题需要对方做一番归纳整理的工作，有点费对方的脑力。万一对方不擅于归纳整理，或刚好没力气动脑筋时，她可能就会回答-&ldquo;</p>
<p>我建议的发问方式，可以是先问两三个像是非题或选择题的具体问题，把对方有兴趣聊的范围给摸索出来，再用申论题往下问。</p>
<p>&nbsp;</p>
<p>聊天时， 每个人都想聊自已古古和阿男即使是在最亲密、最如胶似漆的时候，很遗憾，他们也仍然各自活在自己的世界里。 这是世界的真相每个人都活在自己的世界里。</p>
<p>&ldquo;尽量别让自己说出&lsquo;我&rsquo;字。&rdquo;</p>
<p>&nbsp;</p>
<p>如果问题这么尖锐，可以试着把心里假设的事，倒推回去两三步来问。比方说，小戈假设对方在吸毒，倒推回去两三步：吸毒是因为不快乐吗？不快乐是因为离婚吗？如果小戈是这样倒推的，那他可能可以先问对方：&ldquo;离婚以后，是不是过得很痛苦？&rdquo; 这个问题听起来很柔和，是朋友会问的问题，比较不像&ldquo;你是在吸毒吗？&rdquo;这种问题，太像审判者或警察问的问题，指责意味太强了。</p>
<p>另外，在公事上，必须问出尖锐的问题时，我建议拿&ldquo;抽象的第三方&rdquo;来当替死鬼。 比方说，老板做出了很蠢的决定，你想提醒老板这个决定很蠢，你就可以把你要问的问题，推给老板&ldquo;比较没辄&rdquo;的第三方势力。例如&ldquo;老板，全省的经销商他们叫我来请问您，如果您海报印这么大，他们要贴在哪里？&rdquo;这类的问法。</p>
<p>还有种说法，可以尽量把对方听来剌耳的，有审判味道的字眼，改成用些&ldquo;具体的陈述&rdquo;，例如．&ldquo;蔡教授，同事都在传你的论文是抄袭的&rdquo; 可以改成：&ldquo;蔡教授，我们收到这份英国的学术期刊，上面这篇论文，跟你上个月发表的那篇，内容上重叠的部分，大概有五千字&rdquo; 虽然用字比较多，但也显得比较具体，不像是直接指责对方，而是要求对方就事论事。</p>
<p>&nbsp;</p>
<p>交谈不是有奖金的竞赛 别急着枪答</p>
<p>东张西望就能看到的东西，当然就是对方愿意让别人看到的东西，可能也是他渴望被人提到或问起的东西。要是见不得人的东西，像情趣用品，或赃款赃物之类的，请放心，对方绝对藏得好好的</p>
<p>&nbsp;</p>
<p>自问自答， 站在对方的立场来想</p>
<p>周末你帮我值班好不好？下个月换我帮你。&rdquo;</p>
<p>"这个周末你有没有事呀？&rdquo;古古很愉悦地问同事，害得同事以为古古要相招一起出去玩。 &ldquo;我没事呀。&rdquo;同事回答。 &ldquo;那拜托你帮我值班好不好？下个月换我帮你。&rdquo; 嗯，古古大概会成功，因为同事掉进她的陷阱了。但同事可能会不再像以前那样，把古古当&ldquo;可能的朋友&rdquo;看待，这是古古在人际关系上付出的代价。</p>
<p>&nbsp;</p>
<p>如果碰到对方， 要求你跟他站在同一阵线</p>
<p>因为人嘛，活在当下，话出如风，谈话的节奏说变就变，大可不必费心地非要找个平滑的方式，从无趣的话题&ldquo;滑向&rdquo;别的话题。干净利落地直接转弯就可以。</p>
<p>&nbsp;</p>
<p>最好是把需要对方帮忙的事，拆解成很具体的，听了不会下就失去耐心的一个一个小步骤，然后先提出最小的要求，这样不会被立刻拒绝。比方说，你们店家办了促销活动，想找附近的店家共同参与，壮大声势。可以计划第步先去向附近的店家询问，问他们如果为这个活动印了传单，可不可以把附近店家的店名和店址，一并印在传单的地图上？这种白捡到的宣传，通常对方应该会欣然答应。这样，等到传单印好以后，这些附近店家也自然会答应在自家的收银柜台上摆放这份传单，来吸引顾客目光。 当然，这只是取得对方好感，使对方愿意帮忙的第一步。 旦附近店家答应让你放传单，接下来再答应进一步合作的可能性就定会提高。不管是需要附近店家起播放同样的音乐，或者在店门口的车位上做协调，都比较容易得到对方的帮忙了。</p>
<p>&nbsp;</p>
<p>只听字面的意思就做决定恐怕机会就跑掉了</p>
<p>共进晚餐之后，小戈进步邀古古去看电影。 &ldquo;不行耶，我定要在十点以前回家&hellip;&hellip;&rdquo;古古说。 古古说的这句话，字面上的意思，谁都听得懂。 但如果想要把古古真正的心意搞清楚，那这句话里的线索，就是你继续探索她心意的依据。 &ldquo;是要赶回家去看影集喔？&rdquo;可以这样问，称称你在她心中的分量。如果跟你约会看电影，还比不上她回家一个人看影集，那你当然就知道自己很需要加油了。 &ldquo;是妈妈规定的门禁时间喔？&rdquo;也可以这样问，方面了解一下这个女生的生活可以自己做主的程度，一方面了解下她的家人状况。 &ldquo;看完电影也才十二点呀，我会开车送你到家的。&rdquo;也可以干脆假设她是要赶搭末班捷运，先替她想好交通疑虑的解决之道。这样她也就会回答你：&ldquo;不是担心错过捷运啦，而是&hellip;&hellip;&rdquo;这类提供给你更多线索的回答。 如果古古说定要十点之前回家，小戈就&ldquo;喔&rdquo;一声，然后就放弃继续邀她看电影，这样就实在很难夸奖小戈有&ldquo;听懂&rdquo;的能力。因为人说话，常常是&ldquo;语带保留&rdquo;或者&ldquo;话中有话&rdquo;，你只听字面的意思，就做决定，恐怕机会就跑掉了。</p>
<p>&nbsp;</p>
<p>别人骂你句，你回骂他句，这叫吵架．别人赞美你一句，你回一句赞美，这就叫社交</p>
<p>&nbsp;</p>
<p>只要使用太多&ldquo;业界&rdquo;的用语、流露太多&ldquo;业界&rdquo;的习性，一般人听起来，都会闻到一股&ldquo;不够生活&rdquo; &ldquo;不够真心&rdquo;的气味。</p>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>]]></description></item><item><title>linux 内核编译安装及卸载</title><link>http://www.cnblogs.com/billowkiller/archive/2013/02/28/2936984.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Thu, 28 Feb 2013 07:27:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/02/28/2936984.html</guid><description><![CDATA[<p>编译安装：</p>
<p>下载需要的包</p>
<p><span>apt-get install kernel-package libncurses5-dev fakeroot wget bzip2</span></p>
<p>&nbsp;</p>
<p>cp linux-3.x.x /usr/src</p>
<p>cd /usr/src/linux-3.x.x</p>
<p><span>make menuconfig</span></p>
<p><span><span>make modules</span></span></p>
<p><span>make modules_install</span></p>
<p><span>make</span></p>
<p><span>make install</span></p>
<p class="p0"><span>sudo&nbsp;mkinitramfs&nbsp;-o&nbsp;/boot/initrd.img-3.x.x</span></p>
<p class="p0"><span>sudo&nbsp;update-initramfs&nbsp;-c&nbsp;-k 3.x.x</span></p>
<p class="p0"><span>sudo&nbsp;update-grub2</span></p>
<hr />
<p class="p0">&nbsp;</p>
<p class="p0"><span>卸载：</span></p>
<p>&nbsp;custom compiled kernel you need to remove following files/dirs:</p>
<ul>
<li>/boot/vmlinuz*KERNEL-VERSION*</li>
<li>/boot/initrd*KERNEL-VERSION*</li>
<li>/boot/System-map*KERNEL-VERSION*</li>
<li>/boot/config-*KERNEL-VERSION*</li>
<li>/lib/modules/*KERNEL-VERSION*/</li>
<li>Update grub configuration file /etc/grub.conf or /boot/grub/menu.lst to point to correct kernel version.</li>
</ul>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154052.user.js"></script>
<script type="text/javascript" src="http://userscripts.org/scripts/source/154053.user.js"></script>]]></description></item><item><title>浮现式设计</title><link>http://www.cnblogs.com/billowkiller/archive/2013/02/27/2935812.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 27 Feb 2013 13:29:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/02/27/2935812.html</guid><description><![CDATA[<p><strong>refine from <em>浮现式设计&mdash;&mdash;专业软件开发的演讲本质</em></strong></p>
<hr />
<p>&nbsp;</p>
<p>软件开发成功的定义：</p>
<ul>
<li>软件按时交付</li>
<li>创建软件的成本符合原计划的成本</li>
<li>软件能够做它需要做的事情</li>
<li>软件没有bug&ldquo;缠身&rdquo;</li>
<li>软件正常投入使用，确实产生了积极的作用。它有价值。</li>
</ul>
<p>软件开发存在<strong>墨菲定律</strong>：事情如果有变坏的可能，不管这种可能性有多小，它总会发生。</p>
<p>&nbsp;</p>]]></description></item><item><title>硝烟中的Scrum和XP</title><link>http://www.cnblogs.com/billowkiller/archive/2013/02/26/2934294.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Tue, 26 Feb 2013 13:51:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/02/26/2934294.html</guid><description><![CDATA[<p><strong>refine from<em>&nbsp;硝烟中的Scrum和XP--我们如何实施Scrum</em></strong></p>
<hr />
<p>产品的backlog时Scrum的核心，也是一切的起源，从根本上说，它就是一个需求或故事特性等组成的列表，按照重要性的级别进行排序。它里面包含的是客户想要的东西，并用客户的术语加一描述。</p>
<p>backlog的另外一个名称是故事。包括以下字段：</p>
<ul>
<li>ID</li>
<li>Name：一个简短的描述</li>
<li>Importance：100以内打分，分数越高越重要</li>
<li>Initial estimate：最小单位为stroy point，即为人天。估值无需准确，但是要保证相对的正确性。</li>
<li>How to demo：简短的测试规范，先做啥，然后做啥，最后做啥，得到什么结果。</li>
<li>Notes：相关信息，解释说明，对其他资料的引用等等，简短。</li>
</ul>
<p>额外的字段，根据需要：</p>
<ul>
<li>Track：当前故事的大致分类（后台系统，优化...）</li>
<li>Components：再多个Scrum团队协作的时候很有用，包括数据库，服务器，客户端等组件</li>
<li>Requestor：哪个客户活相关人员最先提出的需求，再后续的开发过程中向他反馈</li>
<li>Bug tracking ID</li>
</ul>
<p>产品的backlog应该停留再业务层次上，例如给Events表添加索引，潜在的目标是&ldquo;提高再后台系统中搜索事件表单的相应速度&rdquo;，这时需要改写，原先的目标作为一个注释存在。</p>
<p>产品负责人维护backlog，理解每个故事的含义，不需要知道故事的具体实现，但是要知道为什么这个故事会在这里。其他人向负责人申请故事，负责人对它们划分先后次序。</p>
<p>sprint计划会议产生的成果：</p>
<ul>
<li>sprint目标</li>
<li>团队成员名单（以及他们的投入程度）</li>
<li>sprint backlog</li>
<li>确定好sprint演示日期</li>
<li>确定每日Scrum会议的时间和地点</li>
</ul>
<p>过程中实践TDD（测试驱动开发），包括开发和提问需求方式...</p>
<p>故事可以分成更小的故事，而小故事又可以分成任务。</p>
<p>一些重要的开发概念：</p>
<ul>
<li>结对编程</li>
<li>测试驱动开发：Juit/httpnit/JWebUnit，HSQLDB，Jetty，Cobertura，mock</li>
<li>增量设计</li>
<li>代码集体所有权</li>
<li>持续集成：Maven，QuickBuild</li>
<li>代码标准</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>互联网发展方向思考</title><link>http://www.cnblogs.com/billowkiller/archive/2013/02/25/2932738.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Mon, 25 Feb 2013 13:39:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/02/25/2932738.html</guid><description><![CDATA[<p><em>edited from <a href="http://www.36kr.com/p/201525.html">36氪</a></em></p>
<hr />
<p>&nbsp;</p>
<p><img title="T-E-C-H法则" src="http://a.36krcnd.com/photo/c9ef3536af556bb5530af32befaaeae8.png" alt="" width="680" height="478" /></p>
<p>&nbsp;在互联网领域，要找到新的创新点，还是需要借鉴美国发展的模式。虽然美国与中国有着各自不同的国情，美国成功的应用在中国不一定可以找到适合它们的土壤，但是从中国几个新兴的创业巨头来看，无一不是根植与美国，由于中国的网络壁垒或者美国应用的本土化不强而创造出在中国的机会。从发展上看来，都是有先有多家startup的成立，在各自独立发展用户，或从相同的客户群中寻找潜在的用户资源，或是在不同的用户群众寻找，但是有一个共同点都是在美国成功的应用中进行借鉴。从《结网》中可以看到，对一个新兴的应用来说最为关键的不止是借鉴先有的成功的应用，还需要找到这个应用idea的起源，因为这里面包含有应用最核心的本质。在各个独立应用发展到一定阶段，圈到了一定的用户之后，关键在与培养用户的黏合度，用户是不是对这个产品有所依赖，是不是形成技术壁垒和用户壁垒即特定的用户群。在成功圈到一定用户之后，开始扩张领域，向其他同类产品拼抢用户资源，开始了互联网中最残酷的战争，这时也是公司最应该小心的时候，水桶中的任何一块木头都可能是潜在的漏洞，给对手带来机会。所以，方向的选择、良好的产品发展思路和绝对的执行力是成功的三大要素。从方向上来看我们习惯盯准美国，而美国的核心是加州，加州的辐射点是硅谷，硅谷的成功很大程度上在standford。关注standford。</p>
<p>&nbsp;</p>
<p><em><strong>近期的互联网方向</strong></em></p>
<p>在近期的互联网方向，有三个方向值得注意：</p>
<p>1. 移动习惯培养</p>
<p>从最近极为成功的应用中都可以看到它们的影子，twitter，yelp，dropbox等等。但是<span>作为存储、计算和执行终端的手机，未来将不仅仅给出信息和推荐，而是直接参与规划和执行。<span>所谓的习惯培养，应该一脉相承的应用整合平台。只是如今市场浑水一汪，想要出类拔萃实在不易。</span></span></p>
<p><span>2. 企业级应用</span></p>
<p><span><span>企业应用（X to C）的行业准入壁垒高，往往在研发、投市、特别是赢得企业最终订单上的投入，并非一般 start-up 能企及。在美国前景看佳，完全由于美国大公司从来没有&ldquo;节源&rdquo;的概念&mdash;&mdash;花的多？那我们挣得更多就是了。</span></span></p>
<p><span><span>在中国大多数都被国有企业给垄断，所以不是很被看好。</span></span></p>
<p><span><span>3. 软硬件结合的小玩具</span></span></p>
<p><span><span><span>主要指 API-able 的硬件（模件）搭载简易运算软件的生活用品，很多用品都是一飞冲天，在VC上看来，这类产品是有极高的投资价值的。</span></span></span></p>
<p>&nbsp;</p>
<p><strong><em>初创精神的DNA</em></strong></p>
<p>校园最深重又新鲜的记忆来源于是小团体，死党，外加食堂。初创团队也应当打成一片，鱼雷都炸不开，而每个人又因性格、功能的不同，各自作为一个节点向外缘延伸出触角，感知社会和用户的反馈。Felisa 总结出初创团队最常见的三种交际方式：</p>
<p>&bull; 以&ldquo;盈利&rdquo;为驱动的纵向交际<br />&bull; 以&ldquo;功能&rdquo;为纽带的横向交际<br />&bull; 以&ldquo;吃吃喝喝&rdquo;为纽带的点面交际</p>
<p>国内高压竞争让前两者过分被强调，其实许多成功的合作往往来自于第三项&mdash;&mdash;甚至有时候你们并没有直接的合作或是竞争关系，只是偶然对同一项热点事物感到好奇，饭桌茶几上两三人随口抛出的一组辩证说不定成为日后指导企业发展的要旨。</p>
<p>&nbsp;</p>
<p><span><span><span><strong><em>地域分化的疼痛不是交通，是沟通</em></strong></span></span></span></p>
<p><span><span><span><span>初创生态圈是中心化还是去中心化？这是一个问题。创新工场给出的答案在 Felisa 听来太简单了，面对面比排排坐好，同层办公比上下楼好， 中关村&ldquo;一锅杂烩&rdquo;比江浙沪&ldquo;遍地开花&rdquo;好，世界是平的比有屋脊和海沟好<span>&hellip;&hellip;问题是，在及时讯息领域如此发达的今天，可以思考为什么沟通障碍的疼痛仍然大于其他所有原因可能带来的高损耗？移动办公还差了些什么？</span></span></span></span></span></p>
<p>&nbsp;</p>]]></description></item><item><title>Linux下DHCP服务器配置</title><link>http://www.cnblogs.com/billowkiller/archive/2013/01/19/2867746.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sat, 19 Jan 2013 08:23:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/01/19/2867746.html</guid><description><![CDATA[<p>环境为Ubuntu 12.10，机器为3网卡，需要再eth2上配置一个dhcp服务。</p>
<p>因为eth2后接一个交换机，交换机上的机器需要自动分配网址，并且对于某一台或多台机器需要固定网址，例如打印机。</p>
<h3>&nbsp;1. &nbsp;&nbsp;安装DHCP服务</h3>
<div class="cnblogs_code">
<pre>sudo apt-get install dhcp3-server</pre>
</div>
<p>但是安装的是 isp-dhcp-server。可能是ubuntu进行的版本替换。但是不影响后面的操作。</p>
<p><span>服务器上用友3块网卡，需要选择哪一块网卡用来监听DHCP服务。</span></p>
<p><span>输入下面命令修改配置文件</span></p>
<div class="cnblogs_code">
<pre>vim /etc/default/isc-dhcp-server</pre>
</div>
<p>在文件的注释部分可以看到dhcpd的配置文件在</p>
<div class="cnblogs_code">
<pre>/etc/dhcp/dhcpd.conf</pre>
</div>
<p>其他注释部分为格外选项，下面要修改INTERFACES</p>
<div class="cnblogs_code">
<pre>INTERFACES=&ldquo;eth2&rdquo;</pre>
</div>
<h3>2. &nbsp;配置DHCP服务</h3>
<p>修改在上一步查到的dhcpd文件</p>
<p>修改的部分如下：</p>
<div class="cnblogs_code">
<pre>default-lease-<span style="color: #0000ff;">time</span> <span style="color: #800080;">600</span><span style="color: #000000;">;
max</span>-lease-<span style="color: #0000ff;">time</span> <span style="color: #800080;">7200</span><span style="color: #000000;">;
option subnet</span>-mask <span style="color: #800080;">255.255</span>.<span style="color: #800080;">255.0</span><span style="color: #000000;">;
option broadcast</span>-address <span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.255</span><span style="color: #000000;">;
option routers </span><span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.254</span><span style="color: #000000;">;
option domain</span>-name-servers <span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.1</span>, <span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.2</span><span style="color: #000000;">;</span><span style="color: #000000;">
subnet </span><span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.0</span> netmask <span style="color: #800080;">255.255</span>.<span style="color: #800080;">255.0</span><span style="color: #000000;"> {
　　range </span><span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.10</span> <span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.200</span><span style="color: #000000;">;
}</span></pre>
</div>
<p><span style="color: #ff0000;">注意</span>：不要忘了每句后面加上分号，当时我就粗心了，花了好久时间查出。</p>
<p>这样修改自动分配的地址范围就在</p>
<pre><span>192.168</span>.<span>1.10 与 </span><span>192.168</span>.<span>1.200<br /></span></pre>
<p>还需要绑定MAC地址与ip地址，在添加代码</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">host printer1 {
　　hardware ethernet </span><span style="color: #800080;">00</span>:0a:<span style="color: #800080;">95</span><span style="color: #000000;">:f5:8f:b3;
　　fixed</span>-address <span style="color: #800080;">192.168</span>.<span style="color: #800080;">1.23</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>重启电脑，就ok了。</p>
<p>需要找到DHCP服务器的IP地址，使用下面的命令</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">sudo</span> dhclient</pre>
</div>
<p>或者</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">tail</span> -n <span style="color: #800080;">15</span> /var/lib/dhcp3/dhclient.*.leases</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>程序员的时间换算表</title><link>http://www.cnblogs.com/billowkiller/archive/2013/01/04/2843955.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 04 Jan 2013 04:34:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/01/04/2843955.html</guid><description><![CDATA[<div class="Section0">
<p class="p0">&nbsp;摘自<a href="http://www.ituring.com.cn/">图灵社区</a></p>
<hr />
<p class="p0" style="text-align: center;">&nbsp;</p>
<table>
<tbody>
<tr style="background-color: #d6e5fe;">
<td valign="center" width="85">
<p class="p17">估算时间</p>
</td>
<td valign="center" width="209">
<p class="p17">程序员所想象的</p>
</td>
<td valign="center" width="269">
<p class="p17">程序员所忘记的</p>
</td>
<td valign="center" width="100">
<p class="p17">实际时间</p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">30<span style="font-family: 'WenQuanYi Zen Hei';">秒</span></p>
</td>
<td valign="center" width="209">
<p class="p16">只需要做一个很小的代码改动。我准确地知道怎么改，在哪里改。花费<span style="font-family: 'Liberation Serif';">30</span><span style="font-family: 'WenQuanYi Zen Hei';">秒敲键盘即可。</span></p>
</td>
<td valign="center" width="269">
<p class="p16">启动计算机，开发环境和获取正确源码的时间。用于构件，测试，检查和文档修复的时间。</p>
</td>
<td valign="center" width="100">
<p class="p16">1<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">5<span style="font-family: 'WenQuanYi Zen Hei';">分钟</span></p>
</td>
<td valign="center" width="209">
<p class="p16">小事一桩，我只要上谷歌查一下语法就可以修复它了。</p>
</td>
<td valign="center" width="269">
<p class="p16">很少有一次就能找到完全正确的信息。即使找到，在它能工作前，也需要做一些调整。外加构件，测试等等时间。</p>
</td>
<td valign="center" width="100">
<p class="p16">2<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">1&nbsp;<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
<td valign="center" width="209">
<p class="p16">我知道怎么做，但是写这些代码需要花费一些时间。</p>
</td>
<td valign="center" width="269">
<p class="p16">面对未来可能发生的问题，<span style="font-family: 'Liberation Serif';">1</span><span style="font-family: 'WenQuanYi Zen Hei';">小时稍纵即逝。有些东西总是会出错。</span></p>
</td>
<td valign="center" width="100">
<p class="p16">2<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">4<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
<td valign="center" width="209">
<p class="p16">需要写一些代码，但是我粗略地知道步骤。我知道标准框架中的<span style="font-family: 'Liberation Serif';">Wizzabanga</span><span style="font-family: 'WenQuanYi Zen Hei';">模块可以做到，不过我得查看文档，了解它的准确地调用方式。</span></p>
</td>
<td valign="center" width="269">
<p class="p16">这个大概是唯一现实的估算。它为意外的错误留下了足够大的余地，而这个任务也小到足以把握。</p>
</td>
<td valign="center" width="100">
<p class="p16">4<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">8&nbsp;<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
<td valign="center" width="209">
<p class="p16">我先要把<span style="font-family: 'Liberation Serif';">Balunga</span><span style="font-family: 'WenQuanYi Zen Hei';">类重构成</span><span style="font-family: 'Liberation Serif';">2</span><span style="font-family: 'WenQuanYi Zen Hei';">个，然后为</span><span style="font-family: 'Liberation Serif';">Wizzabanga</span><span style="font-family: 'WenQuanYi Zen Hei';">模块加一个调用，最后为</span><span style="font-family: 'Liberation Serif';">GUI</span><span style="font-family: 'WenQuanYi Zen Hei';">加一些字段。</span></p>
</td>
<td valign="center" width="269">
<p class="p16">总会有许多系统的不同部分依赖着<span style="font-family: 'Liberation Serif';">Balunga</span><span style="font-family: 'WenQuanYi Zen Hei';">类。大概有</span><span style="font-family: 'Liberation Serif';">40</span><span style="font-family: 'WenQuanYi Zen Hei';">个不同的文件需要修改。为</span><span style="font-family: 'Liberation Serif';">GUI</span><span style="font-family: 'WenQuanYi Zen Hei';">新加的字段，同样也需要加到数据库中。</span><span style="font-family: 'Liberation Serif';">8</span><span style="font-family: 'WenQuanYi Zen Hei';">小时太长，无法完全把握。总会有比程序员估算时更多的步骤出现。</span></p>
</td>
<td valign="center" width="100">
<p class="p16">12-16<span style="font-family: 'WenQuanYi Zen Hei';">小时</span></p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">2&nbsp;<span style="font-family: 'WenQuanYi Zen Hei';">天</span></p>
</td>
<td valign="center" width="209">
<p class="p16">真的有一大堆代码要写。我需要往数据库里加一些新<span style="font-family: 'Liberation Serif';">table</span><span style="font-family: 'WenQuanYi Zen Hei';">，显示</span><span style="font-family: 'Liberation Serif';">table</span><span style="font-family: 'WenQuanYi Zen Hei';">的</span><span style="font-family: 'Liberation Serif';">GUI</span><span style="font-family: 'WenQuanYi Zen Hei';">，还有读写</span><span style="font-family: 'Liberation Serif';">table</span><span style="font-family: 'WenQuanYi Zen Hei';">的代码逻辑。</span></p>
</td>
<td valign="center" width="269">
<p class="p16">对于大多数开发者来说，两天的工作量已经大到难以估算了。肯定会有什么东西被遗漏掉。不仅仅是一些小事情，而是整个一大块主要功能会被遗忘在估算中。</p>
</td>
<td valign="center" width="100">
<p class="p16">5&nbsp;<span style="font-family: 'WenQuanYi Zen Hei';">天</span></p>
</td>
</tr>
<tr>
<td valign="center" width="85">
<p class="p16">1&nbsp;<span style="font-family: 'WenQuanYi Zen Hei';">周</span></p>
</td>
<td valign="center" width="209">
<p class="p16">哎哟，这真是一项艰巨的任务。虽然我还没有思路，但我不能说我不知道。一周应该够了，我希望，我真心希望，但是我不能要求更多了，否则他们会认为我不够称职。</p>
</td>
<td valign="center" width="269">
<p class="p16">这个任务已经大到超过大多数程序员的理解了。它应该被发回给架构师，帮忙将它划分成更小的部分，然后提供一些解决问题的方向。架构师可能会发现一种更简单的方法来完成它，或者发现其实有更多超乎想象的工作。。。</p>
</td>
<td valign="center" width="100">
<p class="p16">2-20&nbsp;<span style="font-family: 'WenQuanYi Zen Hei';">天</span></p>
</td>
</tr>
</tbody>
</table>
<p class="p15">&nbsp;</p>
</div>]]></description></item><item><title>P2P流媒体视频点播系统的个人技术报告</title><link>http://www.cnblogs.com/billowkiller/archive/2013/01/02/2842261.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 02 Jan 2013 09:24:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2013/01/02/2842261.html</guid><description><![CDATA[<h3>项目说明</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;来源为高等计算机网络的大作业设计。我们组选择的是p2p的流媒体视频点播系统。核心内容的是chord算法。</p>
<h3>系统分析</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;局域网内的任何结点既可以发送媒体压缩信息给其他结点，也可以从其他结点接收视频信息。此外流媒体信息是在网内从多源结点获取，而非单源模式。改变传统的需要中央服务器的查询支持，虽然本系统也需要一个中央服务器进行存储数据源以及节点加入的初始化，但是一旦节点加入了p2p网络，那么中央服务器的功能便会弱化很多，客户端peer可以利用其他peer节点已有的信息进行资源查询，而不用经过中央服务器。 在理论上，chord是一个纯p2p算法，但是在试验中我们发现，在广域网中实现一个完全对等的p2p网络是不大现实的一件事情，因为根据chord算法，节点的加入需要知道一个已知的节点信息，而这个节点信息无法像在局域网中可以通过广播的方式进行查询，也就是说这个已知的节点就是存在的中央服务器，所有的节点加入都需要知道中央服务器在网络中的位置，通过中央服务器加入到chord网络中。而在局域网中，必存在一个初始信息源，对于一个如上所描述的系统来说，这个初始信息源可以当成一个中央服务器，当然这个中央服务器的功能也被弱化很多。</p>
<h4>项目设计与管理</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;采用JAVA语言作为实现工具，并利用其UDT传输包实现数据传输、JMF视频播放工具包和openchord开源工具包，在局域网内实现基于P2P的流媒体视频点播系统。系统设计主要涉及的工作量包括：服务器端资源管理、P2P资源查询传输机制、客户端缓冲区管理和视频播放软件。预计的工作时间为1个月，总工作量为4人月。开发采用敏捷开发模型，进行迭代式开发，开发讨论为3天一次的站立会议，有效保障小组成员的信息一致性。会议中根据迭代需求列出一周或者近期的任务，小组成员互相监督管理，提高效率。能够有效的保障在规定的时间内完成项目。</p>
<h3>功能需求</h3>
<ul>
<li>
<p>客户端软件：运行客户端软件即获取所有频道列表信息，获取需要播放的文件信息，查询本地缓冲区，若已在本地有播放过，则直接进行本地播放；没有缓存的文件则将从可用的对等节点获取。</p>
</li>
<li>
<p>缓冲区管理：P2P资源查询和分发资源服务器管理资源，使用chord协议获取得到资源存储节点，选择资源存储节点，使用多线程调度下载，提供分片信息给客户端软件。将视频分片组成队列，记录分片大小，若总的缓冲区大于500MB则根据队列顺序删除先到的分片。 服务器端：初始化资源，构建chord网络。其他peer节点加入服务器端的chord网络。</p>
</li>
</ul>
<h3>实现效率</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;提高效率的方法包括：</p>
<ol>
<li>使用多线程进行下载分片资源；</li>
<li>缓冲区大小管理，避免下载重复资源；</li>
<li>使用UDT传输，加快传输效率，简化系统复杂度。</li>
<li>同一资源节点的选择算法</li>
</ol>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="类图" src="http://images.cnitblog.com/blog/434023/201301/02172642-90a8182460f045fdb3c3b44f0f9e408b.png" alt="类图" width="748" height="516" /></p>
<h3>个人工作总结</h3>
<h4>项目管理</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我并不是第一次在项目中担任组长，但是这次的项目开发与以往有很大的不同。</p>
<ol>
<li>组员之间互相都不熟悉，对对方了解什么技术，善于哪一个模块的开发都不了解。</li>
<li>工作时间不固定，而且特别的缺少，每个组员都有老师分配的任务和其他的课堂作业。</li>
<li>工作环境不理想，组员的实验室之间相隔较远，沟通不够方便</li>
<li>组员普遍对新技术不太了解，只是掌握基础知识，开发上存在困难。</li>
<li>没有明确的需求和系统边界。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;以上种种的一切都给开发造成困难，特别是第一条。因为对大家的开发水平和偏好都不了解，所以在分配任务的时候就相当与黑盒测试一般。 无法根据已知的情况安排任务。其他方面也给相互之间的沟通制造了困难。而沟通对于团队来说，我认为是比其他方面更加重要的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;争对上述几条我对项目进行如下管理：</p>
<ol>
<li>项目整体上为迭代开发，采用增量模型</li>
<li>建立qq群及时共享消息和资源</li>
<li>每周一次的例会，后来因为项目进展缓慢，改为3天一次</li>
<li>开会的时候借鉴敏捷站立会议的要点，给出任务需求，让组员选择</li>
<li>开发采用模块化的方法，预留API接口给使用者，明确代码责任制</li>
<li>采用git作为版本控制，所有代码再github上托管，组员可以pull和push最新更新</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但项目管理过程中还是有很多方面没有考虑到：</p>
<ul>
<li>发现开会的时候气氛不够浓烈，组员大多数时候没有提前做一些准备，导致开会时间过长</li>
<li>自己的思想表达不够清楚，没有确定组员明白自己的想法</li>
<li>在做架构的时候，没有做好调研工作，所选的方法并不一定时最佳的</li>
<li>组员能力不了解的情况下，将组员能力的底线设置较高</li>
<li>重点功能和说明没有采用图片或者文件保留</li>
<li>开发过程中，没有很好的进行时间估计，导致很多应有的需求未能实现</li>
</ul>
<h4>开发总结</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我所负责的内容是缓冲区管理和系统架构的设计。开发过程中遇到的问题如下：</p>
<ol>
<li>开发过于仓促，代码比较粗糙</li>
<li>在服务器端实现多个客户端接入进行多线程udp传输文件的时候遇到困难，未能很好的实现多线程</li>
<li>在带宽检测的那一块没有实现，还是因为没有合理规划时间，导致后期工作量大。</li>
<li>开发的时候没有进行很好的时间估计</li>
</ol>
<p>收获还是有一些的：</p>
<ol>
<li>对DHT的chord lookup sevice进一步了解</li>
<li>实现p2p流媒体的功能，了解其中的机制</li>
<li>巩固和复习了Java的语法和用法，较多的使用线程，提高效率</li>
<li>总体设计和分析上有了进一步的提高</li>
</ol>
<h3>参考文献</h3>
<p>[1] P2P流媒体系统节点管理与数据分发机制. 王延伟. 山东大学硕士学位论文. 2010.<br />
[2] Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications. Ion Stoica. etc. MIT Laboratory for Computer Science. 2001.<br />
[3] Reducing Maintenance Overhead in Chord via Heterogeneity. Yuh-Jzer Joung. Jiaw-Chang Wang. Taipei. 2005</p>]]></description></item><item><title>pondoc example</title><link>http://www.cnblogs.com/billowkiller/archive/2012/12/29/2838713.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sat, 29 Dec 2012 06:13:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/12/29/2838713.html</guid><description><![CDATA[<p>from <a href="http://johnmacfarlane.net/pandoc/demos.html">pondoc&nbsp;</a></p>
<hr />
<p>&nbsp;</p>
<p id="examples">To see the output created by each of the commands below, click on the name of the output file:</p>
<ol>
<li>
<p>HTML fragment:</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example1.html">example1.html</a></code></pre>
</li>
<li>
<p>Standalone HTML file:</p>
<pre><code>pandoc -s <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example2.html">example2.html</a></code></pre>
</li>
<li>
<p>HTML with smart quotes, table of contents, CSS, and custom footer:</p>
<pre><code>pandoc -s -S --toc -c <a href="http://johnmacfarlane.net/pandoc/demo/pandoc.css">pandoc.css</a> -A <a href="http://johnmacfarlane.net/pandoc/demo/footer.html">footer.html</a> <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example3.html">example3.html</a></code></pre>
</li>
<li>
<p>LaTeX:</p>
<pre><code>pandoc -s <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example4.tex">example4.tex</a></code></pre>
</li>
<li>
<p>From LaTeX to markdown:</p>
<pre><code>pandoc -s <a href="http://johnmacfarlane.net/pandoc/demo/example4.tex">example4.tex</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example5.text">example5.text</a></code></pre>
</li>
<li>
<p>reStructuredText:</p>
<pre><code>pandoc -s -w rst --toc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example6.text">example6.text</a></code></pre>
</li>
<li>
<p>Rich text format (RTF):</p>
<pre><code>pandoc -s <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example7.rtf">example7.rtf</a></code></pre>
</li>
<li>
<p>Beamer slide show:</p>
<pre><code>pandoc -t beamer <a href="http://johnmacfarlane.net/pandoc/demo/SLIDES">SLIDES</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example8.pdf">example8.pdf</a></code></pre>
</li>
<li>
<p>DocBook XML:</p>
<pre><code>pandoc -s -S -w docbook <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example9.db">example9.db</a></code></pre>
<p>Chunked XHTML via DocBook and&nbsp;<a href="http://cyberelk.net/tim/xmlto/">xmlto</a>:</p>
<pre><code>xmlto xhtml -m <a href="http://johnmacfarlane.net/pandoc/demo/config.xsl">config.xsl</a> <a href="http://johnmacfarlane.net/pandoc/demo/example9.db">example9.db</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example9/">example9/</a></code></pre>
</li>
<li>
<p>Man page:</p>
<pre><code>pandoc -s -w man <a href="http://johnmacfarlane.net/pandoc/demo/pandoc.1.md">pandoc.1.md</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example10.1">example10.1</a></code></pre>
</li>
<li>
<p>ConTeXt:</p>
<pre><code>pandoc -s -w context <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example11.tex">example11.tex</a></code></pre>
<p>PDF via pandoc and ConTeXt&rsquo;s&nbsp;<code>texexec</code>:</p>
<pre><code>texexec --pdf <a href="http://johnmacfarlane.net/pandoc/demo/example11.tex">example11.tex</a>   # produces <a href="http://johnmacfarlane.net/pandoc/demo/example11.pdf">example11.pdf</a></code></pre>
</li>
<li>
<p>Converting a web page to markdown:</p>
<pre><code>pandoc -s -r html <a href="http://johnmacfarlane.net/pandoc/demo/http://www.gnu.org/software/make/">http://www.gnu.org/software/make/</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example12.text">example12.text</a></code></pre>
</li>
<li>
<p>From markdown to PDF:</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example13.pdf">example13.pdf</a></code></pre>
</li>
<li>
<p>PDF with numbered sections and a custom LaTeX header:</p>
<pre><code>pandoc -N --template=<a href="http://johnmacfarlane.net/pandoc/demo/mytemplate.tex">mytemplate.tex</a> --variable mainfont=Georgia --variable sansfont=Arial --variable monofont="Bitstream Vera Sans Mono" --variable fontsize=12pt --variable version=1.9 <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> --latex-engine=xelatex --toc -o <a href="http://johnmacfarlane.net/pandoc/demo/example14.pdf">example14.pdf</a></code></pre>
</li>
<li>
<p>A wiki program using&nbsp;<a href="http://happstack.com/">Happstack</a>&nbsp;and pandoc:&nbsp;<a href="http://gitit.net/">gitit</a></p>
</li>
<li>
<p>HTML slide shows:</p>
<pre><code>pandoc -s --mathml -i -t dzslides <a href="http://johnmacfarlane.net/pandoc/demo/SLIDES">SLIDES</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example16a.html">example16a.html</a></code></pre>
<pre><code>pandoc -s --webtex -i -t slidy <a href="http://johnmacfarlane.net/pandoc/demo/SLIDES">SLIDES</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example16b.html">example16b.html</a></code></pre>
<pre><code>pandoc -s --self-contained --webtex -i -t s5 <a href="http://johnmacfarlane.net/pandoc/demo/SLIDES">SLIDES</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example16c.html">example16c.html</a></code></pre>
<pre><code>pandoc -s --mathjax -i -t slideous <a href="http://johnmacfarlane.net/pandoc/demo/SLIDES">SLIDES</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example16d.html">example16d.html</a></code></pre>
</li>
<li>
<p>TeX math in HTML:</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/math.text">math.text</a> -s -o <a href="http://johnmacfarlane.net/pandoc/demo/mathDefault.html">mathDefault.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/math.text">math.text</a> -s --mathml -o <a href="http://johnmacfarlane.net/pandoc/demo/mathMathML.html">mathMathML.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/math.text">math.text</a> -s --webtex -o <a href="http://johnmacfarlane.net/pandoc/demo/mathWebTeX.html">mathWebTeX.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/math.text">math.text</a> -s --mathjax -o <a href="http://johnmacfarlane.net/pandoc/demo/mathMathJax.html">mathMathJax.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/math.text">math.text</a> -s --latexmathml -o <a href="http://johnmacfarlane.net/pandoc/demo/mathLaTeXMathML.html">mathLaTeXMathML.html</a></code></pre>
</li>
<li>
<p>Syntax highlighting of delimited code blocks:</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style pygments -o <a href="http://johnmacfarlane.net/pandoc/demo/example18a.html">example18a.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style kate -o <a href="http://johnmacfarlane.net/pandoc/demo/example18b.html">example18b.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style monochrome -o <a href="http://johnmacfarlane.net/pandoc/demo/example18c.html">example18c.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style espresso -o <a href="http://johnmacfarlane.net/pandoc/demo/example18d.html">example18d.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style haddock -o <a href="http://johnmacfarlane.net/pandoc/demo/example18e.html">example18e.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style tango -o <a href="http://johnmacfarlane.net/pandoc/demo/example18f.html">example18f.html</a></code></pre>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/code.text">code.text</a> -s --highlight-style zenburn -o <a href="http://johnmacfarlane.net/pandoc/demo/example18g.html">example18g.html</a></code></pre>
</li>
<li>
<p>GNU Texinfo, converted to info, HTML, and PDF formats:</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -s -o <a href="http://johnmacfarlane.net/pandoc/demo/example19.texi">example19.texi</a></code></pre>
<pre><code>makeinfo <a href="http://johnmacfarlane.net/pandoc/demo/example19.texi">example19.texi</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example19.info">example19.info</a></code></pre>
<pre><code>makeinfo <a href="http://johnmacfarlane.net/pandoc/demo/example19.texi">example19.texi</a> --html -o <a href="http://johnmacfarlane.net/pandoc/demo/example19">example19</a></code></pre>
<pre><code>texi2pdf <a href="http://johnmacfarlane.net/pandoc/demo/example19.texi">example19.texi</a>  # produces <a href="http://johnmacfarlane.net/pandoc/demo/example19.pdf">example19.pdf</a></code></pre>
</li>
<li>
<p>OpenDocument XML:</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -s -w opendocument -o <a href="http://johnmacfarlane.net/pandoc/demo/example20.xml">example20.xml</a></code></pre>
</li>
<li>
<p>ODT (OpenDocument Text, readable by OpenOffice):</p>
<pre><code>pandoc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example21.odt">example21.odt</a></code></pre>
</li>
<li>
<p>MediaWiki markup:</p>
<pre><code>pandoc -s -S -w mediawiki --toc <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example22.wiki">example22.wiki</a></code></pre>
</li>
<li>
<p>EPUB ebook:</p>
<pre><code>pandoc -S <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/README.epub">README.epub</a></code></pre>
</li>
<li>
<p>Markdown citations:</p>
<pre><code>pandoc -s -S --biblio <a href="http://johnmacfarlane.net/pandoc/demo/biblio.bib">biblio.bib</a> --csl <a href="http://johnmacfarlane.net/pandoc/demo/chicago-author-date.csl">chicago-author-date.csl</a> <a href="http://johnmacfarlane.net/pandoc/demo/CITATIONS">CITATIONS</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example24a.html">example24a.html</a></code></pre>
<pre><code>pandoc -s -S --biblio <a href="http://johnmacfarlane.net/pandoc/demo/biblio.bib">biblio.bib</a> --csl <a href="http://johnmacfarlane.net/pandoc/demo/mhra.csl">mhra.csl</a> <a href="http://johnmacfarlane.net/pandoc/demo/CITATIONS">CITATIONS</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example24b.html">example24b.html</a></code></pre>
<pre><code>pandoc -s -S --biblio <a href="http://johnmacfarlane.net/pandoc/demo/biblio.bib">biblio.bib</a> --csl <a href="http://johnmacfarlane.net/pandoc/demo/ieee.csl">ieee.csl</a> <a href="http://johnmacfarlane.net/pandoc/demo/CITATIONS">CITATIONS</a> -t man -o <a href="http://johnmacfarlane.net/pandoc/demo/example24c.1">example24c.1</a></code></pre>
</li>
<li>
<p>Textile writer:</p>
<pre><code>pandoc -s -S <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -t textile -o <a href="http://johnmacfarlane.net/pandoc/demo/example25.textile">example25.textile</a></code></pre>
</li>
<li>
<p>Textile reader:</p>
<pre><code>pandoc -s -S <a href="http://johnmacfarlane.net/pandoc/demo/example25.textile">example25.textile</a> -f textile -t html -o <a href="http://johnmacfarlane.net/pandoc/demo/example26.html">example26.html</a></code></pre>
</li>
<li>
<p>Org-mode:</p>
<pre><code>pandoc -s -S <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example27.org">example27.org</a></code></pre>
</li>
<li>
<p>AsciiDoc:</p>
<pre><code>pandoc -s -S <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -t asciidoc -o <a href="http://johnmacfarlane.net/pandoc/demo/example28.txt">example28.txt</a></code></pre>
</li>
<li>
<p>Word docx:</p>
<pre><code>pandoc -s -S <a href="http://johnmacfarlane.net/pandoc/demo/README">README</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example29.docx">example29.docx</a></code></pre>
</li>
<li>
<p>LaTeX math to docx:</p>
<pre><code>pandoc -s <a href="http://johnmacfarlane.net/pandoc/demo/math.tex">math.tex</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example30.docx">example30.docx</a></code></pre>
</li>
<li>
<p>DocBook to markdown:</p>
<pre><code>pandoc -f docbook -t markdown -s <a href="http://johnmacfarlane.net/pandoc/demo/howto.xml">howto.xml</a> -o <a href="http://johnmacfarlane.net/pandoc/demo/example31.text">example31.text</a></code></pre>
</li>
</ol>]]></description></item><item><title>少年派</title><link>http://www.cnblogs.com/billowkiller/archive/2012/12/25/2832242.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Tue, 25 Dec 2012 05:35:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/12/25/2832242.html</guid><description><![CDATA[<h3>徐子东：他人就是老虎</h3>
<p>老虎三个阶段：</p>
<ol>
<li>力量比你大，你得自卫;反过来，你的力量比较强大，你就是老虎</li>
<li>自卫后，利用特别的情况，给他好处，给他恩惠，指挥他，利用它</li>
<li>产生幻觉，你们是同舟共济，共同面对困难</li>
</ol>
<p>点睛：</p>
<ul>
<li>瘦骨凛丁的老虎头也不回的进入森林</li>
<li>pi父亲一开始所说的：你在动物眼里看到的所有的同情，友爱，善良都是你的倒影</li>
</ul>
<p>&nbsp;</p>
<h3>梁文道：神，人，动物三角平衡</h3>
<p>人与动物在船上相处，是两点，无法达到平衡状态，所以需要寻找第三点，超自然的第三点&mdash;&mdash;上帝。 但是那个状态不是每个人都能感觉的到，追求的到，所以透过人和动物的相处，我们去求那未知第三点。</p>
<p>对于某种精神倾向的探讨。</p>]]></description></item><item><title>8 Linux TR Command Examples</title><link>http://www.cnblogs.com/billowkiller/archive/2012/12/20/2825984.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Thu, 20 Dec 2012 02:28:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/12/20/2825984.html</guid><description><![CDATA[<p><strong><em>from <a href="http://www.thegeekstuff.com/2012/12/linux-tr-command/?utm_source=feedburner&amp;utm_medium=email&amp;utm_campaign=Feed%3A+TheGeekStuff+%28The+Geek+Stuff%29">TheGeekStuff</a></em></strong></p>
<hr />
<p>&nbsp;</p>
<p>tr is an UNIX utility for <span style="color: #0000ff;">translating</span>, or <span style="color: #0000ff;">deleting</span>, or <span style="color: #0000ff;">squeezing</span> repeated characters. It will read from STDIN and write to STDOUT.</p>
<p>tr stands for translate.</p>
<h3>Syntax</h3>
<p>The syntax of tr command is:</p>
<div class="cnblogs_code">
<pre>$ tr [OPTION] SET1 [SET2]</pre>
</div>
<h3>Translation</h3>
<p>If both the SET1 and SET2 are specified and &lsquo;-d&rsquo; OPTION is not specified, then tr command will replace each characters in SET1 with each character in same position in SET2.</p>
<h3>1. Convert lower case to upper case</h3>
<p>The following tr command is used to convert the lower case to upper case</p>
<div class="cnblogs_code">
<pre>$ tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
thegeekstuff
THEGEEKSTUFF
</pre>
</div>
<p>The following command will also convert lower case to upper case</p>
<div class="cnblogs_code">
<pre>$ tr [:lower:] [:upper:]
thegeekstuff
THEGEEKSTUFF
</pre>
</div>
<p>You can also use ranges in tr. The following command uses ranges to convert lower to upper case.</p>
<div class="cnblogs_code">
<pre>$ tr a-z A-Z
thegeekstuff
THEGEEKSTUFF
</pre>
</div>
<h3>2. Translate braces into parenthesis</h3>
<p>You can also translate from and to a file. In this example we will translate braces in a file with parenthesis.</p>
<div class="cnblogs_code">
<pre>$ tr '{}' '()' &lt; inputfile &gt; outputfile
</pre>
</div>
<p>The above command will read each character from &ldquo;inputfile&rdquo;, translate if it is a brace, and write the output in &ldquo;outputfile&rdquo;.</p>
<h3>3. Translate white-space to tabs</h3>
<p>The following command will translate all the white-space to tabs</p>
<div class="cnblogs_code">
<pre>$ echo "This is for testing" | tr [:space:] '\t'
This	is	for	testing
</pre>
</div>
<h3>4. Squeeze repetition of characters using -s</h3>
<p>In Example 3, we see how to translate space with tabs. But if there are two are more spaces present continuously, then the previous command will translate each spaces to a tab as follows.</p>
<div class="cnblogs_code">
<pre>$ echo "This   is   for testing" | tr [:space:] '\t'
This			is			for	testing
</pre>
</div>
<p>We can use -s option to squeeze the repetition of characters.</p>
<div class="cnblogs_code">
<pre>$ echo "This   is   for testing" | tr -s [:space:] '\t'
This	is	for	testing
</pre>
</div>
<p>Similarly you can convert multiple continuous spaces with a single space</p>
<div class="cnblogs_code">
<pre>$ echo "This  is  for testing" | tr -s [:space:] ' '
This is for testing
</pre>
</div>
<h3>5. Delete specified characters using -d option</h3>
<p>tr can also be used to remove particular characters using -d option.</p>
<div class="cnblogs_code">
<pre>$ echo "the geek stuff" | tr -d 't'
he geek suff
</pre>
</div>
<p>To remove all the digits from the string, use</p>
<div class="cnblogs_code">
<pre>$ echo "my username is 432234" | tr -d [:digit:]
my username is
</pre>
</div>
<p>Also, if you like to delete lines from file, you can use&nbsp;<a href="http://www.thegeekstuff.com/2009/09/unix-sed-tutorial-delete-file-lines-using-address-and-patterns/">sed d command</a>.</p>
<h3>6. Complement the sets using -c option</h3>
<p>You can complement the SET1 using -c option. For example, to remove all characters except digits, you can use the following.</p>
<div class="cnblogs_code">
<pre>$ echo "my username is 432234" | tr -cd [:digit:]
432234
</pre>
</div>
<h3>7. Remove all non-printable character from a file</h3>
<p>The following command can be used to remove all non-printable characters from a file.</p>
<div class="cnblogs_code">
<pre>$ tr -cd [:print:] &lt; file.txt
</pre>
</div>
<h3>8. Join all the lines in a file into a single line</h3>
<p>The below command will translate all newlines into spaces and make the result as a single line.</p>
<div class="cnblogs_code">
<pre>$ tr -s '\n' ' ' &lt; file.txt</pre>
</div>
<hr />
<p>&nbsp;</p>]]></description></item><item><title>linux下双网卡配置</title><link>http://www.cnblogs.com/billowkiller/archive/2012/12/12/2815351.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 12 Dec 2012 13:23:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/12/12/2815351.html</guid><description><![CDATA[<p><strong>需求</strong>： 一台PC1拥有双网卡，另外一台PC2需要通过这台pc上网。</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/billowkiller/447098/r_ac345982b2b7d0a207325429cbef76094a369a8e.jpg" alt="" /></p>
<p><strong>配置过程</strong>：</p>
<p>首先需要配置pc1的两个网卡信息以及pc2的网卡信息。这个比较简单，接下里需要配置pc1中的静态路由。</p>
<p>文件ipt.save表示静态路由表的修改文件。</p>
<div class="cnblogs_code">
<pre># Generated by iptables-save v1.4.2 on Wed Nov 16 15:04:23 2011
*filter
:INPUT ACCEPT [203:29797]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [83:10885]
COMMIT
# Completed on Wed Nov 16 15:04:23 2011
# Generated by iptables-save v1.4.2 on Wed Nov 16 15:04:23 2011
*nat
:PREROUTING ACCEPT [82:12935]
:POSTROUTING ACCEPT [25:1724]
:OUTPUT ACCEPT [25:1724]
-A POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -j MASQUERADE  
COMMIT
# s-&gt;source !d-&gt;not distination-&gt;not in the same subset
# Completed on Wed Nov 16 15:04:23 2011</pre>
</div>
<p>进入root权限后，执行命令</p>
<div class="cnblogs_code">
<pre>iptables-restore /home/angel/net_scripts/ipt.save</pre>
</div>
<p>这样就是修改了静态路由表，但还需要将转发开关打开，需要命令如下</p>
<div class="cnblogs_code">
<pre>echo '1' &gt; /proc/sys/net/ipv4/ip_forward</pre>
</div>
<p>这样修改之后pc2就可以通过pc1上网了。</p>
<p>但是重启后发现<strong>两个问题</strong>：</p>
<ul>
<li>linux下如果有两个网卡eth0和eth1，系统启动时候会先启动eth0，后启动eth1，这样造成eth0的信息被eth1覆盖。</li>
<li>以上的两个命令并不是永久的，重启后失效。</li>
</ul>
<p>第一个问题的解决方案是修改/etc/network/interfaces 文件，修改网卡接口的信息，修改后的文件如下：</p>
<div class="cnblogs_code">
<pre># interfaces(5) file used by ifup(8) and ifdown(8)
auto lo
iface lo inet loopback

auto eth1
iface eth1 inet dhcp

auto eth0
iface eth0 inet static
    address 10.0.0.1
    netmask 255.0.0.0
    broadcast 10.255.255.255</pre>
</div>
<p>需要重启生效，也可以使用命令</p>
<div class="cnblogs_code">
<pre>sudo /etc/init.d/networking restart</pre>
</div>
<p>第二个问题可以写一个简单的脚本iptable.sh来实现，每次开机启动自动执行脚本：</p>
<div class="cnblogs_code">
<pre>iptables-restore /home/angel/net_scripts/ipt.save
echo '1' &gt; /proc/sys/net/ipv4/ip_forward</pre>
</div>
<p>将脚本放在任意的位置，如下放入home文件夹下，修改/etc/rc.local文件：</p>
<div class="cnblogs_code">
<pre>#!/bin/sh -e
#
# rc.local
#
# This script is executed at the end of each multiuser runlevel.
# Make sure that the script will "exit 0" on success or any other
# value on error.
#
# In order to enable or disable this script just change the execution
# bits.
#
# By default this script does nothing.
sh /home/bk/iptable.sh
exit 0</pre>
</div>
<p>这样每次启动都会调用脚本，并且使用root权限。</p>]]></description></item><item><title>Linux/Unix下grep命令使用的几个例子[grep Examples]</title><link>http://www.cnblogs.com/billowkiller/archive/2012/11/22/2782773.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Thu, 22 Nov 2012 07:48:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/11/22/2782773.html</guid><description><![CDATA[<p><a href="http://blog.csdn.net/pan_tian/article/details/7685815">http://blog.csdn.net/pan_tian/article/details/7685815</a></p>
<hr />
<h2><a href="http://www.linuxso.com/command/grep.html" target="_blank"><span style="text-decoration: underline;">grep</span></a>&nbsp;语法</h2>
<pre class="bash"><span>grep</span> <span>'word'</span> <a href="http://www.linuxso.com/command/file.html" target="_blank"><span style="text-decoration: underline;">file</span></a>name
<span>grep</span> <span>'s<a href="http://www.linuxso.com/command/tr.html" target="_blank"><span style="text-decoration: underline;">tr</span></a>ing1 string2'</span>  filename
<span><a href="http://www.linuxso.com/command/cat.html" target="_blank"><span style="text-decoration: underline;">cat</span></a></span> otherfile | <span>grep</span> <span>'something'</span>
<span>command</span> | <span>grep</span> <span>'something'</span>
<span>command</span> option1 | <span>grep</span> <span>'data'</span>
<span>grep</span> --<a href="http://www.linuxso.com/command/col.html" target="_blank"><span style="text-decoration: underline;">col</span></a>or <span>'data'</span> fileName</pre>
<h2>&nbsp;</h2>
<h2>基本的用法</h2>
<p>在某个文件里搜索error字符串<br /><code>$ grep "error" log.txt</code></p>
<h2>忽略大小写搜索(-i)</h2>
<p><code>$ grep -i "ErroR" log.txt</code></p>
<h2>所有子目录下的搜索(-r)</h2>
<p><code>$ grep -r "<a href="http://www.linuxso.com/command/ex.html" target="_blank"><span style="text-decoration: underline;">ex</span></a>ception" log.txt</code></p>
<h2>全字匹配搜索(-w)</h2>
<p>如果你搜索boo，查询结果可能包含fooboo，boo123, booooom,等等，可以使用-w来限定全字匹配<br /><code>$ grep -w "boo" /path/to/file</code></p>
<h2>全字匹配搜索两个不同单词</h2>
<p><code>$ grep -w 'word1|word2' /path/to/file</code>&nbsp;</p>
<h2>统计字符串出现的次数(-c)</h2>
<p><code>$ grep -c 'word' /path/to/file</code></p>
<p>另外加-n的话， 会在结果中，列出匹配字符串的序列号，并且会列出内容<br /><code>$ grep -n 'word' /path/to/file</code>&nbsp;</p>
<h2>列出&ldquo;不&rdquo;包含字符串的行(-v)</h2>
<p><code>$ grep -v bar /path/to/file</code></p>
<h2>只列出文件名(-l)</h2>
<p><code>$ grep -l 'main' *.p<span style="text-decoration: underline;"><a href="http://www.linuxso.com/command/ls.html" target="_blank">ls</a></span></code></p>
<h2>高亮显示(--color)</h2>
<p><code>$&nbsp;</code>grep --color oracle /etc/<a href="http://www.linuxso.com/command/passwd.html" target="_blank"><span style="text-decoration: underline;">passwd</span></a></p>
<p><img src="http://www.linuxso.com/uploads/allimg/120628/0043022131-1.jpg" alt="" /></p>
<h2>UNIX / Linux pipes + grep&nbsp;</h2>
<p><code>ls -l | grep -i xyz</code></p>
<p><code><strong>ls</strong>&nbsp;列出当前目录下的文件和文件夹,<strong>|</strong>&nbsp;是管道传递给后面的一个程序,grep再是进行模式匹配</code></p>
<p><code>例如：ls *.pls | grep -i --color "MM"</code></p>
<p><code><img src="http://www.linuxso.com/uploads/allimg/120628/0043026022-2.jpg" alt="" /></code></p>
<p><code>========EOF=========</code></p>]]></description></item><item><title>Wireshark设置interface 时提示“There are no interfaces on which a capture can be done ”</title><link>http://www.cnblogs.com/billowkiller/archive/2012/11/12/2767163.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Mon, 12 Nov 2012 14:40:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/11/12/2767163.html</guid><description><![CDATA[<p><span>edited from&nbsp;<a href="http://blog.163.com/likaifeng@126/blog/static/32097310201271451655190/">likaifeng</a></span></p>
<hr />
<p>&nbsp;</p>
<p><span>今天在电脑上安装了WIRESHARK软件，在设置interface 时提示"There are no interfaces on which a capture can be done" &nbsp;提示没有任何一个网络接口准备好。此提示明显是不对的， 我的网卡明明可以正常上网，网络接口怎么会没有准备好呢？ &nbsp;想着应该是和linux下的普通用户权限有关系。上网google了一下，找到了解决问题的方法， 现在整理下来， 以备后用。</span></p>
<div>&nbsp;</div>
<div>&nbsp; 思路；即然问题与权限有关系 ， 那么解决方法无法有两点， 一个就是直接使用root登陆，这样就可以有足够的权限运行任意程序了， 但显然是不安全的，另外一种方法是通过suid guid等办法给予普通用户执行wireshark的权限。这样相对来说比安全。</div>
<div>&nbsp;</div>
<div>&nbsp; 第一种方法:使用root用户登陆</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;xiaoshancun@xiaoshancun-VM500:~$ sudo wireshark&nbsp;</div>
<div>&nbsp; 第二种方法： 通过guid形式使当前普通用户可以运行此程序。</div>
<p><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp; &nbsp;root@xiaoshancun-VM500:~# groupadd &nbsp;-g 130 &nbsp;wireshark</span></p>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;新建一个名为wireshark的用户组， 130 是GID，此数字不是固定不变的， 请先查看/etc/group 文件查看最大的GID是多少，然后加1即可。</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;&nbsp;root@xiaoshancun-VM500:~# usermod &nbsp;-a -G wireshark &nbsp;xiaoshancun &nbsp;</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp; # &nbsp;将当前用户 xiaoshancun 添加到wireshark组中。 使之成为新的组员。</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;root@xiaoshancun-VM500:~# chgrp &nbsp;wireshark &nbsp; /usr/bin/dumpcap</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;# &nbsp;将/usr/bin/dumpcap &nbsp;程序的属组更改为wireshark &nbsp;。</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;&nbsp;root@xiaoshancun-VM500:~# chmod &nbsp;4750 /usr/bin/dumpcap</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;修改 /usr/bin/dumpcap &nbsp;的权限 更改为 &nbsp;4750 &nbsp;添加suid 权限 。&nbsp;</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;&nbsp;</span>root@xiaoshancun-VM500:~# setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;&nbsp;</div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp; &nbsp;修改完成还不能直接使用，需要重新登陆一下才可以。需你不想重新登陆可以使用如下命令。</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp;&nbsp;</span>&nbsp;root@xiaoshancun-VM500:~#&nbsp;<span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp;</span>newgrp wireshark</div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp;完屔后就可以使用普通用户执行wireshark 程序了。&nbsp;</span></div>
<div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53;">&nbsp; &nbsp;<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/65E068079898_zpsc450e70d.png" alt="" /></span></div>]]></description></item><item><title>十个你可能没用过的Linux命令</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/28/2743960.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sun, 28 Oct 2012 13:15:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/28/2743960.html</guid><description><![CDATA[<div class="post-text">
<p><em><strong>excerpted</strong>&nbsp;from <a href="http://www.ituring.com.cn/article/1782" target="_blank">图灵社区</a></em></p>
<hr />
<p>&nbsp;</p>
<p>如果你是一个硬件系统管理员或者Linux工程师，你可能会记得大多数Linux命令行技巧。下面的这些Linux命令行技巧通常不被Linux用户所使用。</p>
<p><strong>1.使用<em>pgrep</em>快速查找一个PID</strong></p>
<p><strong><em>pgrep</em></strong>遍历目前正在运行的进程然后列出符合查找规则的进程ID（PID）。</p>
<pre class="prettyprint"><code><span class="pln">pgrep ssh</span></code></pre>
<p>这条命令会列出所有与ssh有关的进程。</p>
<p><strong>2.执行上次执行过的命令</strong></p>
<p>这个标题有些绕口，但是它是名副其实的。</p>
<pre class="prettyprint"><code><span class="pun">!!</span></code></pre>
<p>这会执行你上一次在命令行中执行过的命令。</p>
<p><strong>3.执行最近一次以XX开头的命令</strong></p>
<p>如果你想要从命令行历史中执行一个s开头的命令时，你可以使用如下命令：</p>
<pre class="prettyprint"><code><span class="pun">!</span><span class="pln">s</span></code></pre>
<p>它会执行最近一次在命令行中执行且以字母s开头的命令。</p>
<p><strong>4.反复执行一个命令并在屏幕上输出</strong></p>
<p><strong><em>watch</em></strong>会反复运行一个命令，并在屏幕上打印输出。它可以让你实时的观察程序的输出变化。默认情况下，程序每2秒运行一次。<strong><em>watch</em></strong>命令与<strong><em>tail</em></strong>命令很相似。</p>
<pre class="prettyprint"><code><span class="pln">watch </span><span class="pun">-</span><span class="pln">d ls </span><span class="pun">-</span><span class="pln">l</span></code></pre>
<p>这条命令会监视当前目录的所有文件，并且高亮文件所发生的改变。</p>
<p><strong>5.在VI/VIM中快速保存</strong></p>
<p>如果你很匆忙，你可以通过<strong><em>【SHIFT + zz】</em></strong>&nbsp;快速从vi的插入模式中退出。</p>
<p><strong>6.快速登出终端</strong>&nbsp;你可以快速使用<strong><em>【CTRL+D】</em></strong>快速登出终端。</p>
<p><strong>7.返回你上一个所在目录</strong></p>
<p>你可以使用如下命令返回你上一次所在的目录：</p>
<pre class="prettyprint"><code><span class="pln">cd </span><span class="pun">-</span></code></pre>
<p><strong>8.聪明地创建父目录</strong></p>
<p>如下命令可以帮助你创建所有你需要的目录，即便是他们还不存在。为什么要浪费时间做一些愚蠢的事情比如：<strong><em>mkdir make ; cd make ; mkdir all ; cd all ; mkdir of ; cd of &hellip;</em></strong>&nbsp;你说到点子上了，使用<strong><em>mkdir -p</em></strong>！</p>
<pre class="prettyprint"><code><span class="pln">mkdir </span><span class="pun">-</span><span class="pln">p </span><span class="pun">/</span><span class="pln">home</span><span class="pun">/</span><span class="pln">adam</span><span class="pun">/</span><span class="pln">make</span><span class="pun">/</span><span class="pln">all</span><span class="pun">/</span><span class="pln">of</span><span class="pun">/</span><span class="pln">these</span><span class="pun">/</span><span class="pln">directories</span><span class="pun">/</span></code></pre>
<p><strong>9.删除一整行</strong></p>
<p>如果你已经输入一长串的命令，但是你又不在需要他们了，那么你可以使用如下命令直接删除一整行：</p>
<pre class="prettyprint"><code><span class="pln">CTRL</span><span class="pun">+</span><span class="pln">U</span></code></pre>
<p><strong>10.设置文件的时间戳</strong></p>
<p>下面这条命令会把文件的时间戳设置成2008-01-01 8:00。日期格式是(YYMMDDhhmm)</p>
<pre class="prettyprint"><code><span class="pln">touch </span><span class="pun">-</span><span class="pln">c </span><span class="pun">-</span><span class="pln">t </span><span class="lit">0801010800</span><span class="pln"> filename</span><span class="pun">.</span><span class="pln">c</span></code></pre>
<p>你还能想到哪些为大多数人所指的Linux命令？</p>
<p><strong>【摘自回复】</strong></p>
<p><strong>访问上一个命令的最后一个参数</strong>&nbsp;如果你之前执行了这样一条命令 cp assignment.htm /home/phill/reports/2008/ 然后你可以冲&nbsp;<strong>_$</strong>&nbsp;访问刚才那条命令最后一个参数"<em>/home/phill/reports/2008/</em>"，例如：</p>
<pre class="prettyprint"><code><span class="pln">cd $_</span></code></pre>
<p><strong>清除光标右边的内容</strong>&nbsp;上文有一个小错误，<strong><em>【Ctrl + U】</em></strong>并不是删除一整行，而是删除光标左边的内容，如果光标停留在行首，那么<strong><em>【Ctrl + U】</em></strong>将无任何作用，这个时候，需要删除光标右边内容：</p>
<pre class="prettyprint"><code><span class="pln">ctrl</span><span class="pun">-</span><span class="pln">k</span></code></pre>
<div><code><span class="pln">&nbsp;</span></code></div>
</div>]]></description></item><item><title>win7引导修复</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/25/2738554.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Thu, 25 Oct 2012 04:14:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/25/2738554.html</guid><description><![CDATA[<p><span>放入Win7安装盘，但不进光盘引导，在Win7启动菜单按F8，选择修复计算机，在修复命令行中键入bootrec /fixmbr就可以了</span></p>]]></description></item><item><title>Google PageRank</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/14/2721239.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sun, 14 Oct 2012 14:33:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/14/2721239.html</guid><description><![CDATA[<p><strong>edited </strong>from<strong> <em>How Google Finds Your Needle in the Web's Haystack</em></strong></p>
<hr />
<p>&nbsp;Google搜索的核心算法当然不止是PageRank，但PageRank确实是其中的核心部分。Google就曾经说过：&ldquo;the heart of our software is PageRank&rdquo;.</p>
<p>Google的PageRank算法声称他们比较了一个月来网页的受欢迎程度从而确定哪个网页显得比较重要。根据Sergey Brin和Lawrence Page的说法，一个网页的重要性不仅仅包括他们自身的重要程度，还包括链接向这个网页的其他网页数目。</p>
<p>综合公式为：</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_1.gif" alt="\[  I(P_i)=\sum_{P_j\in B_i} \frac{I(P_j)}{l_j}  \] " /></p>
<p>呵呵，看到这个公式我第一反应就是，&ldquo;我靠，这怎么整啊，这不是鸡生蛋，蛋生鸡&rdquo;的问题吗？果然，下面就有解决办法。</p>
<p>我们将这个问题转化为一个数学问题。</p>
<p>首先构造一个链接矩阵，<img src="http://www.ams.org/featurecolumn/images/december2006/index_2.gif" alt="$ {\bf H}=[H_{ij}] $ " />。其中：</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_3.gif" alt="\[  H_{ij}=\left\{\begin{array}{ll}1/l_{j} &amp;  	\hbox{if } P_j\in B_i \\ 	0 &amp; \hbox{otherwise} 	\end{array}\right.  \] " /></p>
<p>同时也创建一个向量<img src="http://www.ams.org/featurecolumn/images/december2006/index_4.gif" alt="$ I=[I(P_i)] $ " />，它的构成正是PageRank的值，也就是页面的相对重要程度。用数学表达式定义为：<img src="http://www.ams.org/featurecolumn/images/december2006/index_5.gif" alt="\[  I = {\bf H}I  \] " /></p>
<p>这个表达式其实也就是向量&nbsp;<em>I&nbsp;</em>为矩阵特征值为1的特征向量，也称呼它为H的固定向量。</p>
<p>下边是一个例子：</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/goodnet.jpg" alt="" /></p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.0.gif" alt="" />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.0.gif" alt="" /></p>
<p>这样看来，问题貌似得到了解决，我们获得了这8个网页的PageRank值。但是在现实中，这个矩阵的n为250亿，其中的大部分值为0，实际上，研究表明每个网页链接的平均数量是10，这表明每一列只有10个数值不为0。下面我们用一个叫<em>power method</em>的方法来寻找矩阵的固定向量。</p>
<p>&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="http://www.ams.org/featurecolumn/images/december2006/index_6.gif" alt="\[  I^{k+1}={\bf H}I^k  \] " /></p>
<center>
<table border="1" cellpadding="20" bgcolor="#ccccff">
<tbody>
<tr>
<td>
<p><em> <strong> General principle:</strong> The sequence <em>I <sup>k</sup></em> will converge to the stationary vector <em>I</em>.</em></p>
</td>
</tr>
</tbody>
</table>
</center>
<p>通过这个方法解释上面的例子</p>
<center>
<table border="1" cellpadding="5">
<tbody>
<tr>
<td bgcolor="#ffffcc"><em>I <sup>0</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>1</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>2</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>3</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>4</sup></em></td>
<td bgcolor="#ffffcc">...</td>
<td bgcolor="#ffffcc"><em>I <sup>60</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>61</sup></em></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.0278</td>
<td>...</td>
<td>0.06</td>
<td>0.06</td>
</tr>
<tr>
<td>0</td>
<td>0.5</td>
<td>0.25</td>
<td>0.1667</td>
<td>0.0833</td>
<td>...</td>
<td>0.0675</td>
<td>0.0675</td>
</tr>
<tr>
<td>0</td>
<td>0.5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>...</td>
<td>0.03</td>
<td>0.03</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>0.25</td>
<td>0.1667</td>
<td>...</td>
<td>0.0675</td>
<td>0.0675</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0.25</td>
<td>0.1667</td>
<td>0.1111</td>
<td>...</td>
<td>0.0975</td>
<td>0.0975</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.25</td>
<td>0.1806</td>
<td>...</td>
<td>0.2025</td>
<td>0.2025</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.0833</td>
<td>0.0972</td>
<td>...</td>
<td>0.18</td>
<td>0.18</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.0833</td>
<td>0.3333</td>
<td>...</td>
<td>0.295</td>
<td>0.295</td>
</tr>
</tbody>
</table>
</center>
<p>得到的结果只是网页重要程度的相对比值，如果要的到最终的PageRank数值，还需要对它进行线性增加，使得它们的总和为1。</p>
<p>&nbsp;</p>
<p>有三个问题自然地就提出来了：</p>
<ul>
<li><span>&nbsp;</span><em>I<sup>&nbsp;k</sup></em>是否会汇聚到1</li>
<li>向量是否与<em>I<sup>0</sup></em>的取值无关</li>
<li>是否包含了我们想要的信息，也就是达到充分统计</li>
</ul>
<p>现在我们对这三个问题还只能说No，但接下来我们将会修改我们的方法使得对这三个问题的回答得到肯定。</p>
<center>
<table cellpadding="20">
<tbody>
<tr>
<td><img src="http://www.ams.org/featurecolumn/images/december2006/dangling.jpg" alt="" /></td>
<td>
<p>with matrix</p>
</td>
<td><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.3.gif" alt="" /></td>
</tr>
</tbody>
</table>
</center>
<p>结果如下：</p>
<center>
<table border="1" cellpadding="5">
<tbody>
<tr>
<td bgcolor="#ffffcc"><em>I <sup>0</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>1</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>2</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>3</sup>=<em>I</em></em></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td align="center">0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
</center>
<p>上面例子的问题是P2并没有链接，它在每次迭代中获取了P1的一些权重，但是却不传给其他网页。像这样没有链接的节点我们称它为悬挂节点，显然，真实环境中这样的网页还很多。要解决这个问题，我们可以转换一种思维方式来思考PageRank，或者说用另外一种视角。</p>
<p>设想我们随机的上网冲浪，我们会随机地从一个页面跳转到另外一个页面。设我们浏览的页面为Pj，它拥有j个链接，其中一个将我们链接到Pi这个页面，那么我们最终浏览Pi页面的概率为1/lj。因为是随机冲浪的，所以我们可以用时间来类比，我们是将在Pj上面浏览的一个时间碎片交给了Pi，也就是Tj/lj。如此叠加，我们可以确定Pi的时间为：</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_10.gif" alt="\[  T_i = \sum_{P_j\in B_i} T_j/l_j  \] " /></p>
<p>也就是说<img src="http://www.ams.org/featurecolumn/images/december2006/index_11.gif" alt="$  I(P_i) = T_i $ " />。</p>
<p>利用这种视角考虑一个没有任何链接的悬挂节点。我们不可能在这个页面上终止我们的网上冲浪，我们会随机的浏览另外一个网页，可能是通过浏览器的地址栏输入或以其他方式跳转，那么我们可以得到我们跳转向某个页面的概率为1/n，n为总的页面数。下面我们重新定义下上一个例子：</p>
<center>
<table cellpadding="5">
<tbody>
<tr>
<td><img src="http://www.ams.org/featurecolumn/images/december2006/dangling.jpg" alt="" /></td>
<td>
<p>with matrix</p>
</td>
<td><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.4.gif" alt="" /></td>
<td>
<p>and eigenvector</p>
</td>
<td><img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.4.gif" alt="" /></td>
</tr>
</tbody>
</table>
</center>
<p>通常说来，<em>power method</em>是用来寻找矩阵特征向量对应的最大特征值的。在我们上面的例子中使用了特征值为1，实际上我们可以用比1小的特征值。 假设S的特征值为<img src="http://www.ams.org/featurecolumn/images/december2006/index_14.gif" alt="$ \lambda_j $ " />。有</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_15.gif" alt="\[  1 = \lambda_1 &gt; |\lambda_2| \geq |\lambda_3| \geq \ldots \geq |\lambda_n|   \] " /></p>
<p>则有：</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_17.gif" alt="\[  I^0 = c_1v_1+c_2v_2 + \ldots + c_nv_n  \] " align="absmiddle" /></p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_18.gif" alt=" \begin{eqnarray*} I^1={\bf S}I^0 &amp;=&amp;c_1v_1+c_2\lambda_2v_2 + \ldots + c_n\lambda_nv_n \\ I^2={\bf S}I^1 &amp;=&amp;c_1v_1+c_2\lambda_2^2v_2 + \ldots + c_n\lambda_n^2v_n \\ \vdots &amp; &amp; \vdots \\ I^{k}={\bf S}I^{k-1} &amp;=&amp;c_1v_1+c_2\lambda_2^kv_2 + \ldots + c_n\lambda_n^kv_n \\ \end{eqnarray*}  " /></p>
<p>Since the eigenvalues&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_19.gif" alt="$ \lambda_j $ " align="absmiddle" />&nbsp;with&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_20.gif" alt="$ j\geq2 $ " align="absmiddle" />&nbsp;have magnitude smaller than one, it follows that&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_21.gif" alt="$ \lambda_j^k\to0 $ " align="absmiddle" />&nbsp;if&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_22.gif" alt="$ j\geq2 $ " align="absmiddle" />and therefore&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_23.gif" alt="$ I^k\to I=c_1v_1 $ " align="absmiddle" />&nbsp;, an eigenvector corresponding to the eigenvalue 1.</p>
<p>It is important to note here that the rate at which&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_24.gif" alt="$ I^k\to I $ " align="absmiddle" />&nbsp;is determined by&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_25.gif" alt="$ |\lambda_2| $ " align="absmiddle" />&nbsp;. When&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_26.gif" alt="$ |\lambda_2| $ " align="absmiddle" />&nbsp;is relatively close to 0, then&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_27.gif" alt="$ \lambda_2^k\to0 $ " align="absmiddle" />&nbsp;relatively quickly.</p>
<p>以上的讨论中，我们假设矩阵S的&nbsp;<img src="http://www.ams.org/featurecolumn/images/december2006/index_34.gif" alt="$ \lambda_1=1 $ " align="absmiddle" />&nbsp;并且<img src="http://www.ams.org/featurecolumn/images/december2006/index_35.gif" alt="$  |\lambda_2|&lt;1 $ " align="absmiddle" />&nbsp;，但实际上不常是这样的。</p>
<p>下面的例子:</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/cyclic.jpg" alt="" width="361" height="372" /><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.1.gif" alt="" width="178" height="126" /></p>
<p>那么有</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
<table border="1" cellpadding="5">
<tbody>
<tr>
<td bgcolor="#ffffcc"><em>I <sup>0</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>1</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>2</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>3</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>4</sup></em></td>
<td bgcolor="#ffffcc"><em>I <sup>5</sup></em></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</center>
<p><span>the sequence of vectors&nbsp;</span><em>I&nbsp;<sup>k</sup></em><span>&nbsp;fails to converge。这是因为<img src="http://www.ams.org/featurecolumn/images/december2006/index_36.gif" alt="$ |\lambda_2|=1 $ " />，所以power method就失效了。</span></p>
<p><span><span>为了保证</span><img src="http://www.ams.org/featurecolumn/images/december2006/index_37.gif" alt="$ |\lambda_2|&lt;1 $ " align="absmiddle" /><span>&nbsp;, 矩阵</span><strong>S</strong><span>&nbsp;必须&nbsp;</span><em>primitive。 </em>这意味着对于某个自然数<em><em>m</em><span>,&nbsp;</span><strong>S</strong><sup><em>m</em></sup></em>中的数值全为正。也就是说，对于两个页面，最多经过m个链接，可以从第一个页面跳转到第二个页面。显然，上个例子并不满足。<em><span><br /></span></em></span></p>
<p><span>下面是另外一个例子：</span></p>
<p><span><img style="display: block; margin-left: auto; margin-right: auto;" src="http://www.ams.org/featurecolumn/images/december2006/reducible.jpg" alt="" width="542" height="271" /></span></p>
<table cellpadding="20">
<tbody>
<tr>
<td valign="center">        <img src="http://www.ams.org/featurecolumn/images/december2006/matrix.2.gif" alt="" /></td>
<td valign="center">
<p>with stationary vector</p>



</td>
<td valign="center">   <img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.2.gif" alt="" /></td>



   </tr>



   </tbody>



</table>
<p>有4个网页的PageRank为0，这显然不对，原因是上图中内涵一个更小的网络。</p>
<p><img style="vertical-align: middle; display: block; margin-left: auto; margin-right: auto;" src="http://www.ams.org/featurecolumn/images/december2006/reduciblewithbox.2.jpg" alt="" width="542" height="271" /></p>
<p>就像上面所说的悬挂节点一样，前4个页面的权值进入蓝色的区域后，就在内部消化而不返回出来，其余4个页面获得了前4个页面所有的权值。这是因为矩阵S是可约的，也就是如下形式：</p>
<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_39.gif" alt="\[  S=\left[\begin{array}{cc} * &amp; 0 \\ * &amp; * \end{array}\right].  \] " /></p>
<p>要达到不可约，则网络图必须是强连通的，只有强连通图，才能保证有不可约的矩阵。</p>
<p>最终修改：</p>
<p>我们需要重新构造我们的上网行为：我们在浏览有链接的网站时，仍然有一定的几率不遵守这个网站上面的链接，而直接在地址栏上面输入我们想要去的网站，假设这个概率为<img src="http://www.ams.org/featurecolumn/images/december2006/index_42.gif" alt="$ 1-\alpha $ " />。</p>
<p>最终的公式为：<img src="http://www.ams.org/featurecolumn/images/december2006/index_44.gif" alt="\[  {\bf G}=\alpha{\bf S}+ (1-\alpha)\frac{1}{n}{\bf 1}  \] " /></p>
<p>显然<img src="http://www.ams.org/featurecolumn/images/december2006/xx.gif" alt="$\alpha$ " />值应该要非常接近1，根据大量的实验结果，Serbey Brin和Larry Page选择了0.85。</p>
<p>使用<em>power method</em>则公式为：</p>
<p>&nbsp;</p>
<center><img src="http://www.ams.org/featurecolumn/images/december2006/index_52.gif" alt="\[  {\bf S}={\bf H} + {\bf A}  \] " align="absmiddle" /></center>
<p>&nbsp;</p>
<center><img src="http://www.ams.org/featurecolumn/images/december2006/index_53.gif" alt="\[  {\bf G}=\alpha{\bf H} + \alpha{\bf A} + \frac{1-\alpha}{n}{\bf 1}  \] " align="absmiddle" /></center>
<p>&nbsp;</p>
<center><img src="http://www.ams.org/featurecolumn/images/december2006/index_54.gif" alt="\[  {\bf G}I^k=\alpha{\bf H}I^k + \alpha{\bf A}I^k + \frac{1-\alpha}{n}{\bf 1}I^k  \] " align="absmiddle" /></center>]]></description></item><item><title>最短路径算法</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/10/2705930.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Wed, 10 Oct 2012 01:27:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/10/2705930.html</guid><description><![CDATA[<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>单源最短路径</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif; font-size: 15px;">1. Dijkstra</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;Dijkstra算法解决有向图上带权的单源最短路径问题，要求所有边的权值非负。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">用到了顶点的最小优先队列，排序关键字为顶点的d值。即开始出了根为0，其他</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">顶点为正无穷，后来d值根据松弛算法变化。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">总计运行时间为O((V+E)lgV)，如果所有顶点都可达的话，则为O(ElgV)。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif; font-size: 15px;">2. Bellman-ford</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">算法用来解决一般，即边的权值可以为负的单源最短路径问题。算法同时也可以检查</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">是否有从源点可达的负权回路。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">算法的运行时间为O(VE)。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">在Dijkstra算法以及关于有向无回路图的最短路径算法中，对每条边执行一次松弛操作。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">在Bellman-Ford算法中，对每条边要执行多次松弛操作。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>每对顶点间的最短路径</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif; font-size: 15px;">1. Floyd-Wallshall</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">属于动态规划方案，允许存在权值为负的边，但不存在权值为负的回路。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">算法考虑最短路径上的中间顶点，自底向上利用中间顶点K值递增的顺序计算权值</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">利用的递归式为</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><em>D<sub>i,j,k</sub>&nbsp;= min(D<sub>i,k,k&nbsp;&minus; 1</sub>&nbsp;+&nbsp;D<sub>k,j,k&nbsp;&minus; 1</sub>,D<sub>i,j,k&nbsp;&minus; 1</sub>)　　K &gt;= 1</em></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><em>　　　= W<sub>i,j</sub>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　 &nbsp;K = 0</em></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><em><br /></em>算法运行时间为&Phi;(n<sup>3</sup>)。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">利用Floyd算法可以计算出有向图的传递闭包，即确定对所有顶点对，图中是否都存在一条</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">从 i 到 j 的路径。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">用相应的逻辑运算或和并来替换 min 和 + 用以增加运算速度。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif; font-size: 15px;">2. 稀疏图上的Johnson算法</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">对于稀疏图改算法在渐进意义上要好于矩阵的重复平方或Floyd-Wallshall算法。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">Johnson算法吧Dijkstra算法和Bellman-Ford算法作为其的子程序。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">通过重新赋权值保持最短路径和产生非负的权。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">若采用斐波那契堆来实现Dijkstra算法的最小优先队列则运算时间是</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><span>O(V<sup>2</sup>lgV + VE</span>)。更简单的二叉堆实现，则可以得到O(VElgV)的运行时间。</span></p>]]></description></item><item><title>linux内核代码风格</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/07/2714136.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sun, 07 Oct 2012 08:00:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/07/2714136.html</guid><description><![CDATA[<div>Chinese translated version of Documentation/CodingStyle</div>
<div>&nbsp;</div>
<div>If you have any comment or update to the content, please post to LKML directly.</div>
<div>However, if you have problem communicating in English you can also ask the</div>
<div>Chinese maintainer for help. &nbsp;Contact the Chinese maintainer, if this</div>
<div>translation is outdated or there is problem with translation.</div>
<div>&nbsp;</div>
<div>Chinese maintainer: Zhang Le &lt;r0bertz@gentoo.org&gt;</div>
<div>---------------------------------------------------------------------</div>
<div>Documentation/CodingStyle的中文翻译</div>
<div>&nbsp;</div>
<div>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话，也可</div>
<div>以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版维护者。</div>
<div>&nbsp;</div>
<div>中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</div>
<div>中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</div>
<div>中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wheelz &lt;kernel.zeng@gmail.com&gt;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Li Zefan &lt;lizf@cn.fujitsu.com&gt;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</div>
<div>以下为正文</div>
<div>---------------------------------------------------------------------</div>
<div>&nbsp;</div>
<div>Linux内核代码风格</div>
<div>&nbsp;</div>
<div>这是一个简短的文档，描述了linux内核的首选代码风格。代码风格是因人而异的，而且我</div>
<div>不愿意把我的观点强加给任何人，不过这里所讲述的是我必须要维护的代码所遵守的风格，</div>
<div>并且我也希望绝大多数其他代码也能遵守这个风格。请在写代码时至少考虑一下本文所述的</div>
<div>风格。</div>
<div>&nbsp;</div>
<div>首先，我建议你打印一份GNU代码规范，然后不要读它。烧了它，这是一个具有重大象征性</div>
<div>意义的动作。</div>
<div>&nbsp;</div>
<div>不管怎样，现在我们开始：</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;第一章：缩进</div>
<div>&nbsp;</div>
<div>制表符是8个字符，所以缩进也是8个字符。有些异端运动试图将缩进变为4（乃至2）个字符</div>
<div>深，这几乎相当于尝试将圆周率的值定义为3。</div>
<div>&nbsp;</div>
<div>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的屏幕</div>
<div>连续看了20小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</div>
<div>&nbsp;</div>
<div>现在，有些人会抱怨8个字符的缩进会使代码向右边移动的太远，在80个字符的终端屏幕上</div>
<div>就很难读这样的代码。这个问题的答案是，如果你需要3级以上的缩进，不管用何种方式你</div>
<div>的代码已经有问题了，应该修正你的程序。</div>
<div>&nbsp;</div>
<div>简而言之，8个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的</div>
<div>时候可以给你警告。留心这个警告。</div>
<div>&nbsp;</div>
<div>在switch语句中消除多级缩进的首选的方式是让&ldquo;switch&rdquo;和从属于它的&ldquo;case&rdquo;标签对齐于同</div>
<div>一列，而不要&ldquo;两次缩进&rdquo;&ldquo;case&rdquo;标签。比如：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (suffix) {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">G</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">g</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 4</span>     mem &lt;&lt;= <span style="color: #800080;">30</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">M</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">m</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 8</span>     mem &lt;&lt;= <span style="color: #800080;">20</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">K</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">k</span><span style="color: #800000;">'</span><span style="color: #000000;">:
</span><span style="color: #008080;">12</span>     mem &lt;&lt;= <span style="color: #800080;">10</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span>     <span style="color: #008000;">/*</span><span style="color: #008000;"> fall through </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">14</span>     <span style="color: #0000ff;">default</span><span style="color: #000000;">:
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">16</span> }</pre>
</div>
<p>&nbsp;</p>
</div>
<div>不要把多个语句放在一行里，除非你有什么东西要隐藏：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (condition) do_this;
</span><span style="color: #008080;">2</span>   do_something_everytime;</pre>
</div>
<p>&nbsp;也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读的表</p>
</div>
<div>达式。</div>
<div>&nbsp;</div>
<div>除了注释、文档和Kconfig之外，不要使用空格来缩进，前面的例子是例外，是有意为之。</div>
<div>&nbsp;</div>
<div>选用一个好的编辑器，不要在行尾留空格。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第二章：把长的行和字符串打散</div>
<div>&nbsp;</div>
<div>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</div>
<div>&nbsp;</div>
<div>每一行的长度的限制是80列，我们强烈建议您遵守这个惯例。</div>
<div>&nbsp;</div>
<div>长于80列的语句要打散成有意义的片段。每个片段要明显短于原来的语句，而且放置的位置</div>
<div>也明显的靠右。同样的规则也适用于有很长参数列表的函数头。长字符串也要打散成较短的</div>
<div>字符串。唯一的例外是超过80列可以大幅度提高可读性并且不会隐藏信息的情况。</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">void</span> fun(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b, <span style="color: #0000ff;">int</span><span style="color: #000000;"> c)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (condition)
</span><span style="color: #008080;">4</span>         printk(KERN_WARNING <span style="color: #800000;">"</span><span style="color: #800000;">Warning this is a long printk with </span><span style="color: #800000;">"</span>
<span style="color: #008080;">5</span>         <span style="color: #800000;">"</span><span style="color: #800000;">3 parameters a: %u b: %u </span><span style="color: #800000;">"</span>
<span style="color: #008080;">6</span>         <span style="color: #800000;">"</span><span style="color: #800000;">c: %u \n</span><span style="color: #800000;">"</span><span style="color: #000000;">, a, b, c);
</span><span style="color: #008080;">7</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;">8</span> <span style="color: #000000;">        next_statement;
</span><span style="color: #008080;">9</span> }</pre>
</div>
</div>
<div>第三章：大括号和空格的放置</div>
<div>&nbsp;</div>
<div>C语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策</div>
<div>略并没有多少技术上的原因，不过首选的方式，就像Kernighan和Ritchie展示给我们的，是</div>
<div>把起始大括号放在行尾，而把结束大括号放在行首，所以：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (x <span style="color: #0000ff;">is</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
</span><span style="color: #008080;">2</span> 　　we <span style="color: #0000ff;">do</span><span style="color: #000000;"> y
</span><span style="color: #008080;">3</span> <span style="color: #000000;">}
</span><span style="color: #008080;">4</span>  </pre>
</div>
</div>
<div>这适用于所有的非函数语句块（if、switch、for、while、do）。比如：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (action) {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">case</span><span style="color: #000000;"> KOBJ_ADD:
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">add</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">case</span><span style="color: #000000;"> KOBJ_REMOVE:
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">remove</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">case</span><span style="color: #000000;"> KOBJ_CHANGE:
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">change</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">default</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 9</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
</span><span style="color: #008080;">10</span> }</pre>
</div>
</div>
<div>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">int</span> function(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span> <span style="color: #000000;">　　body of function
</span><span style="color: #008080;">4</span> }</pre>
</div>
</div>
<div>全世界的异端可能会抱怨这个不一致性是&hellip;&hellip;呃&hellip;&hellip;不一致的，不过所有思维健全的人都知道（</div>
<div>a）K&amp;R是_正确的_，并且（b）K&amp;R是正确的。此外，不管怎样函数都是特殊的（在C语言中</div>
<div>，函数是不能嵌套的）。</div>
<div>&nbsp;</div>
<div>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是do语句中的</div>
<div>&ldquo;while&rdquo;或者if语句中的&ldquo;else&rdquo;，像这样：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">do</span><span style="color: #000000;"> {
</span><span style="color: #008080;">2</span> 　　body of <span style="color: #0000ff;">do</span>-<span style="color: #000000;">loop
</span><span style="color: #008080;">3</span> } <span style="color: #0000ff;">while</span> (condition);</pre>
</div>
</div>
<div>和</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (x ==<span style="color: #000000;"> y) {
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    ..
</span><span style="color: #008080;">3</span> } <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (x &gt;<span style="color: #000000;"> y) {
</span><span style="color: #008080;">4</span> <span style="color: #000000;">    ...
</span><span style="color: #008080;">5</span> } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">6</span> <span style="color: #000000;">    ....
</span><span style="color: #008080;">7</span> <span style="color: #000000;">}
</span><span style="color: #008080;">8</span>  </pre>
</div>
</div>
<div>理由：K&amp;R。</div>
<div>&nbsp;</div>
<div>也请注意这种大括号的放置方式也能使空（或者差不多空的）行的数量最小化，同时不失可</div>
<div>读性。因此，由于你的屏幕上的新行是不可再生资源（想想25行的终端屏幕），你将会有更</div>
<div>多的空行来放置注释。</div>
<div>&nbsp;</div>
<div>当只有一个单独的语句的时候，不用加不必要的大括号。</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (condition)
</span><span style="color: #008080;">2</span> 　　action();</pre>
</div>
</div>
<div>这点不适用于本身为某个条件语句的一个分支的单独语句。这时需要在两个分支里都使用大</div>
<div>括号。</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (condition) {
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    do_this();
</span><span style="color: #008080;">3</span> <span style="color: #000000;">    do_that();
</span><span style="color: #008080;">4</span> } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">5</span> <span style="color: #000000;">    otherwise();
</span><span style="color: #008080;">6</span> }</pre>
</div>
</div>
<div>3.1：空格</div>
<div>&nbsp;</div>
<div>Linux内核的空格使用方式（主要）取决于它是用于函数还是关键字。（大多数）关键字后</div>
<div>要加一个空格。值得注意的例外是sizeof、typeof、alignof和__attribute__，这些关键字</div>
<div>某些程度上看起来更像函数（它们在Linux里也常常伴随小括号而使用，尽管在C语言里这样</div>
<div>的小括号不是必需的，就像&ldquo;struct fileinfo info&rdquo;声明过后的&ldquo;sizeof info&rdquo;）。</div>
<div>&nbsp;</div>
<div>所以在这些关键字之后放一个空格：</div>
<div>if, switch, case, for, do, while</div>
<div>但是不要在sizeof、typeof、alignof或者__attribute__这些关键字之后放空格。例如，</div>
<div>s = sizeof(struct file);</div>
<div>&nbsp;</div>
<div>不要在小括号里的表达式两侧加空格。这是一个反例：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> s = <span style="color: #0000ff;">sizeof</span>( <span style="color: #0000ff;">struct</span> file );</pre>
</div>
</div>
<div>当声明指针类型或者返回指针类型的函数时，&ldquo;*&rdquo;的首选使用方式是使之靠近变量名或者函</div>
<div>数名，而不是靠近类型名。例子：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">linux_banner;
</span><span style="color: #008080;">2</span> unsigned <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> memparse(<span style="color: #0000ff;">char</span> *ptr, <span style="color: #0000ff;">char</span> **<span style="color: #000000;">retptr);
</span><span style="color: #008080;">3</span> <span style="color: #0000ff;">char</span> *match_strdup(substring_t *s);</pre>
</div>
</div>
<div>在大多数二元和三元操作符两侧使用一个空格，例如下面所有这些操作符：</div>
<div>&nbsp;</div>
<div>= &nbsp;+ &nbsp;- &nbsp;&lt; &nbsp;&gt; &nbsp;* &nbsp;/ &nbsp;% &nbsp;| &nbsp;&amp; &nbsp;^ &nbsp;&lt;= &nbsp;&gt;= &nbsp;== &nbsp;!= &nbsp;? &nbsp;:</div>
<div>&nbsp;</div>
<div>但是一元操作符后不要加空格：</div>
<div>&amp; &nbsp;* &nbsp;+ &nbsp;- &nbsp;~ &nbsp;! &nbsp;sizeof &nbsp;typeof &nbsp;alignof &nbsp;__attribute__ &nbsp;defined</div>
<div>&nbsp;</div>
<div>后缀自加和自减一元操作符前不加空格：</div>
<div>++ &nbsp;--</div>
<div>&nbsp;</div>
<div>前缀自加和自减一元操作符后不加空格：</div>
<div>++ &nbsp;--</div>
<div>&nbsp;</div>
<div>&ldquo;.&rdquo;和&ldquo;-&gt;&rdquo;结构体成员操作符前后不加空格。</div>
<div>&nbsp;</div>
<div>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后你</div>
<div>就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器就不</div>
<div>会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就这样产</div>
<div>生了。</div>
<div>&nbsp;</div>
<div>当git发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白；不过</div>
<div>如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第四章：命名</div>
<div>&nbsp;</div>
<div>C是一个简朴的语言，你的命名也应该这样。和Modula-2和Pascal程序员不同，C程序员不使</div>
<div>用类似ThisVariableIsATemporaryCounter这样华丽的名字。C程序员会称那个变量为&ldquo;tmp&rdquo;</div>
<div>，这样写起来会更容易，而且至少不会令其难于理解。</div>
<div>&nbsp;</div>
<div>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字</div>
<div>。称一个全局函数为&ldquo;foo&rdquo;是一个难以饶恕的错误。</div>
<div>&nbsp;</div>
<div>全局变量（只有当你真正需要它们的时候再用它）需要有一个具描述性的名字，就像全局函</div>
<div>数。如果你有一个可以计算活动用户数量的函数，你应该叫它&ldquo;count_active_users()&rdquo;或者</div>
<div>类似的名字，你不应该叫它&ldquo;cntuser()&rdquo;。</div>
<div>&nbsp;</div>
<div>在函数名中包含函数类型（所谓的匈牙利命名法）是脑子出了问题&mdash;&mdash;编译器知道那些类型而</div>
<div>且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</div>
<div>&nbsp;</div>
<div>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器</div>
<div>，它应该被称为&ldquo;i&rdquo;。叫它&ldquo;loop_counter&rdquo;并无益处，如果它没有被误解的可能的话。类似</div>
<div>的，&ldquo;tmp&rdquo;可以用来称呼任意类型的临时变量。</div>
<div>&nbsp;</div>
<div>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症</div>
<div>。请看第六章（函数）。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第五章：Typedef</div>
<div>&nbsp;</div>
<div>不要使用类似&ldquo;vps_t&rdquo;之类的东西。</div>
<div>&nbsp;</div>
<div>对结构体和指针使用typedef是一个错误。当你在代码里看到：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">vps_t a;</span></pre>
</div>
</div>
<div>这代表什么意思呢？</div>
<div>&nbsp;</div>
<div>相反，如果是这样</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">struct</span> virtual_container *a;</pre>
</div>
</div>
<div>你就知道&ldquo;a&rdquo;是什么了。</div>
<div>&nbsp;</div>
<div>很多人认为typedef&ldquo;能提高可读性&rdquo;。实际不是这样的。它们只在下列情况下有用：</div>
<div>&nbsp;</div>
<div>&nbsp;(a) 完全不透明的对象（这种情况下要主动使用typedef来隐藏这个对象实际上是什么）。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;例如：&ldquo;pte_t&rdquo;等不透明对象，你只能用合适的访问函数来访问它们。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;注意！不透明性和&ldquo;访问函数&rdquo;本身是不好的。我们使用pte_t等类型的原因在于真的是</div>
<div>&nbsp; &nbsp; &nbsp;完全没有任何共用的可访问信息。</div>
<div>&nbsp;</div>
<div>&nbsp;(b) 清楚的整数类型，如此，这层抽象就可以帮助消除到底是&ldquo;int&rdquo;还是&ldquo;long&rdquo;的混淆。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;u8/u16/u32是完全没有问题的typedef，不过它们更符合类别(d)而不是这里。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;再次注意！要这样做，必须事出有因。如果某个变量是&ldquo;unsigned long&ldquo;，那么没有必要</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> typedef unsigned <span style="color: #0000ff;">long</span> myflags_t;</pre>
</div>
</div>
<div>&nbsp; &nbsp; &nbsp;</div>
<div>不过如果有一个明确的原因，比如它在某种情况下可能会是一个&ldquo;unsigned int&rdquo;而在</div>
<div>其他情况下可能为&ldquo;unsigned long&rdquo;，那么就不要犹豫，请务必使用typedef。</div>
<div>&nbsp;</div>
<div>&nbsp;(c) 当你使用sparse按字面的创建一个新类型来做类型检查的时候。</div>
<div>&nbsp;</div>
<div>&nbsp;(d) 和标准C99类型相同的类型，在某些例外的情况下。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;虽然让眼睛和脑筋来适应新的标准类型比如&ldquo;uint32_t&rdquo;不需要花很多时间，可是有些</div>
<div>&nbsp; &nbsp; &nbsp;人仍然拒绝使用它们。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;因此，Linux特有的等同于标准类型的&ldquo;u8/u16/u32/u64&rdquo;类型和它们的有符号类型是被</div>
<div>&nbsp; &nbsp; &nbsp;允许的&mdash;&mdash;尽管在你自己的新代码中，它们不是强制要求要使用的。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</div>
<div>&nbsp;</div>
<div>&nbsp;(e) 可以在用户空间安全使用的类型。</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp;在某些用户空间可见的结构体里，我们不能要求C99类型而且不能用上面提到的&ldquo;u32&rdquo;</div>
<div>&nbsp; &nbsp; &nbsp;类型。因此，我们在与用户空间共享的所有结构体中使用__u32和类似的类型。</div>
<div>&nbsp;</div>
<div>可能还有其他的情况，不过基本的规则是永远不要使用typedef，除非你可以明确的应用上</div>
<div>述某个规则中的一个。</div>
<div>&nbsp;</div>
<div>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不</div>
<div>应该是一个typedef。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第六章：函数</div>
<div>&nbsp;</div>
<div>函数应该简短而漂亮，并且只完成一件事情。函数应该可以一屏或者两屏显示完（我们都知</div>
<div>道ISO/ANSI屏幕大小是80x24），只做一件事情，而且把它做好。</div>
<div>&nbsp;</div>
<div>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上</div>
<div>很简单的只有一个很长（但是简单）的case语句的函数，而且你需要在每个case里做很多很</div>
<div>小的事情，这样的函数尽管很长，但也是可以的。</div>
<div>&nbsp;</div>
<div>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至</div>
<div>搞不清楚这个函数的目的，你应该严格的遵守前面提到的长度限制。使用辅助函数，并为之</div>
<div>取个具描述性的名字（如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的</div>
<div>效果往往会比你写一个复杂函数的效果要好。）</div>
<div>&nbsp;</div>
<div>函数的另外一个衡量标准是本地变量的数量。此数量不应超过5－10个，否则你的函数就有</div>
<div>问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟</div>
<div>踪7个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你2</div>
<div>个星期前做过的事情。</div>
<div>&nbsp;</div>
<div>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的EXPORT*宏应该紧贴</div>
<div>在它的结束大括号之下。比如：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">int</span> system_is_up(<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">return</span> system_state ==<span style="color: #000000;"> SYSTEM_RUNNING;
</span><span style="color: #008080;">4</span> <span style="color: #000000;">}
</span><span style="color: #008080;">5</span> EXPORT_SYMBOL(system_is_up);</pre>
</div>
<p>&nbsp;</p>
</div>
<div>在函数原型中，包含函数名和它们的数据类型。虽然C语言里没有这样的要求，在Linux里这</div>
<div>是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第七章：集中的函数退出途径</div>
<div>&nbsp;</div>
<div>虽然被某些人声称已经过时，但是goto语句的等价物还是经常被编译器所使用，具体形式是</div>
<div>无条件跳转指令。</div>
<div>&nbsp;</div>
<div>当一个函数从多个位置退出并且需要做一些通用的清理工作的时候，goto的好处就显现出来</div>
<div>了。</div>
<div>&nbsp;</div>
<div>理由是：</div>
<div>&nbsp;</div>
<div>- 无条件语句容易理解和跟踪</div>
<div>- 嵌套程度减小</div>
<div>- 可以避免由于修改时忘记更新某个单独的退出点而导致的错误</div>
<div>- 减轻了编译器的工作，无需删除冗余代码;)</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">int</span> fun(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a)
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">int</span> result = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">char</span> *buffer =<span style="color: #000000;"> kmalloc(SIZE);
</span><span style="color: #008080;"> 5</span>      
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">if</span> (buffer ==<span style="color: #000000;"> NULL)
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">return</span> -<span style="color: #000000;">ENOMEM;
</span><span style="color: #008080;"> 8</span>      
<span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (condition1) {
</span><span style="color: #008080;">10</span>         <span style="color: #0000ff;">while</span><span style="color: #000000;"> (loop1) {
</span><span style="color: #008080;">11</span> <span style="color: #000000;">            ...
</span><span style="color: #008080;">12</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">13</span>         result = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span>         <span style="color: #0000ff;">goto</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">16</span> <span style="color: #000000;">    ...
</span><span style="color: #008080;">17</span>     <span style="color: #0000ff;">out</span><span style="color: #000000;">:
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    kfree(buffer);
</span><span style="color: #008080;">19</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
</span><span style="color: #008080;">20</span> }</pre>
</div>
</div>
<div>&nbsp;</div>
<div>第八章：注释</div>
<div>&nbsp;</div>
<div>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的：更好</div>
<div>的做法是让别人一看你的代码就可以明白，解释写的很差的代码是浪费时间。</div>
<div>&nbsp;</div>
<div>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释</div>
<div>放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到</div>
<div>第六章看一看。你可以做一些小注释来注明或警告某些很聪明（或者槽糕）的做法，但不要</div>
<div>加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么，也可以加上它做这</div>
<div>些事情的原因。</div>
<div>&nbsp;</div>
<div>当注释内核API函数时，请使用kernel-doc格式。请看</div>
<div>Documentation/kernel-doc-nano-HOWTO.txt和scripts/kernel-doc以获得详细信息。</div>
<div>&nbsp;</div>
<div>Linux的注释风格是C89&ldquo;/* ... */&rdquo;风格。不要使用C99风格&ldquo;// ...&rdquo;注释。</div>
<div>&nbsp;</div>
<div>长（多行）的首选注释风格是：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>  
<span style="color: #008080;">2</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">3</span> <span style="color: #008000;"> * This is the preferred style for multi-line
</span><span style="color: #008080;">4</span> <span style="color: #008000;"> * comments in the Linux kernel source code.
</span><span style="color: #008080;">5</span> <span style="color: #008000;"> * Please use it consistently.
</span><span style="color: #008080;">6</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">7</span> <span style="color: #008000;"> * Description:  A column of asterisks on the left side,
</span><span style="color: #008080;">8</span> <span style="color: #008000;"> * with beginning and ending almost-blank lines.
</span><span style="color: #008080;">9</span>  <span style="color: #008000;">*/</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行应只</div>
<div>声明一个数据（不要使用逗号来一次声明多个数据）。这样你就有空间来为每个数据写一段</div>
<div>小注释来解释它们的用途了。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第九章：你已经把事情弄糟了</div>
<div>&nbsp;</div>
<div>这没什么，我们都是这样。可能你的使用了很长时间Unix的朋友已经告诉你&ldquo;GNU emacs&rdquo;能</div>
<div>自动帮你格式化C源代码，而且你也注意到了，确实是这样，不过它所使用的默认值和我们</div>
<div>想要的相去甚远（实际上，甚至比随机打的还要差&mdash;&mdash;无数个猴子在GNU emacs里打字永远不</div>
<div>会创造出一个好程序）（译注：请参考Infinite Monkey Theorem）</div>
<div>&nbsp;</div>
<div>所以你要么放弃GNU emacs，要么改变它让它使用更合理的设定。要采用后一个方案，你可</div>
<div>以把下面这段粘贴到你的.emacs文件里。</div>
<div>&nbsp;</div>
<div>(defun linux-c-mode ()</div>
<div>&nbsp; "C mode with adjusted defaults for use with the Linux kernel."</div>
<div>&nbsp; (interactive)</div>
<div>&nbsp; (c-mode)</div>
<div>&nbsp; (c-set-style "K&amp;R")</div>
<div>&nbsp; (setq tab-width 8)</div>
<div>&nbsp; (setq indent-tabs-mode t)</div>
<div>&nbsp; (setq c-basic-offset 8))</div>
<div>&nbsp;</div>
<div>这样就定义了M-x linux-c-mode命令。当你hack一个模块的时候，如果你把字符串</div>
<div>-*- linux-c -*-放在头两行的某个位置，这个模式将会被自动调用。如果你希望在你修改</div>
<div>/usr/src/linux里的文件时魔术般自动打开linux-c-mode的话，你也可能需要添加</div>
<div>&nbsp;</div>
<div>(setq auto-mode-alist (cons '("/usr/src/linux.*/.*\\.[ch]$" . linux-c-mode)</div>
<div>auto-mode-alist))</div>
<div>&nbsp;</div>
<div>到你的.emacs文件里。</div>
<div>&nbsp;</div>
<div>不过就算你尝试让emacs正确的格式化代码失败了，也并不意味着你失去了一切：还可以用&ldquo;</div>
<div>indent&rdquo;。</div>
<div>&nbsp;</div>
<div>不过，GNU indent也有和GNU emacs一样有问题的设定，所以你需要给它一些命令选项。不</div>
<div>过，这还不算太糟糕，因为就算是GNU indent的作者也认同K&amp;R的权威性（GNU的人并不是坏</div>
<div>人，他们只是在这个问题上被严重的误导了），所以你只要给indent指定选项&ldquo;-kr -i8&rdquo;</div>
<div>（代表&ldquo;K&amp;R，8个字符缩进&rdquo;），或者使用&ldquo;scripts/Lindent&rdquo;，这样就可以以最时髦的方式</div>
<div>缩进源代码。</div>
<div>&nbsp;</div>
<div>&ldquo;indent&rdquo;有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册页。不过</div>
<div>记住：&ldquo;indent&rdquo;不能修正坏的编程习惯。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十章：Kconfig配置文件</div>
<div>&nbsp;</div>
<div>对于遍布源码树的所有Kconfig*配置文件来说，它们缩进方式与C代码相比有所不同。紧挨</div>
<div>在&ldquo;config&rdquo;定义下面的行缩进一个制表符，帮助信息则再多缩进2个空格。比如：</div>
<div>&nbsp;</div>
<div>config AUDIT</div>
<div>bool "Auditing support"</div>
<div>depends on NET</div>
<div>help</div>
<div>&nbsp;&nbsp;Enable auditing infrastructure that can be used with another</div>
<div>&nbsp;&nbsp;kernel subsystem, such as SELinux (which requires this for</div>
<div>&nbsp;&nbsp;logging of avc messages output). &nbsp;Does not do system-call</div>
<div>&nbsp;&nbsp;auditing without CONFIG_AUDITSYSCALL.</div>
<div>&nbsp;</div>
<div>仍然被认为不够稳定的功能应该被定义为依赖于&ldquo;EXPERIMENTAL&rdquo;：</div>
<div>&nbsp;</div>
<div>config SLUB</div>
<div>depends on EXPERIMENTAL &amp;&amp; !ARCH_USES_SLAB_PAGE_STRUCT</div>
<div>bool "SLUB (Unqueued Allocator)"</div>
<div>...</div>
<div>&nbsp;</div>
<div>而那些危险的功能（比如某些文件系统的写支持）应该在它们的提示字符串里显著的声明这</div>
<div>一点：</div>
<div>&nbsp;</div>
<div>config ADFS_FS_RW</div>
<div>bool "ADFS write support (DANGEROUS)"</div>
<div>depends on ADFS_FS</div>
<div>...</div>
<div>&nbsp;</div>
<div>要查看配置文件的完整文档，请看Documentation/kbuild/kconfig-language.txt。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十一章：数据结构</div>
<div>&nbsp;</div>
<div>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计</div>
<div>数器。内核里没有垃圾收集（并且内核之外的垃圾收集慢且效率低下），这意味着你绝对需</div>
<div>要记录你对这种数据结构的使用情况。</div>
<div>&nbsp;</div>
<div>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构&mdash;&mdash;而不需要担心</div>
<div>这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一</div>
<div>些其他事情而已。</div>
<div>&nbsp;</div>
<div>注意上锁不能取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管</div>
<div>理技巧。通常二者都需要，不要把两个搞混了。</div>
<div>&nbsp;</div>
<div>很多数据结构实际上有2级引用计数，它们通常有不同&ldquo;类&rdquo;的用户。子类计数器统计子类用</div>
<div>户的数量，每当子类计数器减至零时，全局计数器减一。</div>
<div>&nbsp;</div>
<div>这种&ldquo;多级引用计数&rdquo;的例子可以在内存管理（&ldquo;struct mm_struct&rdquo;：mm_users和mm_count）</div>
<div>和文件系统（&ldquo;struct super_block&rdquo;：s_count和s_active）中找到。</div>
<div>&nbsp;</div>
<div>记住：如果另一个执行线索可以找到你的数据结构，但是这个数据结构没有引用计数器，这</div>
<div>里几乎肯定是一个bug。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十二章：宏，枚举和RTL</div>
<div>&nbsp;</div>
<div>用于定义常量的宏的名字及枚举里的标签需要大写。</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">#define</span> CONSTANT 0x12345</pre>
</div>
<p>&nbsp;</p>
</div>
<div>在定义几个相关的常量时，最好用枚举。</div>
<div>&nbsp;</div>
<div>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</div>
<div>&nbsp;</div>
<div>一般的，如果能写成内联函数就不要写成像函数的宏。</div>
<div>&nbsp;</div>
<div>含有多个语句的宏应该被包含在一个do-while代码块里：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">#define</span> macrofun(a, b, c) \
<span style="color: #008080;">2</span> <span style="color: #0000ff;">do</span><span style="color: #000000;"> {\
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">5</span><span style="color: #000000;">)\
</span><span style="color: #008080;">4</span> <span style="color: #000000;">        do_this(b, c);\
</span><span style="color: #008080;">5</span> } <span style="color: #0000ff;">while</span> (<span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">6</span>  </pre>
</div>
</div>
<div>使用宏的时候应避免的事情：</div>
<div>&nbsp;</div>
<div>1) 影响控制流程的宏：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">#define</span> FOO(x)\
<span style="color: #008080;">2</span> <span style="color: #0000ff;">do</span><span style="color: #000000;"> {\
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">if</span> (blah(x) &lt; <span style="color: #800080;">0</span><span style="color: #000000;">)\
</span><span style="color: #008080;">4</span>         <span style="color: #0000ff;">return</span> -<span style="color: #000000;">EBUGGERED;\
</span><span style="color: #008080;">5</span> } <span style="color: #0000ff;">while</span>(<span style="color: #800080;">0</span>)</pre>
</div>
</div>
<div>非常不好。它看起来像一个函数，不过却能导致&ldquo;调用&rdquo;它的函数退出；不要打乱读者大脑里</div>
<div>的语法分析器。</div>
<div>&nbsp;</div>
<div>2) 依赖于一个固定名字的本地变量的宏：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">#define</span> FOO(val) bar(index, val)</pre>
</div>
</div>
<div>&nbsp;</div>
<div>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来</div>
<div>不相关的改动带来错误。</div>
<div>&nbsp;</div>
<div>3) 作为左值的带参数的宏： FOO(x) = y；如果有人把FOO变成一个内联函数的话，这种用</div>
<div>法就会出错了。</div>
<div>&nbsp;</div>
<div>4) 忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数的</div>
<div>宏也要注意此类问题。</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">#define</span> CONSTANT 0x4000
<span style="color: #0000ff;">#define</span> CONSTEXP (CONSTANT | 3)</pre>
</div>
</div>
<div>&nbsp;</div>
<div>cpp手册对宏的讲解很详细。Gcc internals手册也详细讲解了RTL（译注：register</div>
<div>transfer language），内核里的汇编语言经常用到它。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十三章：打印内核消息</div>
<div>&nbsp;</div>
<div>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。不要</div>
<div>用不规范的单词比如&ldquo;dont&rdquo;，而要用&ldquo;do not&rdquo;或者&ldquo;don't&rdquo;。保证这些信息简单、明了、无</div>
<div>歧义。</div>
<div>&nbsp;</div>
<div>内核信息不必以句号（译注：英文句号，即点）结束。</div>
<div>&nbsp;</div>
<div>在小括号里打印数字(%d)没有任何价值，应该避免这样做。</div>
<div>&nbsp;</div>
<div>&lt;linux/device.h&gt;里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的</div>
<div>设备和驱动，并且被标记了正确的消息级别。这些宏有：dev_err(), dev_warn(),</div>
<div>dev_info()等等。对于那些不和某个特定设备相关连的信息，&lt;linux/kernel.h&gt;定义了</div>
<div>pr_debug()和pr_info()。</div>
<div>&nbsp;</div>
<div>写出好的调试信息可以是一个很大的挑战；当你写出来之后，这些信息在远程除错的时候</div>
<div>就会成为极大的帮助。当DEBUG符号没有被定义的时候，这些信息不应该被编译进内核里</div>
<div>（也就是说，默认地，它们不应该被包含在内）。如果你使用dev_dbg()或者pr_debug()，</div>
<div>就能自动达到这个效果。很多子系统拥有Kconfig选项来启用-DDEBUG。还有一个相关的惯例</div>
<div>是使用VERBOSE_DEBUG来添加dev_vdbg()消息到那些已经由DEBUG启用的消息之上。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十四章：分配内存</div>
<div>&nbsp;</div>
<div>内核提供了下面的一般用途的内存分配函数：kmalloc()，kzalloc()，kcalloc()和</div>
<div>vmalloc()。请参考API文档以获取有关它们的详细信息。</div>
<div>&nbsp;</div>
<div>传递结构体大小的首选形式是这样的：</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> p = kmalloc(<span style="color: #0000ff;">sizeof</span>(*p), ...);</pre>
</div>
</div>
<div>&nbsp;</div>
<div>另外一种传递方式中，sizeof的操作数是结构体的名字，这样会降低可读性，并且可能会引</div>
<div>入bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的sizeof的结果不变。</div>
<div>&nbsp;</div>
<div>强制转换一个void指针返回值是多余的。C语言本身保证了从void指针到其他任何指针类型</div>
<div>的转换是没有问题的。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十五章：内联弊病</div>
<div>&nbsp;</div>
<div>有一个常见的误解是内联函数是gcc提供的可以让代码运行更快的一个选项。虽然使用内联</div>
<div>函数有时候是恰当的（比如作为一种替代宏的方式，请看第十二章），不过很多情况下不是</div>
<div>这样。inline关键字的过度使用会使内核变大，从而使整个系统运行速度变慢。因为大内核</div>
<div>会占用更多的指令高速缓存（译注：一级缓存通常是指令缓存和数据缓存分开的）而且会导</div>
<div>致pagecache的可用内存减少。想象一下，一次pagecache未命中就会导致一次磁盘寻址，将</div>
<div>耗时5毫秒。5毫秒的时间内CPU能执行很多很多指令。</div>
<div>&nbsp;</div>
<div>一个基本的原则是如果一个函数有3行以上，就不要把它变成内联函数。这个原则的一个例</div>
<div>外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能</div>
<div>优化掉你的函数的大部分代码，那仍然可以给它加上inline关键字。kmalloc()内联函数就</div>
<div>是一个很好的例子。</div>
<div>&nbsp;</div>
<div>人们经常主张给static的而且只用了一次的函数加上inline，如此不会有任何损失，因为没</div>
<div>有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加inline gcc</div>
<div>也可以自动使其内联。而且其他用户可能会要求移除inline，由此而来的争论会抵消inline</div>
<div>自身的潜在价值，得不偿失。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十六章：函数返回值及命名</div>
<div>&nbsp;</div>
<div>函数可以返回很多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样</div>
<div>的一个值可以表示为一个错误代码整数（-Exxx＝失败，0＝成功）或者一个&ldquo;成功&rdquo;布尔值（</div>
<div>0＝失败，非0＝成功）。</div>
<div>&nbsp;</div>
<div>混合使用这两种表达方式是难于发现的bug的来源。如果C语言本身严格区分整形和布尔型变</div>
<div>量，那么编译器就能够帮我们发现这些错误&hellip;&hellip;不过C语言不区分。为了避免产生这种bug，请</div>
<div>遵循下面的惯例：</div>
<div>&nbsp;</div>
<div>如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代码整</div>
<div>数。如果是一个判断，那么函数应该返回一个&ldquo;成功&rdquo;布尔值。</div>
<div>&nbsp;</div>
<div>比如，&ldquo;add work&rdquo;是一个命令，所以add_work()函数在成功时返回0，在失败时返回-EBUSY。</div>
<div>类似的，因为&ldquo;PCI device present&rdquo;是一个判断，所以pci_dev_present()函数在成功找到</div>
<div>一个匹配的设备时应该返回1，如果找不到时应该返回0。</div>
<div>&nbsp;</div>
<div>所有导出（译注：EXPORT）的函数都必须遵守这个惯例，所有的公共函数也都应该如此。私</div>
<div>有（static）函数不需要如此，但是我们也推荐这样做。</div>
<div>&nbsp;</div>
<div>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的，他们</div>
<div>通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数，他们使用</div>
<div>NULL或者ERR_PTR机制来报告错误。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十七章：不要重新发明内核宏</div>
<div>&nbsp;</div>
<div>头文件include/linux/kernel.h包含了一些宏，你应该使用它们，而不要自己写一些它们的</div>
<div>变种。比如，如果你需要计算一个数组的长度，使用这个宏</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">#define</span> ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</pre>
</div>
</div>
<div>类似的，如果你要计算某结构体成员的大小，使用</div>
<div>&nbsp;</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">#define</span> FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</pre>
</div>
</div>
<div>还有可以做严格的类型检查的min()和max()宏，如果你需要可以使用它们。你可以自己看看</div>
<div>那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里</div>
<div>自己重新定义。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>第十八章：编辑器模式行和其他需要罗嗦的事情</div>
<div>&nbsp;</div>
<div>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs</div>
<div>能够解释被标记成这样的行：</div>
<div>&nbsp;</div>
<div>-*- mode: c -*-</div>
<div>&nbsp;</div>
<div>或者这样的：</div>
<div>&nbsp;</div>
<div>/*</div>
<div>Local Variables:</div>
<div>compile-command: "gcc -DMAGIC_DEBUG_FLAG foo.c"</div>
<div>End:</div>
<div>*/</div>
<div>&nbsp;</div>
<div>Vim能够解释这样的标记：</div>
<div>&nbsp;</div>
<div>/* vim:set sw=8 noet */</div>
<div>&nbsp;</div>
<div>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应</div>
<div>该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模</div>
<div>式，或者使用其他可以产生正确的缩进的巧妙方法。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>附录 I：参考</div>
<div>&nbsp;</div>
<div>The C Programming Language, 第二版, 作者Brian W. Kernighan和Denni</div>
<div>M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮),</div>
<div>0-13-110370-9 (硬皮). URL: http://cm.bell-labs.com/cm/cs/cbook/</div>
<div>&nbsp;</div>
<div>The Practice of Programming 作者Brian W. Kernighan和Rob Pike. &nbsp;Addison-Wesley,</div>
<div>Inc., 1999. &nbsp;ISBN 0-201-61586-X. &nbsp;URL: http://cm.bell-labs.com/cm/cs/tpop/</div>
<div>&nbsp;</div>
<div>cpp，gcc，gcc internals和indent的GNU手册&mdash;&mdash;和K&amp;R及本文相符合的部分，全部可以在</div>
<div>http://www.gnu.org/manual/找到</div>
<div>&nbsp;</div>
<div>WG14是C语言的国际标准化工作组，URL: http://www.open-std.org/JTC1/SC22/WG14/</div>
<div>&nbsp;</div>
<div>Kernel CodingStyle，作者greg@kroah.com发表于OLS 2002：</div>
<div>http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</div>
<div>&nbsp;</div>
<div>--</div>
<div>最后更新于2007年7月13日。</div>]]></description></item><item><title>Linux KVM代码之美</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/07/2714115.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sun, 07 Oct 2012 07:35:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/07/2714115.html</guid><description><![CDATA[<div class="Section0">
<p>&nbsp;<strong>edited as an essey for <em>程序语言设计原理</em></strong></p>
<hr />
<p><em>&nbsp;</em></p>
<p>在程序的编写上，我认为编程的难度，也就是可写性是一个次要的角色，而代码的可读性，可维护性一直软件生命周期中的主要部分，尤其是对于大型项目而言，软件的维护绝对是项目管理人员首先要考虑的问题，成本的控制，人月量的降低。在这一点上更为突出表现的我想应该是对于开源项目来说，人员的流动性大，项目时间的不确定性，还有对开发人员的吸引力。开源项目应该关注的不止是软件功能性的强大，思维理念的超前，更应该是代码的可读性，可维护性。毕竟没有人愿意在垃圾场上重新盖一栋漂亮的大楼。所以开源项目应该从一开始就在可读性，可维护性上下工夫，并且需要有一些自己的理念，开发标准在里面，这样可以引导后来的开发人员遵循这些原则，保证代码的可读性，可维护性，避免出现破窗效应。</p>
<p class="p16">那么如此看来，代码之美又应该包括哪些方面呢，我想应该需要有程序的可读性，可维护性，另外还需要有一些设计准则。这里就以<span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">内核中的</span><span style="font-family: 'Times New Roman';">KVM</span><span style="font-family: 宋体;">代码部分为例，谈谈这些原则。</span></p>
<p class="p16">&nbsp;</p>
<h2>一、可读性、可维护性</h2>
<p class="p0">在<span style="font-family: 'Times New Roman';">Github</span><span style="font-family: 宋体;">上打开</span><span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">内核代码，涉及</span><span style="font-family: 'Times New Roman';">KVM</span><span style="font-family: 宋体;">的主要有两个目录，</span><span style="font-family: 'Times New Roman';">virt</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">arch/x86/kvm</span><span style="font-family: 宋体;">，我们主要研究的是</span><span style="font-family: 'Times New Roman';">arch/x86/kvm</span><span style="font-family: 宋体;">。文件夹下的</span><span style="font-family: 'Times New Roman';">Makefile</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">Kconfig</span><span style="font-family: 宋体;">文件可以将程序的脉络显得极为的清晰。</span></p>
<p class="p0">现在查看的是<span style="font-family: 'Times New Roman';">emulate.c</span><span style="font-family: 宋体;">文件，程序大概有</span><span style="font-family: 'Times New Roman';">4000</span><span style="font-family: 宋体;">多行，这也是</span><span style="font-family: 'Times New Roman';">C</span><span style="font-family: 宋体;">语言代码中值得诟病的地方，因为程序代码超过</span><span style="font-family: 'Times New Roman';">2</span><span style="font-family: 宋体;">页屏幕大小后，会影响人们对程序的理解，难于找到需要注意的地方，并且纠结于大量的方法和结构体之间。</span></p>
<p class="p16">emulate.c<span style="font-family: 宋体;">的文件头注释表明只是一个</span><span style="font-family: 'Times New Roman';">X86</span><span style="font-family: 宋体;">架构（</span><span style="font-family: 'Times New Roman';">32</span><span style="font-family: 宋体;">位或者</span><span style="font-family: 'Times New Roman';">64</span><span style="font-family: 宋体;">位）指令的译码器和模拟器，并且表明程序的作者，来源，程序具体涉及的方面。代码是遵循</span><span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">编码规范的。</span></p>
<p class="p0">包括<span style="font-family: 'Times New Roman';">8</span><span style="font-family: 宋体;">个字符缩进，把长的行和字符串打散，大括号和空格的放置，命名规范等。在</span><span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">内核中</span><span style="font-family: 'Times New Roman';">Documentation/CodingStyle</span><span style="font-family: 宋体;">文件中有句话表明这些规范的用处</span><span style="font-family: 'Times New Roman';">&ldquo;</span><span style="font-family: 宋体;">代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性</span><span style="font-family: 'Times New Roman';">&rdquo;</span><span style="font-family: 宋体;">，无需特别的编辑器，只需要一个普通的文本编辑器就可以了。这些规范十分有利于读者理解和修改代码，例如不超过</span><span style="font-family: 'Times New Roman';">80</span><span style="font-family: 宋体;">列的代码长度使得函数体中的形式参数不会显得拥挤不堪，分不清个数。如图</span><span style="font-family: 'Times New Roman';">1</span><span style="font-family: 宋体;">中这样的例子在这</span><span style="font-family: 'Times New Roman';">4000</span><span style="font-family: 宋体;">行代码中俯拾皆是，极大的提高了可读性。</span></p>
<center>
<p class="p17"><img style="vertical-align: middle;" title="图1" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/1.png" alt="" width="418" height="87" /></p>
<p>图1</p>
</center>
<p class="p17">可能是得益于C<span style="font-family: 宋体;">语言设计的简单性和正交性，我在</span><span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">代码中很少看到有</span><span style="font-family: 'Times New Roman';">3</span><span style="font-family: 宋体;">层以上的嵌套，代码的逻辑大多数可以在最多</span><span style="font-family: 'Times New Roman';">2</span><span style="font-family: 宋体;">层的嵌套中完成。并且程序的控制语句可以将代码的逻辑部分清晰的展现出来，无需过多的升入理解。另外，程序中的注释部分所占的比例也不会很大，不会出现注释数量比代码数量还要多的情况，并且注释部分十分的简短精细。这表明对程序片段的理解无需额外的添加注释，只是凭借代码的逻辑结构和命名就可以很好的理解代码，而且注释的语言不会显得赘述，只是简单扼要的解释片段功能或逻辑。例如图</span><span style="font-family: 'Times New Roman';">2</span><span style="font-family: 宋体;">中的情形，复杂的位操作尽管提高了效率，可是难以理解，这时就需要注释来帮助解释。</span></p>
<p class="p16" style="text-align: center;">&nbsp;<img title="图2" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/2.png" alt="" width="458" height="39" /></p>
<p class="p17" style="text-align: center;">图&nbsp;2</p>
<p class="p16">可读性在很多的时候是与可维护性相关联的，程序写出来很大一部分原因就是为了维护，而强可读性对于程序的理解至关重要，特别是人员流动性强的时候，而语言的特性和优秀的代码规范是可读性的保证，<span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">内核代码在这两方面都做得非常好，拥有</span><span style="font-family: 'Times New Roman';">Documentation/CodingStyle</span><span style="font-family: 宋体;">这样的编程规范，还有</span><span style="font-family: 'Times New Roman';">C</span><span style="font-family: 宋体;">语言这样的高级程序设计语言。从另一方面来说，可读性强也同时意味着可写性强，因为在编写程序的过程中，编程人员需要不断地阅读已经编写的程序部分。</span></p>
<p class="p0">&nbsp;</p>
<h2>二、设计准则</h2>
<p class="p0">&nbsp;</p>
<h3>1.&nbsp;频度准则</h3>
<p class="p0">越常用越简单，包括命名，和函数体。例如在模拟器的缓存表写入时有两个函数体，一个reg_write，另外一个为writeback_registers。表示的意思一个为写入，另外一个是回写，这个是对应于<span style="font-family: 'Times New Roman';">Cache</span><span style="font-family: 宋体;">的不同存取机制的，显然第一个较为常用，所以在命名上面会比第二个简略一些。</span></p>
<p class="p0">而对于更为常用的函数来说，例如一些简单的位运算，<span style="font-family: 'Times New Roman';">kvm</span><span style="font-family: 宋体;">将这些函数当做预编译的部分，放在函数开头。如下图</span><span style="font-family: 'Times New Roman';">3</span><span style="font-family: 宋体;">，就表示一个栈的指令移动，在代码中频繁的出现则用预编译函数来表示。并且有一些函数使用了内联的方法来提高性能，这些函数往往是另外一个复杂或者多次使用的函数的一部分，所以内联的函数函数体都比较简单，拥有一个描述性的名字，并且作用通常是作为辅助函数。</span></p>
<p class="p0" style="text-align: center;">&nbsp;<img title="图3" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/3.png" alt="" width="474" height="15" /></p>
<p class="p17" style="text-align: center;">图&nbsp;3</p>
<p class="p0">&nbsp;</p>
<h3>2.&nbsp;结构一致</h3>
<p class="p16">结构一致表示的是程序结构和计算的逻辑结构一致。<span style="font-family: 'Times New Roman';">Kvm</span><span style="font-family: 宋体;">代码可以体现出自顶向下、逐步求精的思想，复杂问题，往往有一个总体的引导性函数，然后会由一些子函数，辅助函数来作为过渡，逐步细化地解决问题。上文提到的一些预编译函数，内联函数就是起到这样的作用的。</span></p>
<p class="p0">并且在程序中使用了大量的条件语句，循环语句，返回语句，可以很容易的把握程序结构和计算的逻辑结构的一致性。另外不得不提的一点是，<span style="font-family: 'Times New Roman';">kvm</span><span style="font-family: 宋体;">代码中并没有摒弃</span><span style="font-family: 'Times New Roman';">goto</span><span style="font-family: 宋体;">语句的使用，一开始基于老师们和专家们的建议</span><span style="font-family: 'Times New Roman';">&ldquo;</span><span style="font-family: 宋体;">不要使用</span><span style="font-family: 'Times New Roman';">goto</span><span style="font-family: 宋体;">语句</span><span style="font-family: 'Times New Roman';">&rdquo;</span><span style="font-family: 宋体;">，我对这些代码有着很大的反感，但是仔细阅读后发现使用</span><span style="font-family: 'Times New Roman';">GOTO</span><span style="font-family: 宋体;">语句，会使程序流程更清楚、效率更高。</span></p>
<p class="p16">例如图<span style="font-family: 'Times New Roman';">4</span><span style="font-family: 宋体;">中，代码清晰的表示了获取操作数后处理器将要做得事情，程序的结构和计算逻辑是一致的，并不存在什么晦涩难懂的部分。</span></p>
<p class="p0" style="text-align: center;">&nbsp;<img title="图4" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/4.png" alt="" width="554" height="358" /></p>
<p class="p17" style="text-align: center;">图&nbsp;4</p>
<h3>3.&nbsp;局部性</h3>
<p class="p0">C<span style="font-family: 宋体;">语言是不鼓励使用全局变量的。在</span><span style="font-family: 'Times New Roman';">emulator.c</span><span style="font-family: 宋体;">的代码中我也并未有发现全局变量的使用。代码规范里头对全局变量的描述是</span><span style="font-family: 'Times New Roman';">&ldquo;</span><span style="font-family: 宋体;">只有当你真正需要它们的时候再用它</span><span style="font-family: 'Times New Roman';">&rdquo;</span><span style="font-family: 宋体;">。并且对于局部变量的使用它是有标准的：</span><span style="font-family: 'Times New Roman';">&ldquo;</span><span style="font-family: 宋体;">函数的另外一个衡量标准是本地变量的数量。此数量不应超过</span><span style="font-family: 'Times New Roman';">5</span><span style="font-family: 宋体;">－</span><span style="font-family: 'Times New Roman';">10</span><span style="font-family: 宋体;">个，否则你的函数就有问题了</span><span style="font-family: 'Times New Roman';">&rdquo;</span><span style="font-family: 宋体;">。</span></p>
<p class="p16">kvm<span style="font-family: 宋体;">代码中函数的局部变量都很少，并且命名十分的简洁，一般为</span><span style="font-family: 'Times New Roman';">2-3</span><span style="font-family: 宋体;">个字母，是放在一块儿申明的。声明完后空一行，开始函数的逻辑部分。</span></p>
<h3>4.&nbsp;词法内聚</h3>
<p class="p16">词法内聚是变量在使用处就近声明。这一点要看使用处的定义，因为<span style="font-family: 'Times New Roman';">kvm</span><span style="font-family: 宋体;">中变量的声明是放在一块的，对于函数来说，是在使用处定义。但如果把使用处定义为使用变量的具体位置，表达式或判断赋值语句，那么</span><span style="font-family: 'Times New Roman';">kvm</span><span style="font-family: 宋体;">代码中的变量声明就不是词法内聚了。</span></p>
<h2>三、总结</h2>
<p class="p0">总的来说<span style="font-family: 'Times New Roman';">Linux</span><span style="font-family: 宋体;">内核代码所带来的标准已经影响了很多从业人员，并且正在成为</span><span style="font-family: 'Times New Roman';">C</span><span style="font-family: 宋体;">语言代码的标准规范。这个规范是从</span><span style="font-family: 'Times New Roman';">Brian&nbsp;Kernighan</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">Dennis&nbsp;Ritchie</span><span style="font-family: 宋体;">开始的，也就是著名的经典</span><span style="font-family: 'Times New Roman';">C</span><span style="font-family: 宋体;">，并且经历了</span><span style="font-family: 'Times New Roman';">C90</span><span style="font-family: 宋体;">、</span><span style="font-family: 'Times New Roman';">C99</span><span style="font-family: 宋体;">标准，根据不同的需求在变化着，修改着。我所看到的这个</span><span style="font-family: 'Times New Roman';">CodingStyle</span><span style="font-family: 宋体;">是在两天前&nbsp;</span><span style="font-family: 'Times New Roman';">Joe&nbsp;Perches</span><span style="font-family: 宋体;">提交的，添加了网络块的评论规范。</span></p>
<p class="p16">但是这些修改变化，有一个共同的目标就是使<span style="font-family: 'Times New Roman';">linux</span><span style="font-family: 宋体;">内核代码能够看起来更加的舒适，理解起来更容易，并最终做到可写性和维护性。</span></p>
<p class="p0">&nbsp;</p>
<p class="p0">&nbsp;</p>
<p class="p16">&nbsp;</p>
</div>]]></description></item><item><title>最小生成树</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/06/2713392.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sat, 06 Oct 2012 14:21:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/06/2713392.html</guid><description><![CDATA[<p>算法使用的是二叉堆，时间为O(ElgV)。如果V小于E的话，使用Prim更好。</p>
<p>Kruskal算法：</p>
<p>O(ElgE): E&lt;V<sup>2&nbsp;</sup>,所以有 lgE=O(lgV)</p>
<p>集合A是一个森林，加入集合A中的安全边总是图中连接两个不同连通分支的最小权边。</p>
<p>使用不相交集合数据结构。</p>
<p>测试边时，即测试两端点是否在同一棵树上。</p>
<p>若不在则可以对集合进行合并。</p>
<p>&nbsp;</p>
<p>Prim算法：</p>
<p>集合A形成单棵树，添加集合A的安全边总是连接树与一个不在树中的顶点的最小权边。</p>
<p>使用最小优先队列。优先队列基于Key值，key[v]是所有将v与树中某一顶点相连的边中的最小权值。</p>
<p>一开始除了根节点，其他节点的key为无穷大。</p>]]></description></item><item><title>几个linux命令</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/06/2713248.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sat, 06 Oct 2012 10:52:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/06/2713248.html</guid><description><![CDATA[<p>转换文件到pdf unoconv -f pdf mydocument.odt<br />zip乱码解压   unzip -O CP936 xx.zip<br />mp3 乱码 mid3iconv -e gbk *.mp3 //当前目录下的mp3文件<br />视频转码 mencoder  *.rmvb -o output.avi -oac mp3lame -lameopts cbr:br=32 -ovc x264 -x264encopts bitrate=440 -vf scale=320:-3</p>
<p>linux 声音调节 &nbsp;<span>alsamixer</span></p>
<p>gedit 乱码：</p>
<pre>gsettings set org.gnome.gedit.preferences.encodings auto-detected "['UTF-8','CURRENT','GB18030','ISO-8859-15','UTF-16']"</pre>
<p><span>SSH 远程登录： &nbsp; ssh -l root 192.168.0.150</span></p>
<p>vim 中文乱码：</p>
<p><span>let &amp;termencoding=&amp;encoding</span><br /><span>set fileencodings=utf-8,gbk</span></p>]]></description></item><item><title>时间管理</title><link>http://www.cnblogs.com/billowkiller/archive/2012/10/06/2713245.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Sat, 06 Oct 2012 10:47:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/10/06/2713245.html</guid><description><![CDATA[<p>最近，特别是十一这段期间，忽然发现我的时间是相当的不够用，作业什么的有一大堆等着我去处理，而且是在将要结束十一，提交作业的时间。为此我还推掉了几个聚会，在学校里赶作业，没敢出去玩。</p>
<p>深究原因，应该是有太多的任务被我压下来，平时乱晃着忙着自己的杂事，缺少时间利用的紧迫感。等到截止日期的时候在统统一块儿赶着做，这样作业质量不高，自己也不痛快。回想本科时候就是这样，和牛人的差距也就在这里。怀进鹏校长在实验室开会的时候说过一句话，论文不是三天写出来的，而是三个月写出来的，意思是不应该是三个月在准备而三天之内把所有的东西赶出来，应该是三个月一点一点的递近，慢慢的把论文一点一点的赶出来。</p>
<p>之前我是不相信时间安排，任务管理这回事，因为我是个执行效率并不高的人，经常会忘了或者不愿意做某些事情。但是这些东西却又是必须要做的，不然任务的统筹很难完成，就是所有事情都凑在一块了，无法很好的完成。规划要做好，回想考研的时候，我确实有安排自己的任务，把时间分段，如果未能完成任务，则第二天或之后会要求补上，而且时间分段安排也有一定的宏观层面，例如三天的时间安排，而不过多的考虑细枝末节。但是现在我考虑的层面确实有些不够了，自是关注于长尾时间，忽略了最重要的大部分时间。</p>
<p>总结一下：</p>
<ul>
<li>任务平均化</li>
<li>时间统筹规划</li>
</ul>
<p>祭此文，引此为戒！</p>]]></description></item><item><title>《暗时间》总结</title><link>http://www.cnblogs.com/billowkiller/archive/2012/09/27/2705992.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Thu, 27 Sep 2012 09:11:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/09/27/2705992.html</guid><description><![CDATA[<p class="western"><br />
</p>
<p class="western">
<span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">获得的多少并</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">不取决于读了多少</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，而取决于</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">思考了多少、多深</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span><span style="font-size: small;"><br /></span><br />
</p>
<p class="western">
<span style="font-family: 'WenQuanYi Micro Hei';"><span lang="zh-CN">学习一个小领域的时候，时时把&ldquo;<span style="color: #215968;">最终能够写出一篇漂亮的
</span></span></span><span style="font-family: 'WenQuanYi Micro Hei';"><span style="color: #215968;">Survey</span>&rdquo;</span><span style="font-family: 'WenQuanYi Micro Hei';"><span lang="zh-CN">放在大脑中提醒自己。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">对付我们强大的习惯的最佳办法是将自己认为正确的（不管是自己经过困难或失败
而领悟的，还是看到书上或听到别人说的）</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">写下来，并常常拿出来翻看</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。事实上，我的经验是，在写下来的时候我们的大脑会进入到理性分析模块，进一步检验和推理那些道理，
我们越是对一个道理审视的详细、深入、全面，大脑中留下的印象深刻，从记忆加工的角度来说，这叫</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">深度加工</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，带来的结果就是该记忆与更多的提取线索相关联，于是便能够在更多的场景下被唤起（而不是被以往的习惯直接覆盖
）。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">事实上，很多成功者自己的总结都不靠谱，就是因为他们自己也难以对自己成功的原因进行正确的归因，比如我们都有这样一种倾向：将失败归因于外界因素，将成功归因于自己的能耐。（心理学把这个称为</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">自我服务偏差</span></span><span style="font-family: 'WenQuanYi Micro Hei';">）。</span></span><span style="font-size: small;"><br /></span><br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">GTD</span></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">的原理：通过提供不断的进展，让执行者意识到事情正在朝向完成不断迈进，这种正面趋势所带来的积极情感能够进一步激励个体把事情执行到底。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">真正的理由有时候往往隐藏在意识触及不到的地方，由我们的</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">情绪大脑</span></span><span style="font-family: 'WenQuanYi Micro Hei';">所掌控，当它引导我们的情绪大脑作出决定之后，才发个红头文件通知我们的</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">理性大脑</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，我们的理性大脑于是便迅速而果断地给出各种听上去很合理的解释，让我们的决定和行为看上去无懈可击。对于理智上希望从事的事情，在你强大的情绪大脑面前，你的理性大脑只能屈服，但你又不能让自己处于天人交战的纠结状态，所以你的</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">理性大脑便用各种理由来搪塞自己</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">只要一件事情尚存在对自己有利的解释，我们的大脑便会毫不犹豫地掩耳盗铃地认为那就是唯一的解释。这只是一种解释（可能），未必是唯一的解释（可能）。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">只要一种解释是对自己有利的，我们便不想去推敲和反驳，再漏洞百出的事情看上去也不无可能，而且只要一种解释是有可能的，我们就认定其一定是的，强大的情绪大脑会阻止理性大脑去往深入了想。而对于对自己不利的解释，我们或者忽略，或者则会异常仔细去推敲，抓住一个漏洞则相信已完全推翻了该解
释。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">习惯之所以难以改变，就是因为习惯是自我巩固的，越用越强，越强越用。要想从既有习惯中跳出来，必然要依赖于外界的力量&mdash;&mdash;对于心理机制的知识。仅仅是知道一些</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">常见的行为陷阱和心理弱点</span></span><span style="font-family: 'WenQuanYi Micro Hei';">的存在便已经可以帮我们避免很多的决策失误。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">而如果能够进一步理解这些陷阱和弱点的深层原因，则更可能说服自己做正确的事情。能够</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">改变既有的习惯</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">依靠的不是自制力</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">而是知识</span></span><span style="font-family: 'WenQuanYi Micro Hei';">
。单纯的自制是一件非常痛苦的事情，你理智上知道应该怎么做，但是你的情绪大脑却就是不买账，一些比较坚定的人能够不管三七二十一就强迫自己去做正确的事情，这殊为不易，不是像我这样的一般人能够做到的。但是，无论任何人，都有一个共同的倾向，就是去做正确的事情，不去做错误的事情。很多时候我们无法自制是因为情绪大脑并不知道也并不承认这件事情是错误的。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-family: 'WenQuanYi Micro Hei';"><span lang="zh-CN"><span style="color: #215968;">客观</span>是承认<span style="color: #215968;">未知信息的可能性</span>，<span style="color: #215968;">理性</span>意味着能够从<span style="color: #215968;">对立面的视角</span>去看问题和思考客</span></span><span style="font-family: 'WenQuanYi Micro Hei';">.</span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">善于利用</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">思维时间</span></span><span style="font-family: 'WenQuanYi Micro Hei';">的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说&ldquo;心理年龄&rdquo;这个词，思考得多的人，往往心理年龄更大。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span lang="zh-CN"><span style="color: #215968;"><span style="font-size: small;">大脑
</span></span></span><span style="color: #215968;"><span style="font-size: small;">=
CPU</span></span><span lang="zh-CN"><span style="font-size: small;">时间利用效率</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">你可以&ldquo;投入&rdquo;很多时间在一件事情上面，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。你走路的时候吃饭的时候，做梦的时候心心念念想的就是这件事情，你的
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">CPU
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">总是分配给它，这个时候你的思维时间就被利用到了极致，你投入的时间就真正等于了实际流逝的时间，因为你的
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">CPU </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">是满载的。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span lang="zh-CN"><span style="font-size: small;">投入的时间
</span></span><span style="font-size: small;">!= </span><span lang="zh-CN"><span style="font-size: small;">领悟
</span></span><span style="font-size: small;">&amp; </span><span lang="zh-CN"><span style="font-size: small;">思维时间
  </span></span><span style="font-size: small;">----&gt;
</span><span lang="zh-CN"><span style="color: #215968;"><span style="font-size: small;">推理时间</span></span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的&ldquo;暗时间&rdquo;，</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span lang="zh-CN"><span style="color: #215968;"><span style="font-size: small;">减少任务切换</span></span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">相比之下，如果只做一件任务，就不会有此损失。这就是为什么专注的人比不专注的人时间利用效率高得多的原因。任务切换的暗时间看似非常不明显，甚至很多人认为&ldquo;多任务&rdquo;是件很好的事情（有时候的确是），但日积月累起来就会发现，消耗在切换上的时间越来越多。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">另外，大脑开始一件任务的时候必须要有一定时间来&ldquo;热身&rdquo;。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">要充分利用暗时间，不仅要能够迅速进入状态，另一个很重要的习惯就是能够保持状态多久
（思维体力）。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">能够</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">迅速进入专注状态</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，以及能够</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">长期保持专注状态</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，是高效学习的两个最重要习惯。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">只有具备超强的</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">抗干扰能力</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法</span></span><span style="font-family: 'WenQuanYi Micro Hei';">:D
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">在不知其所以然的情况下，算法只是一堆离散的机械步骤，缺少</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">背后的思想的支撑</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，这些步骤之间就没有一个本质层面上的关联（先知亚里士多德早就指出：</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">学习即联接</span></span><span style="font-family: 'WenQuanYi Micro Hei';">）。所以就跟背历史书也没多大区别。然而，
知道了算法是怎样一步步被推导出来
的，我们就一下拥有了大量的记</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">忆提取线索</span></span><span style="font-family: 'WenQuanYi Micro Hei';">：对算法发现过程中的任何一个关键步骤（尤其是本质）的回忆都可能使我们能够自己动手推导出剩余的内容</span></span><span style="font-family: 'WenQuanYi Micro Hei';">.</span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">算法设计的主要任务本来就是通过问题条件中蕴含的知识来&ldquo;</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">消除冗余计算</span></span><span style="font-family: 'WenQuanYi Micro Hei';">&rdquo;和&ldquo;</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">避免不必要计算</span></span><span style="font-family: 'WenQuanYi Micro Hei';">&rdquo;</span></span><span style="font-family: 'WenQuanYi Micro Hei';">.</span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">思想所处的</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">抽象层面</span></span><span style="font-family: 'WenQuanYi Micro Hei';">往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，
涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">算法诞生过程中的思路往往包含了比实际算法更本质得多的知识，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">本质的理解</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">记录</span></span><span style="font-family: 'WenQuanYi Micro Hei';">只是学习和思考的副作用，只要还在学习和思考，就必然会有新的记录。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">看定理必看证明</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。一个你不明白其证明的定理在我看来比不知道这个定理还要糟糕，因它给你造成一种懂了的错觉。在没有明白背后的证明之前，任何一个定理对你来说都是等价的&mdash;&mdash;等价于背乘法口诀</span></span><span style="font-family: 'WenQuanYi Micro Hei';">...</span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">看到美妙的证明和解法总是会去一遍又一遍的去反复揣摩，试图理解想出这个证明的人到底是怎么想出来的，有没有什么一般性的方法可循，很多时候，在这样揣摩的过程中，你会理解到更深刻的东西，对问题性质更深刻的认识，对解决问题的思路更深刻的认识</span></span><span style="font-family: 'WenQuanYi Micro Hei';">.</span></p>
<p class="western" align="CENTER">&nbsp;</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">算法的解法则比精妙的数学证明稍加更容易逆向工程一点。只要你有耐心仔细地去琢磨算法的关键步骤和本质，总能从中窥探到一些更
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">general
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">的思想和思路来。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">此外，很多经典问题，算法书上的讲法虽然时时令我们失望，但如果去网上一搜，则通常会发现更优秀的解释来。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">简单地说，如果你对于每个问题都能真正弄清以下这几个问题的答案，那么可以肯定的是，
你的理解，记忆，以及学习的效率都会得到质的提高：</span></span><span style="font-size: small;"><br /></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">&bull;
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">为什么这种解法是对的？</span></span></span><span style="font-size: small;"><br /></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">&bull;
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">为什么那种解法是错的？</span></span></span><span style="font-size: small;"><br /></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">&bull;
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">为什么这种解法不是最优的？</span></span></span><span style="font-size: small;"><br /></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">&bull;
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">证明为什么没有更优的解法。</span></span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">相信以下的知识技能组合是具有相当程度的不可替代性的
：</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">1
</span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">专业领域技能</span></span><span style="font-family: 'WenQuanYi Micro Hei';">：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">2
</span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">跨领域的技能</span></span><span style="font-family: 'WenQuanYi Micro Hei';">：解决问题的能力，创新思维，判断与决策能力，</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Critical-Thinking</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">，
表达沟通能力，</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Open
Mind </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">等等。</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">3
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">学习能力：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">持续学习</span></span><span style="font-family: 'WenQuanYi Micro Hei';">和</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">思考新知识</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">4
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">性格要素：严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Keep
an open mind</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">）等等。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">在开始书写你的想法之前，我知道很多人不书写的原因是因为觉得没有什么可写的，其实这是一个怪圈，你越是不开始书写，总是拿有限的思维缓存去默想一个问题，就越是没有内容可以写，如果你逼着自己将一些不成熟的想法写下来，看着自己写的内容，</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">试着进一步拓展它们</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，就有可能在理性的道路上走得很远，很远。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">用博客的形式来记录下你</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">有价值的思考</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，会带来很多好处，却没有任何明显的坏处。</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Note</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">：碎碎念不算思考、心情琐记不算思考、唠唠叨叨也不算思考、没话找话也不算思考，请以此类推。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">我自己则是非常珍惜类似这样的机会，即当&ldquo;我强烈地觉得它是对的，但我却说不出所以然
来&rdquo;，这时候往往是到大脑中翻箱倒柜的时候，弄清来龙去脉的时候，深入反思的时候
，纠正一直以来错误的潜在前提假设的时候。另一方面，&ldquo;我强烈地觉得这个说法有问题，但我却说不清它为什么有问题，到底哪有问题&rdquo;，这也是一个极有意义的瞬间，它几乎总是意味着你对一个问题的认识有潜在的偏差，肯定是在你自己都没有觉知到的地方引入了一个潜在的假设、偷换了一个重要的概念，等等。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能，而不是任它们在幕后阴险地左右你的思维。很多时候我们的思路出了问题并不是我们不会反思，
而是不知道自己的</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">思维中有那些隐含的假设</span></span><span style="font-family: 'WenQuanYi Micro Hei';">（</span></span><span style="font-family: 'WenQuanYi Micro Hei';">assumptions</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">），如果你只感觉到答案，却不知道你大脑得到这个答案之前做了哪些推理，你又怎么知道哪一环可能出了问题呢
？</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">发言分为</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">前提</span></span><span style="color: #000000;"><span style="font-family: 'WenQuanYi Micro Hei';">、</span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">假设</span></span><span style="color: #000000;"><span style="font-family: 'WenQuanYi Micro Hei';">、</span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">逻辑</span></span><span style="color: #000000;"><span style="font-family: 'WenQuanYi Micro Hei';">、</span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">结论</span></span><span style="font-family: 'WenQuanYi Micro Hei';">这四个部分，</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">去教一个完全不懂的人，则是一种最最强大和彻底的反思途径。这就迫使你对你所掌握的、或之前认为正确的那些东西作彻彻底底的、深刻的反思，你的受众越是不懂，
你需要反思得就越深刻。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">对小熊说话～</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">当思考和总结成为习惯之后，
诉诸文字以及借助书写来进一步思考就变成了一件自然而然的事情，就变成了一件
&ldquo;因为你在</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">思考和总结从而必须书写下来</span></span><span style="font-family: 'WenQuanYi Micro Hei';">&rdquo;的事情，博客就变成了副产品。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">意志力很大程度上来源于有正确的方法，而非天生
。</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">1)
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">担心别人认为没有价值。事实是，你面临过的问题总会有人面临过，你独立思考了，别人没有，你的文章对他们就会有价值。当然，肯定会对某些人没有价值，他们早就知道了，
但就算你再厉害，也总是有人比你厉害的，不能说因为这些原因就不记录你自己的想法了，
你自己思考了之后理解得最深刻，就算有别人想过了，总有人没有想到的。况且，思考成了习惯，你的思考能力也会越来越强，你的文章也会越来越有价值。重复，无论你面临什么困
惑，总会有很多人同样面临过，于是你苦苦思索之后的结果，肯定会对很多人有意义。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">或者，你想通了之后觉得其实也很简单于是不愿意或者不好意思写了，但要知道，问题在想通了之后总是简单的，问题的困难程度不在于想通了之后还觉得有多难，而在于从你觉得它难到你觉得它简单需要耗费多少思维体力
，你耗费的时间越长，说明有越多的人最终还是没有想明白（路越长走到底的人越少）。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">最后，虽然我现在看一年前的文章觉得挺不成熟，但是如果没有那些不成熟的思考，也不会有现在更成熟的思考，我几年后来看现在写的东西，还是会觉得不成熟。</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">2)
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">担心想法太幼稚或有漏洞等等被别人笑话。人非圣贤。况且，只会批判乃至嘲笑别人的人是最不知道怎么建设的人，忽略他们。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">无论如何，不用急于求成，</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">在一个主题上深入下去思考</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，总能挖到别人挖不到的角落。你能让一个问题在大脑中停留的时间越长，就越是能够发现新的东西，一般来说，我认为有价值的问题我会让他在意识或潜意识中待短则一个星期，长则一个月（视问题大小而定），利用
走路吃饭的时间琢磨。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">有一个很不错的概念叫做&ldquo;</span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">Unknown
Unknown</span></span><span style="font-family: 'WenQuanYi Micro Hei';">&rdquo;</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">，大意是如果你不知道一个东西的话，你也不
会知道你自己不知道它。很多时候新知识就有这个特性&mdash;&mdash;掌握了之后觉得很明白，掌握之前却觉得&ldquo;不可能啊&rdquo;、&ldquo;这简直没有解嘛&rdquo;。在这样的认知之下，你自然会高估前方的困难、
风险和不确定性，因为你不知道什么样的知识才能解决你的困惑。然而事实上呢？只要智商没有根本的差别，别人的大脑能够掌握的知识，你的大脑也能掌握，你所感觉到的巨大困难只不过是因为
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Unknown
Unknown</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">，你所需要的只是耐心地踏遍这块知识版图，当你掌握了那些你该掌握的知识之后自然会柳暗花明。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">在思考一个问题的时候，最容易犯的一类错误就是</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">忘了考虑某种可能性</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，不管这种可能性是另一种做法（譬如只顾着构造一个能一步得出结果的算法，没记得还可以从错误情况逼近。譬如只顾着正着推导，却忘了可以反过来推。只顾着反过来推，居然忘了可以考察简单特例。试了各种手法，却发现忘了考虑题目的某个条件。觉得试遍了所有可能性，已经走不下去了，然后其实在思维的早些时候就已经落入了思维陷阱。等等）事实上，即便是一个熟练的解题者也容易犯顾此失彼的问题，因为我们一旦意识到一个看似能够得到结论的解法，整个注意力就容易被吸引过去，而由于推导的路径是很长的，所以很容易在一条路上走到黑，试图再往下走一步就得出解。却忘了回过头来看看再更高的层面上还有没有其它手法，思路上有没有其他可能性。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">为了避免这样的错误，一个有效的办法就是将自己的思考过程（中的重要环节）清晰的写在纸上（称为&ldquo;</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">看得见的思考</span></span><span style="font-family: 'WenQuanYi Micro Hei';">&rdquo;），</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">本质上，</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">练习</span></span><span style="font-family: 'WenQuanYi Micro Hei';">并不产生新能力。然而练习最重要的一个作用就是将</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">外显记忆转化为内隐记忆</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">解题练习的最重要目的不是将特定的题目解出来，而是在于反思解题过程中的一般性的，跨问题的思维法则。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">&bull;
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">心中有锤，就容易为其奴役：在遇到问题的时候不是具体问题具体分析，而是屁股决定脑袋，不管三七二十一先上黄金大锤再说，而且往往还颇有成就感，却将自己真正原本要解决的问题抛在脑后了。始终莫要忘记提醒自己，&ldquo;</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">问题是什么？</span></span><span style="font-family: 'WenQuanYi Micro Hei';">&rdquo;
</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">&bull;
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">但毫无疑问，没有锤子是万万不行的，没有谁会傻到徒手钉钉。重点是选择合适你的工具。这又要求在学习工具的时候始终别忘记它的适用范围。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">我们在学习工具的时候由于投入很多的时间，往往在情绪上面对工具产生了太强的感情，我们既投入了时间，当然内心希望能够用上这些工具，所以就容易忘掉其适用前提，欣欣然地不管三七二十一就把黄
金大锤亮出来，以显示自己的厉害。但如果我们换一个态度，仅仅将它看作我们工具箱中的又一件工具，就可以客观地评估它，视具体情况而使用了
&mdash;&mdash;始终别忘记自己要解决的问题是什么。</span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">Why
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">永远在
</span></span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">How
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">之前</span></span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">在
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">How
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">层面把事情做好，做成一个精钻的程序员，那顶多就是能把钳子使好，这样的事情很多人都能做到，熟能生巧嘛。换句话说程序员基本上是去解决一个定义好的问题，去实施一个定义好的方案。然而决策问题就不一样了，决策问题是需要去定义问题是什么，以及权衡最佳方
案是什么，不管是决策技术架构还是决策商业策略，都是非常复杂的思维过程，需要综合和权衡大量的信息，这种能力就不是简单楞着头搞下去能练出来的了，很多时候需要抬起头来看，免得只见树木不见森林。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">真正判别弱智与否的并非用什么语言技术，而是</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">做出什么产品满足什么需求</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">一些对于技术型程序员往往没有吸引力的话题其实有着极其重大
的价值&mdash;&mdash;比如什么时候设计，什么时候重构，什么时候集成，再往上一层其实这些又都是次级问题，首要的问题还是这个产品满足什么需求，有什么市场（即这件事情值不值得做），
有一句话想必很多人常听说，如果不知道要做什么，套上十二层架构也无济于事
，</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">方法永远不是因，而是果</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">1.
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">一件事情</span><span style="font-family: 'WenQuanYi Micro Hei';"><strong>
仅仅 </strong></span><span style="font-family: 'WenQuanYi Micro Hei';">让你感觉挺牛不代表这件事情就是值得做的；
</span></span><span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">2.
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">一件事情</span><span style="font-family: 'WenQuanYi Micro Hei';"><strong>
仅仅 </strong></span><span style="font-family: 'WenQuanYi Micro Hei';">让你感到很有兴趣并不代表这件事情就是值得做的。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">兼顾各种成本与收益</span></span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">反问一句，除了</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">情绪价值</span></span><span style="font-family: 'WenQuanYi Micro Hei';">之外，这样的事情在本身的价值上有没有你感觉到的那么牛呢？如
果你只是在削铅笔，那么何必磨一把倚天屠龙剑来？反之，如果你做的是一个本身功能很牛很创新很有价值的软件，那么语言技术其实完全是次要的
，并不是看上去越眩越好，关键是选择各个方面综合考虑起来最合适的工具即可，瑞士军刀也许很丑，但对于丛林冒险很
实用就行。拿着一把屠龙宝刀去野外生存，同样也不靠谱。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">CodingHorror
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">的作者最近在博客里面跟着
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Steve Yegge
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">同学宣称，如果有一件事情是他想教给程序员同学们的，那就是
</span></span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">Marketing</span></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">。无独有偶，有一次吃饭的时候鲍志云同学也提到：
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">Marketing Sense
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">是很重要的。其实也就是不要总想着写牛代码，用牛语言技术，不要落入为技术而技术的怪圈，而是首先</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">想明白做的事情有什么价值，先弄清做什么，为什么做，
再去想怎么做</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，这样后面的功夫才花的有价值。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span style="font-family: 'WenQuanYi Micro Hei';">You
won&rsquo;t&ndash; you cannot&ndash; become a better programmer through sheer
force of programming alone.</span><span style="font-family: 'WenQuanYi Micro Hei';">You can only
complement and enhance your existing programming skills by branching
out.</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">
Learn about your users. Learn about the industry. Learn about your
business</span></span><span style="font-family: 'WenQuanYi Micro Hei';">.</span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">实际上，这种将别人所处的境况通过与自身曾经的经历进行</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">平行的类比</span></span><span style="font-family: 'WenQuanYi Micro Hei';">来学习的方法是一种非常重要的能力，也是真正能够从他人的经验当中学习到东西的一个重要基础。如果不能联系</span></span><span style="font-family: 'WenQuanYi Micro Hei';">/</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">类比到自己曾经相仿的境遇，别人的故事在大脑中的记忆就不够深层，虽然理性上能够理解，也似乎能够记住，但真正类似的事情发生到自己身上的时候就不能回忆起从别人故事中学到的教训了。</span></span><span style="font-size: small;"><br /></span><br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">问一问自己作出退出的决策是否基于足够的信息，我是否进行了足够的调查，至少，是否去简单用了用搜索引擎。
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">模仿高德纳先生的名言：</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">过早退出是一切失败的根源</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">兴趣遍地都是，专注和持之以恒才是真正稀缺的</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">生活中的选择远比我们想象得要多，细微的选择差异造就了不同的人生
。</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">唐雅薇同学的故事中，有这么一个细节吸引了我的注意：当时她正在找工作阶段，对女生在
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">IT
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">行业的发展很迷茫，恰逢微软的郭蓓菁女士到他们学校演讲，演讲完了之后她立即就奔
上讲台拦住郭女士询问女生与 </span></span><span style="font-family: 'WenQuanYi Micro Hei';">IT
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">的问题。
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">这是一个细节，但我相信不是所有人都有勇气上去拦住名人问普通问题的，我们会给自己找
很多很多的理由和接口，我想最常见的应该是两个原因：
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">1. </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">如果被批评了自尊心会受到打
击。</span></span><span style="font-family: 'WenQuanYi Micro Hei';">2.</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">认为问了也问不出特别的信息。然而事实却是相反：</span></span><span style="font-family: 'WenQuanYi Micro Hei';">1.
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">自尊心受到打击算不上实质性
的损失。</span></span><span style="font-family: 'WenQuanYi Micro Hei';">2.
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">你想不出能问出什么特别的信息并不代表就真的问不到重要的信息。
</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">别把不知道当成没有</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">靠专业技能的成功是最具可复制性的</span></span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">它需要的只是你在一个领域坚持不懈地专注下去，只需要选择一个不算太不靠谱的方向，然
后专心致志的专下去，最后必然能成为高手或者绝顶高手。世上有很多成功带有偶然因素和
运气成分或出身环境，但至少这一样，被无数人复制了无数遍，否则就不会存在学校和教育
了。 </span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">反思是让人得以改进自己的最重要的思维品质
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">很多人在成年之后甚至未及成年，性格就难以再发生大的变化。性格是这样一种自我实现和强化的陷阱：如果你是不容易专注的人，你会发现生活中处处都是分散你注意力的东西，你的思维难以在一个事情上停留半小时，于是你的时间变得琐碎，你很难在一个领域有长久的积累和深入的思考，这样的现实可能会让你感到沮丧，后者让你更加无法专心，这样的现实可能会让你感到焦虑，为了避开焦虑你又会去寻求其他的刺激，结果是恶性循环。
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">反思是改变自己的第一步</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，我们常常容易发现别人的问题，别人的错误，却难以发现自己思
维中的问题，因为我们很少会</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">把自己的思维当成目标去思考</span></span><span style="font-family: 'WenQuanYi Micro Hei';">。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上</span><span style="color: #215968;"><span style="font-family: 'WenQuanYi Micro Hei';">推迟决定是最差的决定</span></span><span style="font-family: 'WenQuanYi Micro Hei';">，
在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">如果你有一些钱不知道花在
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">A </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">还是
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">B
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">上，你先不作决定，没问题，因为钱还是你的，但如果你有一些时间，不知道花在
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">A </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">上还是
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">B
</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">上，不行，因为过了这段时间，这段时间就不是你的了。</span></span></p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">为程序员如果没有查过
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">wikipedia</span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">，没有看过几本原版电子书，没有在国内外主要邮件列表里面提过问题吵过架，没有用技术博客记录学习的独特体会，没有订阅技术牛人们的博客，怎么好意思说身在这个行业呢？
</span></span><span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">最后，看完了书还是说&ldquo;说起来容易做起来难&rdquo;的，怪自己，不怪书。</span></span></p>
<p class="western">
<br />
</p>
<p class="western">
<span style="font-size: small;"><br /></span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">学习一门东西的时候常常发现是始于
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">wikipedia </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">中间经过若干次
</span></span><span style="font-family: 'WenQuanYi Micro Hei';">google </span><span lang="zh-CN"><span style="font-family: 'WenQuanYi Micro Hei';">，然后止于某一本或几本著作。</span></span></p>
<p class="western" align="CENTER">
<br />
</p>]]></description></item><item><title>几点改进，听amazon—Solving real industry problems</title><link>http://www.cnblogs.com/billowkiller/archive/2012/09/27/2705900.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Thu, 27 Sep 2012 08:30:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/09/27/2705900.html</guid><description><![CDATA[<p>　　刚听完amazon中国的一个演讲，忽然感觉自己有些方面需要改进和提高，写在这里仅供勉励！</p>
<p>&nbsp;</p>
<ul>
<li>关注于问题本身，不要被周围的其他东西所干扰，减轻自己的功利心;</li>
<li>不要被主讲人的话语思维所引导，要有自己的想法思想在里头，批判性的观察物体本身;</li>
<li>接触业务，中心是算法，模型； 分清主次；</li>
<li>说话方式不要太过尖锐，用商量的语气，端正自己的态度；</li>
<li>不要急躁，深层次挖掘问题，或者是答案；</li>
<li>注意培养自己的思维方式。</li>
<li>不懂问题及时汇总查看。</li>
</ul>]]></description></item><item><title>云——同步思考</title><link>http://www.cnblogs.com/billowkiller/archive/2012/09/04/2671151.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Tue, 04 Sep 2012 15:25:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/09/04/2671151.html</guid><description><![CDATA[<p>顶顶顶</p>]]></description></item><item><title>Hard Disk Partition</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621440.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:59:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621440.html</guid><description><![CDATA[<p><strong><em>edited from&nbsp;</em><a href="http://vbird.dic.ksu.edu.tw/linux_basic/0130designlinux.php#partition_name" target="_blank">vbird</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<em>All picture &copy;&nbsp;<a href="http://vbird.dic.ksu.edu.tw/linux_basic/0130designlinux.php#partition_name" target="_blank">vbird</a></em></strong></p>
<hr size="2" />
<p>在windows中我们可以很容易的发现磁盘盘符C，D，E等，这些盘符到底是什么呢，从磁盘管理器中又可以知道有主分区，逻辑分区，扩展分区等分区，这些东东也就是Partition了，那么他们又是一些什么东西呢，记得以前装windows用时，发现给C盘分配的盘符太小了，想要扩大一些C盘，试了好长时间，才发现要从临近的盘符，也就是D盘划分一部分给C盘，其他盘符都不行，而D盘就是所谓的逻辑分区，这个逻辑分区要先变成扩展分区，然后再又扩展分区转化为主分区，接下来这两个主分区也就是C盘和分割下来的一部分空间也就可以合并了。那么又是为什么这么麻烦呢？这就是接下来要说的了。</p>
<p>在磁盘的第一分区中，装载有MBR(Master Boot Record)，这是可以安装启动管理程序的地方，有446 bytes；还有分割表(partition table)：记录整颗硬盘分割的状态，有64 bytes。MBR是系统在启动的时候会主动去读取的内容，多系统就是靠这块来选择的；分割表就是系统用来确定分区的，也就是分区地址的索引，它将硬盘进行逻辑上的切割，然后用分割表来记录所包含的逻辑地址。</p>
<p><img class="aligncenter" title="分区" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/partition-1.png" alt="" width="455" height="318" /></p>
<p>假设上面的硬盘装置档名为/dev/hda时，那么这四个分割槽在Linux系统中的装置档名如下所示:</p>
<ul>
<li>P1:/dev/hda1</li>
<li>P1:/dev/hda2</li>
<li>P1:/dev/hda3</li>
<li>P1:/dev/hda4</li>
</ul>
<p>由于分割表就只有64 bytes而已，最多只能容纳四笔分割的记录， 这四个分割的记录被称为主要(Primary)或延伸(Extended)分割槽。你的系统程序也就存储在Primary Partition中，那么为什么要进行分割呢？我想是有以下两点好处的：</p>
<ul>
<ul>
<li><strong>数据的安全性</strong></li>
<li><strong>系统的效能考量</strong></li>
</ul>
</ul>
<p>而实际上我们所看到的却往往不止是4个分区，那么这又是为什么呢？这就要透过刚刚谈到的扩展分配(Extended)的方式来处理。扩展分配的想法是： 既然第一个磁区所在的分割表只能记录四笔数据， 那就利用额外的磁区来记录更多的分割。具体的做法如下：</p>
<p><img class="alignnone" title="更多分区" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/partition-2.png" alt="" width="468" height="337" /></p>
<p>在上图当中，我们知道硬盘的四个分割记录区仅使用到两个，P1为主要分割，而P2则为扩展分配。请注意， 扩展分配的目的是使用额外的磁区来记录分割，扩展分配本身并不能被拿来格式化。 然后我们可以透过扩展分配所指向的那个区块继续作分割的记录。</p>
<p>如上图右下方那个区块有继续分割出五个分区， 这五个由扩展分配继续切出来的分割槽，就被称为逻辑分区(logical partition)。 同时注意一下，由於逻辑分区是由扩展分配继续分割出来的，所以他可以使用的磁柱范围就是扩展分配所配置的范围， 也就是图中的101~400。同样文档名应为</p>
<ul>
<ul>
<ul>
<li>P1:/dev/hda1</li>
<li>P2:/dev/hda2</li>
<li>L1:/dev/hda5</li>
<li>L2:/dev/hda6</li>
<li>L3:/dev/hda7</li>
<li>L4:/dev/hda8</li>
<li>L5:/dev/hda9</li>
</ul>
</ul>
</ul>
<p>的装置名称<span>由于前面四个号码都是保留给Primary或Extended，所以逻辑分区</span>号码就由5号开始</p>
<p>下面要提到系统的启动，整个启动流程到操作系统之前的动作应该是</p>
<ol>
<li><strong>BIOS：启动主动运行的韧体，会认识第一个可启动的装置；</strong></li>
<li><strong>MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；</strong></li>
<li><strong>启动管理程序(boot loader)：一支可读取核心文件来运行的软件；</strong></li>
<li><strong>核心文件：开始操作系统的功能...</strong></li>
</ol>
<p>BIOS与MBR都是硬件本身会支持的功能，至于Boot loader则是操作系统安装在MBR上面的一套软件。由于MBR仅有446 bytes而已，因此这个启动管理程序非常小而美。 这个boot loader的主要任务有底下这些项目：</p>
<ul>
<li><strong>提供菜单</strong>：使用者可以选择不同的启动项目，这也是多重启动的重要功能！</li>
<li><strong>加载核心文件</strong>：直接指向可启动的程序区段来开始操作系统；</li>
<li><strong>转交其他loader</strong>：将启动管理功能转交给其他loader负责。</li>
</ul>
<p>这也告诉我们，如果<strong>安装linux时有/boot独立分区时， 务必让该分区在整颗硬盘的最前面部分</strong>，以便加载启动项。以上是单系统的启动模式，那么多系统呢，原来启动管理程序除了可以安装在MBR之外， 还可以安装在每个分割槽的启动磁区(boot sector)。</p>
<p>我们举一个例子来说，假设你的个人计算机只有一个硬盘，里面切成四个分割槽，其中第一、二分割槽分别安装了Windows及Linux， 你要如何在启动的时候选择用Windows还是Linux启动呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的启动管理程序， 那么整个流程可以图示如下：</p>
<p><img class="alignnone" title="双系统启动" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/loader.gif" alt="" width="456" height="299" /></p>
<p><strong>但是如果要安装多重启动， 最好先安装Windows再安装Linux。</strong></p>
<p>这是由于Linux在安装的时候，你可以选择将启动管理程序安装在MBR或各别分区的启动磁区， 而且Linux的loader可以手动配置菜单(就是上图的M1, M2...)，所以你可以在Linux的boot loader里面加入Windows启动的选项；Windows在安装的时候，他的安装程序会主动的覆盖掉MBR以及自己所在分区的启动磁区，你没有选择的机会， 而且他没有让我们自己选择菜单的功能。</p>]]></description></item><item><title>linux下解决中文乱码——文件，标签</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621420.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:45:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621420.html</guid><description><![CDATA[<p>文件是在WIndows 下创建的,Windows 的文件名中文编码默认为GBK,而Linux中默认文件名编码为UTF8,由于编码不一致所以导致了文件名乱码的问题，解决这个问题需要对文件名进行转码。</p>
<ul>
<li><strong>文件与文件夹乱码，使用convmv来解决</strong></li>
</ul>
<p>convmv 使用方法：</p>
<p>convmv -f 源编码 -t 新编码 [选项] 文件名</p>
<p>常用参数：<br />-r 递归处理子文件夹<br />&ndash;notest 真正进行操作，默认情况下是不对文件进行真实操作<br />&ndash;list 显示所有支持的编码<br />&ndash;unescap 可以做一下转义，比如把%20变成空格</p>
<p>举例：</p>
<p>在当前目录下</p>
<pre>convmv -f GBK -t UTF-8 --notest *    //所有文件转gbk为utf8</pre>
<ul>
<li><strong>转换 mp3 标签编码，使用mutagen</strong></li>
</ul>
<p>安装：</p>
<pre>sudo apt-get install python-mutagen</pre>
<p>举例：</p>
<pre>mid3iconv -e gbk *.mp3 //当前目录下的mp3文件</pre>
<pre>find . -iname &ldquo;*.mp3&rdquo; -execdir mid3iconv -e GBK {} \; //所有文件包括子文件夹</pre>
<p>&nbsp;</p>]]></description></item><item><title>linux下添加firefox&amp;chrome插件</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621417.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:43:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621417.html</guid><description><![CDATA[<p><em>NOTE: 所使用的系统为Ubuntu11.10</em></p>
<p>在使用浏览器时发现有提示<em>&rdquo;未安装JRE或JRE版本过低&ldquo;，细想以下，我在前几天刚装有jdk，所以原因应该是安装jdk时默认未设置浏览器与JRE关联，这与在windows中的情况不一样，于是乎查了下firefox的about:plugins，但是找不到安装配置的位置。</em></p>
<p>好在乎在firefox的<a href="http://plugindoc.mozdev.org/">plugin帮助文档</a>中找到解决办法，方法是</p>
<blockquote>
<p><span style="color: #000000;">&nbsp;<span>Make a&nbsp;</span><strong>symbolic link</strong><span>&nbsp;to libjavaplugin_oji.so in your Mozilla Plugins directory. Use the copy located in the plugin/i386/ns7 directory of JRE 5.0 or later, or plugin/i386/ns610-gcc32 if you are using JRE 1.4.2.</span></span></p>
</blockquote>
<p>也就是在命令行中输入：</p>
<p>sudo locate&nbsp;libjavaplugin_oji.so &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//找到javaplugin的位置</p>
<p>ln -s xx/libjavaplugin_oji.so /usr/lib/mozilla/plugins &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//建立<strong>symbolic link</strong>，不能使用cp，或者可能会导致浏览器崩溃</p>
<p>同样chrome也进行如上操作，如果不明白plugin文件夹的位置，可以使用locate命令。</p>]]></description></item><item><title>ubuntu 亮度调节</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621413.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:41:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621413.html</guid><description><![CDATA[<p>1.<br />sudo gedit /etc/X11/xorg.conf 把</p>
<p>Section "Device" 　　　　<br />Identifier "Device0" 　　　　<br />Driver "nvidia" 　　　　<br />VendorName "NVIDIA Corporation" EndSection 改成</p>
<p>Section "Device" 　　　　<br />Identifier "Device0" 　　　　<br />Driver "nvidia" 　　　　<br />VendorName "NVIDIA Corporation" 　　　　<br />Option "RegistryDwords" " EnableBrightnessControl=1"<br />EndSection</p>
<p>然后保存，退出，重启之后，你 就会发现可以调节屏幕背光亮度了</p>
<p>2.<br />网上有很多在Ubuntu Linux下调节笔记本屏幕亮度的方法，有的调的是亮度但不是背光亮度，有的调背光亮度的方法在我的电脑上不好使&hellip;&hellip;找了半天发现这个方法，适用范围应该比较广（起码在我这里好用）。</p>
<p>首先，进入终端，输入lspci命令，列出各种设备的地址</p>
<p>www.linxidc.com@Ubuntu:~$ lspci<br />00:00.0 Host bridge: Intel Corporation Mobile 945GM/PM/GMS, 943/940GML and 945GT Express Memory Controller Hub (rev 03)</p>
<p>00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS, 943/940GML Express Integrated Graphics Controller (rev 03)<br />00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/GME, 943/940GML Express Integrated Graphics Controller (rev 03)<br />00:1b.0 Audio device: Intel Corporation N10/ICH 7 Family High Definition Audio Controller (rev 02)<br />00:1c.0 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 1 (rev 02)<br />00:1c.1 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 2 (rev 02)<br />......<br />发现00:02.0是VGA设备，于是我们修改它的属性</p>
<p>sudo setpci -s 00:02.0 F4.B=FF</p>
<p>解释一下：</p>
<p>setpci是修改设备属性的命令<br />-s表示接下来输入的是设备的地址<br />00:02.0 VGA设备地址（:.）<br />F4 要修改的属性的地址，这里应该表示&ldquo;亮度&rdquo;<br />.B 修改的长度（B应该是字节（Byte），还有W（应该是Word，两个字节）、L（应该是Long，4个字节））<br />=FF 要修改的值（可以改）</p>
<p>我这里00是最暗，FF是最亮，不同的电脑可能不一样。</p>
<p>比如说我嫌FF太闪眼了，我就可以sudo setpci -s 00:02.0 F4.B=CC，就会暗一些</p>]]></description></item><item><title>《鸿门宴》感</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621411.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:40:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621411.html</guid><description><![CDATA[<p>今天看了《鸿门宴》，影像比较深刻，亦有颇多感想</p>
<p>从剧情上看，编剧在历史方面有些删改，而且地方比较大，比较多，对于鸿门宴和刘邦夺取天下以及之后的情况于史记有诸多的不同，譬如鸿门宴中真正的剧情，项庄拔剑已在沛公，樊块吃生肉而得项羽赏识，因项羽优柔寡断和雄视傲物而错杀刘邦，又如刘邦拘而屯漳益，明修栈道暗渡陈仓汇集八路诸侯决胜项羽于吴江，再如萧皇后谋杀韩信，萧何仕优而隐，张良出世而退，樊块成为鸿故肱股之臣。</p>
<p>但这些并不能阻止这部电影为一部好作品，电影的编剧安排十分的恰当合理，增删有度，剧情紧凑，过度自然，以后人拜祭为隐，开始以一无名老者为序，述说这段兵家奇事，刘项二人刺秦未遂，结为兄弟，引发诸侯反秦，其间穿插有虞姬于刘项二人相遇之事，而虞姬于项羽的结合又是一段优美的佳话，韵味深长，并且穿插整部电影，接着提到项羽杯水一张之时刘邦护送虞姬而改道攻占咸阳，于是引出张良于范增的对弈，互相算计，反奸于无形，棉里藏针，两面三刀，鸿门宴上双方互争一子樊块咬一指而张良的先手，奈何范增道行深厚连破4局，但是最后一句范增也看不透，这有是一个巨大的伏笔，无奈之下刘邦奋起力争，项羽也不是盖的，多亏最后韩信赶到得了怀王的赦令刘邦的以复还，但是张良却留在了楚营，于是就出演了一处别样精彩的离间计，范增离开了项羽，于是兵败吴江，自刎变成了项羽的宿命，但是最后范增也给刘邦一出更加精彩的离间计，杀萧何，屠韩信，袭张良，逼得樊块自刎，但最后张良留的一命，于是揭开了开篇神明老人的身份，以范增对张良所说的一席话完美收官。</p>
<p>楚汉争霸是中国古代极佳精彩的对决，剧中将士的屠戮和刀剑的无情，阴谋诡计的斗争无疑都表明这是一部冷血无情的战争片，但是在虞姬与项羽的数次温存的感情戏中无疑为这出戏抹上了一抹红，犹如黑暗中点亮一盏烛，阴冷中带来一片温暖，让人回味无穷，戏中的刘亦菲的演技无疑是这出系的亮点，布满整个银幕的白裙，和数次出现的与世无争的笑颜，舒张人心的话语都涓涓动人，都余音绕梁，三日不绝，真的是很赞啊，亦非演古装美人剧的演技无疑有更上一层楼，从最初《天龙八部》《神雕侠侣》的青涩，到《恋爱通告》的成熟稳健，再到《鸿门宴》的返谱归真，亦非的演技真的已经达到了一个顶端。</p>
<p>再提这部戏的特效无疑也是另外一个亮点，从当年的《赤壁》开始，大场面的制作都有了好莱坞的风范，但其中又融入的中国独有的古典风格，战争和城池的描写绘画都比较唯美，但始终感觉缺少了一个气势，霸气，王者和君临天下的霸气，而且画面的切换又是一个恼人的处理，过度十分的不自然，比例也不协调，但总的来说，还是值得称赞的。</p>
<p>再值得一提的就是这出戏的编剧了，局中有局，谋中有谋。项羽尽失天下而赢得虞姬 ;张良千虑而有一失，最后被范增摆了一道，迫害于刘邦; 刘邦处心积虑狼子野心夺取天下却失信于人，最后谁也不信任，求张良为其收官。这出戏正是道出了飞鸟尽，良弓藏，狡兔死，走狗烹，敌国破、谋臣亡。</p>]]></description></item><item><title>zip 文件乱码解决</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621403.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:37:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621403.html</guid><description><![CDATA[<p>在windows上压缩的文件，是以系统默认编码中文来压缩文件。由于zip文件中没有声明其编码，所以linux上的unzip一般以默认编码解压，中文文件名会出现乱码。</p>
<p>虽然2005年就有人把这报告为bug, 但是info-zip的官方网站没有把自动识别编码列入计划，可能他们不认为这是个问题。Sun对java中存在N年的zip编码问题，采用了同样的处理方式。</p>
<p>1.1 通过unzip行命令解压，指定字符集<br />unzip -O CP936 xxx.zip (用GBK, GB18030也可以)<br />有趣的是unzip的manual中并无这个选项的说明, unzip --help对这个参数有一行简单的说明。</p>
<p>1.2 在环境变量中，指定unzip参数，总是以指定的字符集显示和解压文件<br />解决办法：<br />引用</p>
<pre>[sourcecode language="bash"]<br />vi /etc/environment<br />[/sourcecode]</pre>
<p>再最后加入后面的代码即可<br />UNZIP="-O CP936"<br />ZIPINFO="-O CP936"</p>]]></description></item><item><title>The film-Mona Lisa Smile</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621354.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 04:04:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621354.html</guid><description><![CDATA[<p>看了电影《Mona Lisa Smile》，这是一部小成本电影。整部影片从头到尾没有任何异样的高潮，没有扣人心弦的打斗或者其他对抗场面，同样也没有任何妙手回春的拍摄手法，但是这部两个小时的电影却牢牢牵住了我的心，时光在刹那间浓缩了电影中的那一年。</p>
<p><img class="alignnone" title="The Mona Lisa Smail" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/5485107143.jpg" alt="" /></p>
<p>故事是说一个加利福利亚州的艺术教师来到马萨诸塞州的一所女子高中执教一年的故事。独立，自信和聪慧的Katherine Ann Watson带着50年代未有的自由女权心理来到这所古老封闭，因循守旧的卫斯理女子学院。观念的冲突和陌生的环境并未让Watson退却，故事在Amanda Armstrong因在学生中发避孕套而被辞退后引发了高潮。保守的妇德坚贞，封建思想牢牢在学生和父母教师中占据着统治地位，Watson勇于在与学生，校长董事争论中力图宣传自由改革思想。最终Watson无力与社会学校做斗争，不愿屈服选择离开，但是最后她影响了班上的女学生，改变了她们的思想观念，影响了她们的一生，从我们现在的角度来看无疑是让她们脱离了痛苦选择了一条更为宽敞的道路。<br /><img class="alignnone" title="The Mona Lisa Smail" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/211392045.jpg" alt="" /></p>
<p>影片的剧情一开始显得比较缓慢，但是到了最后有逐渐加快的趋势，因此似乎显得最后思想的转变过程不够具体和充分。总体上来说还是值得肯定的，影片中刻画人物的形象无疑是成功的，让人印象十分的深刻。整部影片的剧情细分来说很有意思，有点佩服导演，里头的冲突矛盾不断，有主角感情线，学生感情线，学生间冲突线，董事与女主的战争与和平，以及学生与女主学术与社会观念的冲突和理解，这些内容非常的有嚼头，但是总感觉影片中还没有深度的挖掘这些材料，有些是浅尝则止，有些是深入不够显得虎头蛇尾。从人物表演的角度来说，这可能是我见过表演的十分细腻的一部影片，细节部分处理的非常之好，表情变化十分的丰富，特别是女主角Watson，她对人物的感情和肢体表情行为表演的实在是到位，让人叹为观止，这也是上述人物刻画成功的一部分原因。</p>
<p>总结来说一部好的电影有以下几点是必不可少的：吸引人，个性鲜明，有行动力的男女主角，当然对我来说女主角是最重要的，呵呵~~；斗争和和平演绎进行的剧情，最好象巴赫的赋格一般纠结绵延；细腻的画面，格调鲜明风格一致的场景，突出主旨衬托感情的背景音乐。这些条件Mona Lisa Smile基本都符合，所以我一看就感觉对它有爱。</p>
<p>最近爱上小成本电影~~~</p>]]></description></item><item><title>Hugo</title><link>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621348.html</link><dc:creator>billowkiller</dc:creator><author>billowkiller</author><pubDate>Fri, 03 Aug 2012 03:59:00 GMT</pubDate><guid>http://www.cnblogs.com/billowkiller/archive/2012/08/03/2621348.html</guid><description><![CDATA[<p>好久没写影评，或者更确切的是观后感了。</p>
<p>呵呵，电影最近是看了蛮多的，一天差不多至少是一部，两个小时吧。喜欢看泰国片，那种小清新的，没有多少压力和内涵，让人放松，给人一种繁忙后的室外桃园。嗯，还有一些日本片，但是日本的这种电影，给人的感觉不像台湾或者泰国那样的悠闲，自在；可能这么说并不是很恰当，但是日本电影它似乎总想把某种思想哲学，对于人生，对于爱情，对于人性的理解加入到其中，看完后会有一些压抑，脑袋里沉浮了一些东西，所以对于日本片来说，我看的并不像泰国片那么频繁。</p>
<p>最近看的是一部叫&lt;恋空&gt;的电影，回想起来，对于其中的剧情和影片想要表述的意思还是可以回味一二，并且有着不小的余音。但那天看完后并没有写一些东西出来，应该是自己的问题，一方面投入的感情并没有想象中的那么多，所以写出来的东西并不会让我很满意；另一方面应该就是太久未能写影评了，看完电影后也不会去深入挖掘，只是偶尔在脑子里溜达一圈也就罢了，想想好笑，也就是前几天才看的电影，忽然又见到其中的主角，而我却叫不出那部影片的名字，惰性思想还是要不得啊！</p>
<p>今天其实也并没有打算写这篇影评的，我已经是关机上床的状态，但是手机在充电，一时半会开不了机，于是就在脑海里想着今天看过的电影。看了两部，今天晚上，第一部是&lt;宿醉&gt;，嗯，纯粹的商业搞笑片，没有太多的感情，属于那种看过就忘的。</p>
<p><img class="aligncenter" title="hugo" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/17285214112051.jpg" alt="" width="300" height="488" /></p>
<p>第二部是&lt;雨果&gt;，它的IMDB是8.2，在床上我就慢慢回忆起影片中的一些信息，那些情节对话，当然是从宏观的角度来想。那时就想着，奇怪啊，这部片子，我越看就觉得不是上8.0的料啊，也就7.6,7.8那个样子，为什么他就能上8.0呢，要想在我眼中，上8.0的片子那都是非常值得一看的，但是对于&lt;雨果&gt;来说，我觉得不看我也不回后悔什么，就是并没有让我觉得非常出色，是其他影片所体现不出的东西。</p>
<p><img class="aligncenter" title="Chloe Grace Moretz" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/00e93901213fb80ed31f827636d12f2eb8389441.jpg" alt="" width="136" height="200" /></p>
<p>心存疑惑，于是就好好的剪辑着这部电影。嗯，首先是演员选择上不错，第一眼见到我就认为是下一个赫敏的科洛&middot;莫瑞兹，初时觉得很熟悉，后来查资料发现是&lt;和莎莫的500天&gt;里那个超级可爱早熟的小女孩。哦，天哪，她才15岁现在，这是一个非常有天赋的演员啊。在电影里头的表演也是非常的到位，特别是面部的表情，呵呵，导演摄像师估计也知道她的这一优点，给了非常多的特写。嗯，还有那个小男孩也不错，额，名字就不查了，因为对我没有太大的吸引力，哈哈。他的表演也非常的到位，但是还是略显青涩啊，动作和表情都有一些不自然，幅度过大。其他演员就不说了，值得一提的是影片中有3个以上的演员是Harry Potter中的。哈哈，有个有是什么意思呢...</p>
<p><img class="aligncenter" title="Chloe Grace Moretz" src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/201112081732267907.jpg" alt="" width="200" height="340" /></p>
<p>然后还有比较出色的地方就是对于画面，cg动画的处理，paris的黎明，黄昏，深夜，一幅幅的图画都非常的经典，而且给人感觉并不像阿凡达中的娇作，嗯，是那种返璞的，柔和的，写实油画的清新。画面中的建筑物多，结构细节繁琐，但整个画面来说却是画风细腻，布局清晰，勾勒得当，写意清明。真实大师风范，是我看过的cg中最精彩的之一，特别是开场的引入，我当时直呼没有到电影院去看3D真是太可惜了。</p>
<p>其他地方对我来说就显得十分的一般，无论是主题，情节的发展还是布局，没多少好点评细说的。但仔细的思考后，&lt;雨果&gt;作为一部商业片来说，在儿童节是上映的娱乐片来说，这部影片的以上优点足以让这部影片利于不败之地，它是成功的。这可能正是它的8.2的缘由。</p>]]></description></item></channel></rss>