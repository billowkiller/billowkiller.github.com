<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2015-11-23T13:28:15+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hadoop Secondary Sorting]]></title>
    <link href="http://billowkiller.github.io/blog/2015/11/22/hadoop-secondary-sorting/"/>
    <updated>2015-11-22T17:27:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/11/22/hadoop-secondary-sorting</id>
    <content type="html"><![CDATA[<p>Hadoop MapReduce的神奇之处发生在mapper和reducer之间，将所有相同key的map输出记录聚集在一块，使得用户可以方便的处理聚合在一起的数据。Hadoop内部使用了partition、sort和merge（shuffle的一部分），在每个reducer中流式地得到排序后的key和value集合。在MapReduce Sorting中有个特别的部分是secondary sort，也就是对value进行排序。</p>

<!--more-->

<p>Secondary sort在两种情况下特别有用：</p>

<ul>
  <li>需要某一部分的数据比其他数据更快的到达reducer。</li>
  <li>希望job的输出按照两个key进行排序。</li>
</ul>

<p>实现Secondary sort需要对MapReduce中的数据流和处理有一定的了解，下图展示了对reducer中出现的数据有影响的三个部分。</p>

<p><img src="http://i5.tietuku.com/7ad3ad872415c4b6.png" width="600px" /></p>

<p><code>partitioner</code>决定哪个reducer接收该mapper数据记录；<code>sorting RawComparator</code>用于在各自的分片中排序输出的结果，map和reduce阶段都有它，其中map阶段的sorting是对reduce阶段sorting的一个优化，让reducer的sorting更高效；最后，<code>grouping RawComparator</code>用于决定reducer处理排序后记录的边界，发生在reducer从本地磁盘读取数据的时候，也就是说，你可以用这个方法决定数据记录是如何聚集起来调用一个reduce方法的。MapReduce默认把这个三个方法作用于map方法输出的key上。</p>

<p>要实现Secondary sorting，我们需要重写partitioner、sort comparator和grouping comparator。</p>

<p>下面，通过对人名的排序来说明如何使用Secondary sorting。使用primary sort排序last name，secondary sort排序first name。</p>

<p>我们需要构建一个由map方法输出的Composite key，这个key由两部分组成：</p>

<ul>
  <li>Natural Key</li>
  <li>Secondary Key</li>
</ul>

<p><img src="http://i5.tietuku.com/25eedf0319e92775.png" width="430px" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="n">WritableComparable</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="kd">private</span> <span class="n">String</span> <span class="n">firstName</span><span class="o">;</span>
</span><span class="line">  <span class="kd">private</span> <span class="n">String</span> <span class="n">lastName</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFields</span><span class="o">(</span><span class="n">DataInput</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">firstName</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">lastName</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">DataOutput</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">    <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="n">firstName</span><span class="o">);</span>
</span><span class="line">    <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="n">lastName</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下图说明hadoop框架配置中用于设置partitioning、sorting和grouping类的名字和方法。</p>

<p><img src="http://i5.tietuku.com/520e7242cd6ecc43.png" width="530px" /></p>

<h3 id="partitioner">Partitioner</h3>

<p>默认的partitioner使用对key进行hash后取reducer个数的模。但是默认的partitioner使用整个key，会导致相同的natural key发往不同的reducer。所以需要实现自己的partitioner。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonNamePartitioner</span> <span class="kd">extends</span>
</span><span class="line">    <span class="n">Partitioner</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getPartition</span><span class="o">(</span><span class="n">Person</span> <span class="n">key</span><span class="o">,</span> <span class="n">Text</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numPartitions</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">*</span> <span class="mi">127</span><span class="o">)</span> <span class="o">%</span>
</span><span class="line">        <span class="n">numPartitions</span><span class="o">;</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="sorting">Sorting</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonComparator</span> <span class="kd">extends</span> <span class="n">WritableComparator</span> <span class="o">{</span>
</span><span class="line">  <span class="kd">protected</span> <span class="nf">PersonComparator</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="kd">super</span><span class="o">(</span><span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">WritableComparable</span> <span class="n">w1</span><span class="o">,</span> <span class="n">WritableComparable</span> <span class="n">w2</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">w1</span><span class="o">;</span>
</span><span class="line">    <span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">w2</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span> <span class="n">cmp</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">());</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="grouping">grouping</h3>

<p>grouping阶段所有的数据记录已经是secondary sort了，grouping comparator需要将相同的last name聚合在一起。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonNameComparator</span> <span class="kd">extends</span> <span class="n">WritableComparator</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="kd">protected</span> <span class="nf">PersonNameComparator</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="kd">super</span><span class="o">(</span><span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">WritableComparable</span> <span class="n">o1</span><span class="o">,</span> <span class="n">WritableComparable</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o1</span><span class="o">;</span>
</span><span class="line">    <span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o2</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="mapreduce">MapReduce</h3>

<p>最后在driver中，需要设置上文提到的三个类：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">job</span><span class="o">.</span><span class="na">setPartitionerClass</span><span class="o">(</span><span class="n">PersonNamePartitioner</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line"><span class="n">job</span><span class="o">.</span><span class="na">setSortComparatorClass</span><span class="o">(</span><span class="n">PersonComparator</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line"><span class="n">job</span><span class="o">.</span><span class="na">setGroupingComparatorClass</span><span class="o">(</span><span class="n">PersonNameComparator</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line">
</span><span class="line"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Map</span> <span class="kd">extends</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Person</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">  <span class="kd">private</span> <span class="n">Person</span> <span class="n">outputKey</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(</span><span class="n">Text</span> <span class="n">lastName</span><span class="o">,</span> <span class="n">Text</span> <span class="n">firstName</span><span class="o">,</span> <span class="n">Context</span> <span class="n">context</span><span class="o">)</span>
</span><span class="line">      <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">    <span class="n">outputKey</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">lastName</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">firstName</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class="line">    <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">outputKey</span><span class="o">,</span> <span class="n">firstName</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Reduce</span> <span class="kd">extends</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="n">Text</span> <span class="n">lastName</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Text</span><span class="o">();</span>
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Person</span> <span class="n">key</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span>
</span><span class="line">                     <span class="n">Context</span> <span class="n">context</span><span class="o">)</span>
</span><span class="line">      <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">    <span class="n">lastName</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class="line">    <span class="k">for</span> <span class="o">(</span><span class="n">Text</span> <span class="n">firstName</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">lastName</span><span class="o">,</span> <span class="n">firstName</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Secondary sort涉及到的自定义的partitioner、sorter和grouper，还是比较复杂的。可以考虑<a href="http://htuple.org">htuple</a>对简单类型进行secondary sort。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark Streaming]]></title>
    <link href="http://billowkiller.github.io/blog/2015/10/27/spark-streaming/"/>
    <updated>2015-10-27T21:04:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/10/27/spark-streaming</id>
    <content type="html"><![CDATA[<p>流式计算通常是为了满足日益增长的数据的实时获取和低延时计算的需求。通常来说，一个优秀的流式计算引擎需要满足一下的一些需求：</p>

<ol>
  <li>不重不丢的保证（在节点或计算失败的时候，内存中的计算状态能被正确的恢复）</li>
  <li>低延迟</li>
  <li>高吞吐量</li>
  <li>强大的计算模型</li>
  <li>容错机制的低开销</li>
  <li>流控</li>
</ol>

<p><img src="http://spark.apache.org/images/spark-logo.png" alt="image" />
<!--more--></p>

<p>介绍完了spark后就可以来说说spark streaming，毕竟spark streaming是完全构建在spark之上，熟悉了spark的RDD原理之后就比较容易理解spark streaming。说白了，spark streaming中的流式计算是伪实时的，之所以是伪实时的是因为它将实时的处理变成时间跨度较小的批量处理。没错，就是将一段时间间隔中的数据变成RDD，然后利用spark原有的架构处理这段时间内的数据，接着在时间维度上对这些处理后的RDD进行迭代计算。也就是将流式计算分解为一系列微小的、原子的批量作业，每个微批量作业如果失败则可以重新计算。这种分解的思想可以应用在批量计算框架、也可以应用在流式计算框架上，例如Storm Trident。</p>

<p>这样的处理带来了几个明显的好处：</p>

<ul>
  <li>高吞吐量</li>
  <li>不从不丢的保证</li>
  <li>快速falut recovery</li>
  <li>更方便处理慢节点</li>
  <li>实时和批量统一的编程接口</li>
</ul>

<p>下面介绍下spark streaming中的具体实现来理解这几点。</p>

<h3 id="section">计算模型</h3>

<p><img src="http://blog.selfup.cn/wp-content/uploads/2014/08/streaming-flow.png" alt="image" /></p>

<p>首先，Spark Streaming把实时输入数据流以时间片（如1秒）为单位切分成块。Spark Streaming会把每块数据作为一个RDD，并使用RDD操作处理每一小块数据。每个块都会生成一个Spark Job处理，最终结果也返回多块。</p>

<p>举个栗子来说明下这个过程：</p>

<pre><code>pageViews = readStream("http://..."， “ls”)
ones = pageViews.map(event =&gt; (event.url, 1))
counts = ones.runningReduce((a, b) =&gt; a+b)
</code></pre>

<p>上述代码的作用是根据URL的数量计算访问次数。处理的过程为首先通过HTTP获取到一个pageview事件的RDD，经过<em>transformation</em>操作变成(URL, 1), 最后的操作计算相同的URL数目。整个streaming过程可以用下图来表示：
<img src="http://img-storage.qiniudn.com/15-10-18/95269436.jpg" alt="" /></p>

<p>整个的处理过程可以看出，输入流被分成每个都是1秒的batch，经过处理后生成resultRDD，这个resultRDD在每个时间间隔中都会产生一个，并经过reduce迭代计算。在上图中最终的reduce的输入参数就包括上一个时间间隔的resultRDD和这个时间间隔中map操作的结果。上图也可以看出这些RDD的lineage graph，在节点失败的时候，可以根据这个lineage graph以partition的粒度为单位重新执行任务计算丢失的分片，可以看出这些计算的任务都是可以并行执行的。同时，对于慢节点来说，因为计算是无状态的，且每个job的结果是可以确定的，spark streaming可以执行类似于hadoop中的预测模型——在其他节点上计算同样的任务。另外，spark streaming也会有些checkpoint来防止无限制的恢复计算。</p>

<p>对比于其他流式处理的方式，spark streaming在处理失败任务和慢节点上无疑更有效率。它可以从时间和partition两个维度上并行地计算数据来加快恢复速度。而对于像Strom的流式处理来说，往往是通过<strong>上游数据backup</strong>或者<strong>同时复制执行相同的作业</strong>来保证数据处理的可靠性。这两种处理方式对于资源的消耗无疑都是巨大的，且恢复的时间也比较长。</p>

<ul>
  <li>其中对于前者来说，每个节点都需要保存上一个checkpoing后所发送数据的拷贝，在节点失败时由standby机器重新计算上游节点发送过来的数据，因为这些计算都是有状态的，所以恢复的时间比较长，Storm就只保证“at least once”语义来提高处理速度。Trident之所以能够保证不重不丢是使用了数据库来复制计算状态。</li>
  <li>对于后者无疑更加消耗资源，并且需要保证两个数据处理操作接受到的上游数据的顺序是一样的。</li>
</ul>

<p>同spark一样，只有当某个Output Operations原语被调用时，stream才会开始真正的计算过程。现阶段支持的Output方式有以下几种：</p>

<ul>
  <li>print()</li>
  <li>foreachRDD(func)</li>
  <li>saveAsObjectFiles(prefix, [suffix])</li>
  <li>saveAsTextFiles(prefix, [suffix])</li>
  <li>saveAsHadoopFiles(prefix, [suffix])</li>
</ul>

<h3 id="section-1">流式处理中的几点难点</h3>

<p>在流式处理中通常都会有几个难点需要考虑。</p>

<ul>
  <li>时间窗口问题</li>
  <li>数据一致性问题</li>
  <li>内存状态管理问题</li>
</ul>

<p>我们来看下spark streaming是如何解决的。</p>

<ol>
  <li>
    <p><strong>时间窗口问题。</strong>spark streaming是根据数据到达系统的时间将记录放到对应的RDD中，这种时间窗口划分是基于墙上时间的，好处可以保证系统及时产生一个新的batch运行job，并且可以让程序运行在数据生成的地方，不必再进行分发。</p>

    <p>这种基于墙上时间的统计有一个非常严重的问题是不能回放数据流。当数据流是实时产生的时候，“墙上时间”的一分钟也就只会有一分钟的event被产生出来。但是如果统计的数据流是基于历史event的，那么一分钟可以产生消费的event数量只受限于数据处理速度。另外event在分布式采集的时候也遇到有快有慢的问题，一分钟内产生的event未必可以在一分钟内精确到达统计端，这样就会因为采集的延迟波动影响统计数据的准确性。所以产生了另外一种时间窗口划分的方法。</p>

    <p>另一种时间窗口划分的方法是基于外部时间的，例如日志时间。spark streaming提供两种方法来处理这种情况：</p>

    <ul>
      <li>延迟处理，等待一定时间来处理每个batch。</li>
      <li>用户的应用程序中保证乱序事件的正确处理。</li>
    </ul>

    <p>以上也说明在批处理的流式计算模型是受限的，很多情况下只能依靠用户的应用程序来做处理，例如实时的统计5s内的pv；其次这种方式也没有很好的流控技术手段，如果有突发的大量数据产生，会导致结果产生的时间更长，甚至是将系统的JVM撑爆。最后实时性也是受限的，只能达到次秒级的处理延迟，毕竟是要等待一个时间batch的处理完成。</p>
  </li>
  <li>
    <p><strong>数据一致性问题。</strong>什么是数据一致性，举个栗子，要统计网站中来自各个国家的page view，把不同国家的pv统计放在不同的节点上处理。但是现在统计英国的节点处理速度要慢于法国的，这将导致两个节点上数据的时间状态不一致。在流式处理中，数据的一致性的保证同时意味着资源的消耗。流式处理的数据一致性有三种解决思路，在上文中也有提到，这里概括下：</p>

    <ul>
      <li>上游备份策略：重启的时候重放kafka的历史数据，恢复内存状态</li>
      <li>中间状态持久化：把统计的状态放到外部的持久的数据库里，不放内存里</li>
      <li>同时跑两份：同时有两个完全一样的统计任务，重启一个，另外一个还能正常运行。</li>
    </ul>

    <p>而在spark streaming中，数据一致性天然得到保证的。因为记录根据时间来分片，所以中间的resultRDD反应的是当前时间和之前时间所计算出来的结果，无论计算和结果被分配到哪个节点上都不会有节点间数据不一致的情况。也就是数据的不重不丢可以得到保证。</p>
  </li>
  <li>
    <p><strong>内存状态管理问题。</strong>
做流式统计的有两种做法：</p>

    <ul>
      <li>依赖于外部存储管理状态：比如没收到一个event，就往redis里发incr增1</li>
      <li>纯内存统计：在内存里设置一个counter，每收到一个event就+1</li>
    </ul>

    <p>第一种会把整个压力全部压到数据库上，造成处理速度下降；第二种的状态相对来说容易管理一些，计算直接是基于这个内存状态做的。如果重启丢失了，重放一段历史数据就可以重建出来。内存的问题是它总是不够用的，解决的方法是input分割和把存储移到外边去。在内存计算中把窗口统计的中间状态落地的好处是显而易见的：重启之后不用通过重算来恢复内存状态。但是这种对外部数据库使用不小心就会导致两个问题：</p>

    <ul>
      <li>处理速度慢。不用一些批量的操作，数据库操作很快就会变成瓶颈</li>
      <li>数据库的状态不一致。内存的状态重启了就丢失了，外部的状态重启之后不丢失。重放数据流就可能导致数据的重复统计</li>
    </ul>

    <p>在spark streaming中支持传统批量计算中的无状态<em>transformation</em>操作，例如<code>map</code>、<code>reduce</code>、<code>groupBy</code>和<code>join</code>。这就避免了普通流式计算中麻烦的状态保存问题。但spark streaming中也支持多个时间间隔中有状态的<em>transformation</em>操作，包括：</p>

    <ol>
      <li>Windowing: 生成滑动窗口RDD。<code>words.window("5s")</code>将产生一个RDD包含[0,5),[1,6),[2,7)的时间间隔。</li>
      <li>增量聚合：在滑动窗口的基础上进行RDD的聚合操作，也就是<code>reduceByWindow</code>。在下图的<em>a</em>中对应的代码为<code>pairs.reduceByWindow("5s", (a, b) =&gt; a+b)</code>，也就是计算5s内的计数之后。图<em>b</em>的代码为<code>pairs.reduceByWindow("5s", (a, b) =&gt; a+b, (a, b) =&gt; a-b)</code>。其实很简单，第一个lambda表达式为进入滑动窗口的处理函数，第二个表达式为离开滑动窗口的处理函数。这样也就不用重复求和了。
 <img src="http://img-storage.qiniudn.com/15-10-18/97873121.jpg" alt="" /></li>
      <li>状态跟踪：
 如下图所示，就是保存上一个时间间隔的RDD与本次的记录进行groupBy加map计算的到状态的变化情况。
 <img src="http://img-storage.qiniudn.com/15-10-18/91458919.jpg" alt="" /></li>
    </ol>

    <p>在对这些带状态的操作的处理过程中也就用到了上述的所属的利用外存在保存中间的状态。spark streaming中这只发生在intervel之间，所以整个内存的状态管理会比传统的流式处理简单许多，而且高效，不需要对每一步都进行状态同步，状态恢复的成本也比较低，上文中提到的可以在多个节点上并行计算恢复。</p>
  </li>
</ol>

<h3 id="system-architecture">System Architecture</h3>
<p><img src="http://img-storage.qiniudn.com/15-10-18/82954556.jpg" alt="" /></p>

<p>Spark streaming和Spark的系统结构有些许改动，如上图所示主要包括3个部分：</p>

<ul>
  <li><em>master</em> that tracks the D-Stream lineage graph and schedules tasks to compute new RDD partitions.</li>
  <li><em>Worker</em> nodes that receive data, store the partitions of input and computed RDDs, and execute tasks.</li>
  <li>A <em>client</em> library used to send data into the system.</li>
</ul>

<p>从上图中可以看出，Spark Streaming和传统的流式系统最大的区别就是Spark Streaming将计算分成小的，无状态的确定性的任务，这些任务会在集群的任意节点上运行。并且相对于传统流式系统的拓扑结构来说，无需消耗大量时间将将任务进行迁移，Spark Streaming可以很好的对机器上的节点进行负载均衡，处理失败任务并且对慢节点进行预测。</p>

<p>对比于Spark的系统，Spark Streaming做了一下的改进：</p>

<ul>
  <li>网络传输。使用异步I/O获取远端数据。</li>
  <li>TimeStep pipelining。Spark的调度器可以在当前任务还未完成的时候可以提交下一个时间分片的任务。</li>
  <li>任务调度：优化任务调度器，例如调整控制消息的大小，可以在每隔几百毫秒时间内启动几百个并行任务。</li>
  <li>存储层：支持异步的RDD checkpoint，RDD是不可变的，所以异步存储不会阻塞现有的计算。</li>
  <li>Lineage切割：控制RDD linage graph的大小，在checkpoint之前的lineage便可以删除。</li>
</ul>

<p>当master fail的时候可以进行HA，所有的worker重新连接到新的master上，将原来的checkpoint和原始数据重新计算。因为所有的操作都是确定性的，所以RDD是可以重复计算，也就是说在HA的时候丢失一些正在运行的计算任务不会对最终结果造成什么影响。所有的元数据都是存储在HDFS上的，包括：</p>

<ol>
  <li>RDD的lineage graph，代表用户代码的Scala函数对象。</li>
  <li>上一个checkpoint的时间</li>
  <li>RDD的ID。因为HDFS的checkpoint文件会在每个时间片重新命名。</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2015/10/27/spark-introduction/"/>
    <updated>2015-10-27T21:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/10/27/spark-introduction</id>
    <content type="html"><![CDATA[<p>简单介绍下Spark。Spark是分布式的内存计算模型，对于两类计算形式能够极大地提升处理的效率：迭代计算，和交互式的数据挖掘工具。迭代计算例如PageRank、K-means聚类、逻辑回归等要求计算结果的重新利用，交互式的数据挖掘例如针对一份的数据集进行多次特定查询也要求原始数据的重复利用。对比于MR作业，它不需要外部存储的介入，从而提升处理速度。接下来将会从Spark的数据模型、编程模型和架构来介绍Spark。</p>

<p><img src="https://spark.apache.org/images/spark-logo.png" alt="image" /></p>

<!--more-->

<h3 id="rdd-data-model">RDD Data Model</h3>
<p>那么如何利用多个节点的内存进行分布式的计算呢，这就是Spark的核心RDD（Resilient Distributed Dataset）。RDD是一个个记录的集合，只读和分片的。它只能通过外部存储或者其他RDD生成。RDD的这些变化操作名称为<em>transformation</em>，在Spark编程中还有另外一个操作需要知道，<em>action</em>，意思是返回一个值或者将数据导出到外部存储，像<code>count</code>、<code>collect</code>、<code>save</code>。一个spark程序往往是从外部存储中定义一个或多个RDD开始的，接着经过各种<em>transformation</em>，最后<em>action</em>。同时<em>action</em>也是计算的开始，在spark中计算是延迟的，各种<em>transformation</em>形成了computation pipeline在<em>action</em>中进行计算。</p>

<p>下表是对RDD中的<em>transformation</em>和<em>action</em>操作：
<img src="http://ww2.sinaimg.cn/large/74311666jw1ex310kinr3j210c0fujwg.jpg" alt="" /></p>

<p>RDD还有两个操作：<em>persistence</em>和<em>partitioning</em>。其实顾名思义，<em>persistence</em>即RDD的持久化操作，这是为了避免重复计算。<em>partitioning</em>是重新分区，为了得到更好的执行并发度。</p>

<p>合理的分区可以有效减少shuffle的数据量，根据特定的应用场景执行不同的<em>partitioning</em>。例如在PageRank中根据域名来对URL进行Hash，因为很多链接都是内部的。下图表示<em>partitioning</em>的效果。</p>

<p><img src="http://img-storage.qiniudn.com/15-10-16/6543188.jpg" alt="" /></p>

<p>持久化操作是也是为了更高的计算效率。例如在下图中，Spark有两个action，所以产生两个job。两个job各自计算RDD1和RDD2，对于数据量大的RDD无疑会影响性能，所以可以将RDD进行<em>persistence</em>操作，可以存入内存、硬盘或者二者结合。后续缓存的资源可以手动清除或者通过LRU算法自动清除。
<img src="http://ww2.sinaimg.cn/large/74311666jw1ex30g3zpazj20u60f2tb9.jpg" alt="" /></p>

<p>在上文中我们提到RDD是有<code>transformation</code>和<code>lazy compute</code>的特性的。这两个特性使得RDD不需要一直被实例化，只需要保存这个RDD是如何产生的，在延迟计算的时候便可以通过这些dependence信息进行RDD transformation操作。以上就是RDD lineage，一个RDD的血统关系图。RDD的只读特性也是为了更好地描述这个lineage graph。在上图中两个Output的产生也可以直观地看到RDD的lineage信息。那么这个linage究竟有什么好处呢，RDD可以根据dependency信息直接追踪到在外存中的数据，在发生错误的时候直接通过外存的原始数据计算丢失或错误的RDD分片信息。</p>

<h3 id="rdd-programming-model">RDD Programming Model</h3>

<p>RDD的编程模型需要通过适当的接口来表示RDD是如何经过一系列的transformations来达到现在的状态。在Spark中，RDD的编程模型暴露了5方面的信息：</p>

<ul>
  <li>dateset中的分片信息</li>
  <li>父RDD的依赖关系</li>
  <li>基于其父RDD的计算RDD方法</li>
  <li>分片的shceme元数据</li>
  <li>数据存放的位置
<img src="http://ww3.sinaimg.cn/large/74311666jw1ex32afwa8gj20qq0ds41v.jpg" alt="" /></li>
</ul>

<p>在第3个方法中，也就是根据父RDD分片计算本RDD的分片有两种情况：每个父RDD分片最多被一个子RDD分片依赖；父RDD分片被多个子RDD分片依赖。这两种情况分别对应<em>narrow dependency</em>和<em>wide dependency</em>。为什么区分这两种依赖关系呢，这和RDD的延迟计算特性有关系。</p>

<ul>
  <li>在<em>narrow dependency</em>中，一个节点上的RDD分片可以通过pipeline的方式从原始数据开始计算，多个分片可以并行的进行。而对于<em>wide dependency</em>需要所有父RDD的分片可用，而且涉及到data shuffle。</li>
  <li><em>narrow dependency</em>在节点失效后的恢复的效率更高，因为可以并行地在不同的节点上计算丢失的分片。而在<em>wide dependency</em>中，一个父RDD分片可能被多个子RDD分片使用，所以可能导致这些子RDD的祖先分片都有丢失，所以需要重新完整的计算。</li>
</ul>

<p>整个spark作业的执行调度也是和这两种dependency有关。当一个用户执行一个<em>action</em>操作的时候，spark的调度器检测RDD的lineage graph，建立一个DAG图来执行，DAG图中的每个节点就是一个<em>stage</em>。在每个<em>stage</em>中包含了多个pipeline的<em>transformation</em>操作，这些RDD的关系全都是
<em>narrow dependency</em>。每个<em>stage</em>的边界都是由<em>wide dependency</em>的shuffle操作，或者已经计算好的分片。调度器这时候就可以建立执行任务计算每个stage中缺失的<em>partitions</em>，直到得到最终的RDD。</p>

<p>那么如何合理划分 stage，并确定 task 的类型和个数？
<img src="http://img-storage.qiniudn.com/15-10-16/48846624.jpg" alt="" /></p>

<p>可以看到在上图中，每个stage中的数据都是形成了pipeline计算的，这里的pipeline思想是：<strong>数据用的时候再算，而且数据是流到要计算的位置的</strong>。有两层意思，一是延迟计算，二是计算本地化。比如在第一个 task 中，从 FlatMappedValuesRDD 中的 partition 向前推算，只计算要用的（依赖的） RDDs 及 partitions。在第二个 task 中，从 CoGroupedRDD 到 FlatMappedValuesRDD 计算过程中，不需要存储中间结果（MappedValuesRDD 中 partition 的全部数据）。</p>

<p>在有<em>wide dependency</em>的时候需要Shuffle后无法进行pipeline。那么我们可以<strong>从后往前推算，遇到 <em>wide dependency</em>就断开，遇到<em>narrow dependency</em>就将其加入该stage。每个stage里面task 的数目由该stage最后一个RDD中的partition个数决定</strong>。因此上图中最后一个stage的id是0，stage 1  stage 2都是stage 0的parents。</p>

<p>整个的computing chain也是根据数据依赖关系自后向前建立，遇到<em>wide dependency</em>后形成 stage。computing chain从后到前建立，而实际计算出的数据从前到后流动，那么RDD内部是如何实现计算的呢。在每个stage中，每个RDD中的compute()调用parentRDD.iter()来将parent RDDs中的 records一个个fetch过来。</p>

<blockquote>
  <p>代码实现：每个 RDD 包含的 getDependency() 负责确立 RDD 的数据依赖，compute() 方法负责接收 parent RDDs 或者 data block 流入的 records，进行计算，然后输出 record。经常可以在 RDD 中看到这样的代码firstParent[T].iterator(split, context).map(f)。firstParent 表示该 RDD 依赖的第一个 parent RDD，iterator() 表示 parentRDD 中的 records 是一个一个流入该 RDD 的，map(f) 表示每流入一个 recod 就对其进行 f(record) 操作，输出 record。为了统一接口，这段 compute() 仍然返回一个 iterator，来迭代 map(f) 输出的 records。</p>
</blockquote>

<p>在实现中，每个task是基于数据的本地性进行分配的，任务是在该分片的节点上执行的。而对于<em>wide dependecy</em>，会在拥有父分片的节点上计算中间结果，这是为了减少fault recovery的时间。</p>

<h3 id="spark-architecture">Spark Architecture</h3>
<p>在上一节中我们确定了Spark stage和task的生成和执行方式，那么这些stage和task在整个spark application中又处于什么样的位置呢，上文中我们提到的每个job又是什么意思呢，为什么一个application中又会有好多个job，它们之间的关系又是什么样的呢？</p>

<p><img src="http://spark-internals.books.yourtion.com/markdown/PNGfigures/deploy.png" alt="image" /></p>

<p>从部署图中可以看到</p>

<ul>
  <li>整个集群分为 Master 节点和 Worker 节点，相当于 Hadoop 的 Master 和 Slave 节点。</li>
  <li>Master 节点上常驻 Master 守护进程，负责管理全部的 Worker 节点。</li>
  <li>Worker 节点上常驻 Worker 守护进程，负责与 Master 节点通信并管理 executors。</li>
  <li>Driver 官方解释是 “The process running the main() function of the application and creating the SparkContext”。Application 就是用户自己写的 Spark 程序（driver program），比如 WordCount.scala。</li>
  <li>每个 Worker 上存在一个或者多个 ExecutorBackend 进程。每个进程包含一个 Executor 对象，该对象持有一个线程池，每个线程可以执行一个 task。</li>
  <li>每个 application 包含一个 driver 和多个 executors，每个 executor 里面运行的 tasks 都属于同一个 application。</li>
</ul>

<p>在最开始的时候我们介绍了RDD的<code>action</code>操作，还提到每个<code>action</code>就是一个job，事实上上表中的<code>action</code>操作其实是论文中的，实际上还有更多的<code>action</code>。如下表：</p>

<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">finalRDD(records) =&gt; result</th>
<th style="text-align:left">compute(results)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">reduce(func)</td>
<td style="text-align:left">(record1, record2) =&gt; result, (result, record i) =&gt; result</td>
<td style="text-align:left">(result1, result 2) =&gt; result, (result, result i) =&gt; result</td>
</tr>
<tr>
<td style="text-align:left">collect()</td>
<td style="text-align:left">Array[records] =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">count()</td>
<td style="text-align:left">count(records) =&gt; result</td>
<td style="text-align:left">sum(result)</td>
</tr>
<tr>
<td style="text-align:left">foreach(f)</td>
<td style="text-align:left">f(records) =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">take(n)</td>
<td style="text-align:left">record (i&lt;=n) =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">first()</td>
<td style="text-align:left">record 1 =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">takeSample()</td>
<td style="text-align:left">selected records =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">takeOrdered(n, [ordering])</td>
<td style="text-align:left">TopN(records) =&gt; result</td>
<td style="text-align:left">TopN(results)</td>
</tr>
<tr>
<td style="text-align:left">saveAsHadoopFile(path)</td>
<td style="text-align:left">records =&gt; write(records)</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">countByKey()</td>
<td style="text-align:left">(K, V) =&gt; Map(K, count(K))</td>
<td style="text-align:left">(Map, Map) =&gt; Map(K, count(K))</td>
</tr>
</tbody>
</table>

<p>用户的 driver 程序中一旦出现 action()，就会生成一个 job，比如 foreach() 会调用sc.runJob(this, (iter: Iterator[T]) =&gt; iter.foreach(f))，向 DAGScheduler 提交 job。如果 driver 程序后面还有 action()，那么其他 action() 也会生成 job 提交。所以，driver 有多少个 action()，就会生成多少个 job。这就是 Spark 称 driver 程序为 application（可能包含多个 job）而不是 job 的原因。</p>

<p>每一个 job 包含 n 个 stage，最后一个 stage 产生 result。。在提交 job 过程中，DAGScheduler 会首先划分 stage，然后先提交无 parent stage 的 stages，并在提交过程中确定该 stage 的 task 个数及类型，并提交具体的 task。无 parent stage 的 stage 提交完后，依赖该 stage 的 stage 才能够提交。从 stage 和 task 的执行角度来讲，一个 stage 的 parent stages 执行完后，该 stage 才能执行。</p>

<p>Spark就先介绍到这里，没有涉及到spark的具体内部实现，包括job的调度，shuffle的过程、文件的管理、cache和broadcast机制等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compression Format Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2015/09/18/compression-format-introduction/"/>
    <updated>2015-09-18T13:34:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/09/18/compression-format-introduction</id>
    <content type="html"><![CDATA[<h1 id="section">压缩格式</h1>
<p>最近在做一个日志的压缩策略，在此就记录下几种不同的压缩算法。本文不涉及每种算法的具体实现，只是用于介绍概念。</p>

<!--more-->

<h2 id="gzip">Gzip</h2>
<p>说到gzip，其实我是不想写的，满满的都是痛苦的回忆啊。在研究生时期曾经写过一个程序，在网关出对用户访问的网页进行hack，在网页的最后加上一个网页跳转的代码。由于网页传输的压缩编码就是gzip，具体做法是获取gzip的头文件后，构造压缩后的数据添加到原始的网页数据上。这里面很有意思的是，gzip是bit-oriented的，所以需要定位去除EOF marker后的数据最后的bit位置，再插入构造好的压缩数据。这里面涉及到的东西比较多，包括对gzip头文件的分析，找到每个单词对应的huffman编码；对压缩数据的反解找到对应的bit位；还有HTTP传输编码替换，所有的编码都改为CHUNKED编码方式。言归正传，那么什么是Gzip压缩编码？</p>

<p>Gzip是基于DEFLATE压缩算法的，它是由LZ77和Huffman编码的组成。LZ77其实很好理解，就是将重复的字符串用数字表示，标记为(length, distance)，相当于建立一个索引，后续出现的数据都可以通过这个索引找到原始的数据。举个简单的例子A A A A A A B A B A A A A A 经过LZ77编码后转化为A A A A A B &lt;2,2&gt; &lt;5,8&gt;, 可以看到A B和A A A A A是重复的，用长度和距离的组合来表示。Huffman编码是一种可变字长编码，依据字符出现概率来构造字符的二进制表示，用于保证了按字符出现概率分配码长，使平均码长最短。</p>

<p>通常我们说的gzip是指gzip文件格式，它的构成如下：</p>

<ul>
  <li>10字节的头，包括magic number，版本号和时间戳</li>
  <li>可选的附加字段，例如源文件名</li>
  <li>正文，也就是经过DEFLATED压缩后的数据</li>
  <li>8字节的EOF marker，包括CRC-32校验和和原始未压缩数据的长度。</li>
</ul>

<p>详细的文件格式如下：</p>

<p><img src="http://img-storage.qiniudn.com/15-9-18/30592957.jpg" alt="" /></p>

<h2 id="lzo">lzo</h2>

<p>lzo令人郁闷的一点是压缩算法是定义好的，但是传输和存储的格式并没有定义好。这就导致不同的厂商在lzo文件压缩格式上有不同的解决方案，在查找lzo资料的时候我就曾见过三种不同的传输或存储格式。那么为什么会有这种情况发生呢，原因就在于lzo lib包中只是定义了压缩的算法，且算法有好几十种。lib包关心的是如何将一串文本转成压缩好的字符串数据，而不关心客户端和服务端是否沟通协调好具体的算法，在传输或存储时候是否会有数据损坏的情况，所以在对lzo压缩进行产品化的时候我们需要考虑这些情况。</p>

<p>在hadoop中，lzo所采用的和<em>lzop</em>相同的压缩格式，lzop是神马呢，官网简介如下：
&gt;lzop is a file compressor which is very similar to gzip. lzop uses the LZO data compression library for compression services, and its main advantages over gzip are much higher compression and decompression speed (at the cost of some compression ratio).</p>

<p>lzop定的的头文件包含的信息如下：</p>

<pre><code>typedef struct {
    unsigned char magic[9]
    uint16_t version;
    uint16_t lib_version;
    uint16_t version_needed_to_extract;
    unsigned char method;
    unsigned char level;                // ignore
    uint32_t flags;                     
    uint32_t filter;                    // filter is not supported
    uint32_t mode;                      // ignore
    uint32_t mtime_low;                 // ignore
    uint32_t mtime_high;                // ignore
    unsigned char filename_len;
    uint32_t checksum;
} header_t;
</code></pre>

<p>在lzop的头文件格式中中还有定义一些extra fields，filename，这些在hadoop的解压算法中就直接给忽略了，所以这里也就没有添加上去，<code>header_t</code>中都是一些必要的占位字段，有些无意义，有些有意义。其中在<code>flags</code>中定义了一些是压缩格式实现的细节，例如压缩前数据的校验和算法，压缩后数据的校验和算法，是否有filter，是否是多文件合并等等。<code>method</code>字段定义了具体的压缩算法，使用的比较多的是M_LZO1X<em>1、M_LZO1X</em>1<em>15、M_LZO1X</em>999. 在官方的lib包中又对各种压缩算法的一个比较，通常情况下使用M_LZO1X_1就足够了。</p>

<p>lzo的压缩是面向块的，所以正文部分也就是由一块一块的压缩块构成，每块的压缩格式如下：</p>

<pre><code>/*
 * uncompressed block size
 * compressed block size
 * uncompressed block checksum
 * compressed block checksum
 * compressed block
 */
</code></pre>

<p>最后写一个EOF marker，也就是4bytes的0.</p>

<h2 id="snappy">snappy</h2>

<p>Google开发的一个 C++ 的用来压缩和解压缩的开发包，旨在提供高速压缩速度和合理的压缩率，Snappy 比 zlib 更快，但文件相对要大 20% 到 100%。Snappy特地为64位x86处理器做了优化，在单个Intel Core i7处理器内核上能够达到至少每秒250MB的压缩速率和每秒500MB的解压速率。Snappy的压缩是属于LZ77 体系，不同于gzip，它是byte-oriented，也就是说数据块之间是有严格的字节区分的；而gzip由于最后加入了Huffman编码，所以它是bit-oriented。byte-oriented的好处是处理起来比较简单，不需要记录字节中的位占用情况和加入数据的位迁移。</p>

<p>Snappy的压缩方式有一个frame的概念，这个帧并不是Snappy压缩所必须的，这个帧其实也就是Snappy的压缩文本加上一些必要的其他信息，例如checksum。Snappy中帧与帧之间是相互独立的，也就是说在压缩过程中你可以不关心其他帧的情况，只需要压缩好自己的数据然后发送或存储，解压的过程中会根据帧的粒度进行解压。这就意味着在分布式的环境中，你可以很容易的合并各个节点上的压缩数据，无需和其他节点进行同步，这个在其他算法中是无法办到的。</p>

<p>Snappy文件只由一个个连续的chunk构成，每个chunk的构成包括：1字节的chunk标识符，3字节的chunk长度，接着就是数据。chunk长度可以为0，这就表示该chunk的数据不存在。Snappy文件的第一个chunk是stream chunk，固定的6字节长度，其中数据部分为”sNaPpY”。这个chunk可以理解为Snappy的头文件，但是这个头文件可以出现多次，这也就是每个Snappy frame可以独立的原因之一；另外一个原因是Snappy并没有EOF marker。其他chunk的类型还包括：</p>

<ul>
  <li>Compressed data</li>
  <li>Uncompressed data</li>
  <li>padding</li>
  <li>Reserved unskippable chunks</li>
  <li>Reserved skippable chunks</li>
</ul>

<h2 id="section-1">对比</h2>
<p>以下是在论文中找到的一些资料。</p>

<p><img src="http://img-storage.qiniudn.com/15-9-17/82781797.jpg" alt="" /></p>

<p><img src="http://ww1.sinaimg.cn/large/74311666jw1ew5aeta9loj20w10hfdi2.jpg" alt="" /></p>

<h2 id="section-2">其他</h2>
<p><a href="https://github.com/billowkiller/Codec">以上三种压缩格式的c++方法</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mapreduce framework]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/mapreduce-framework/"/>
    <updated>2015-07-26T17:23:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/mapreduce-framework</id>
    <content type="html"><![CDATA[<h2 id="mapreduce">MapReduce框架</h2>

<p>mapReduce 的输入是hdfs上存储的一系列文件集。在hadoop中，这些文件被一种定义了如何分割一个文件成分片的input format来分割，一个分片是一个文件基于字节的可以被一个map任务加载的一个块。</p>

<ul>
  <li>每个map任务被分为以下阶段：<code>record reader</code>，<code>mapper</code>，<code>combiner</code>，<code>partitioner</code>。Map任务的输出叫中间数据，包括keys和values，发送到reduce端。</li>
  <li>Reduce任务分为以下阶段：<code>shuffle</code>，<code>sort</code>，<code>reduce</code>，<code>output format</code>。运行map任务的节点会尽量选择数据所在的节点。这种情况下，不会出现网络传输，在本地节点就可以完成计算。</li>
</ul>

<!--more-->

<h3 id="record-reader">Record reader</h3>

<p>Record reader会把根据input fromat生成输入分片翻译成records。Record reader的目的是把数据解析成记录，而不是解析数据本身。它把数据以键值对的形式传递给mapper。通常情况下键是偏移量，值是这条记录的整个字节块。从Input file到map的中间过程如下图所示</p>

<p><img src="http://i12.tietuku.com/691b0fd1648b0497.png" width="450px" /></p>

<p>InputFormat其实做了三件事：</p>

<ul>
  <li>校验job的input configuration（比如，查看数据是否存在）。</li>
  <li>split输入的数据文件为逻辑上分片InputSplit，每个InputSplit给接下来的map task处理。</li>
  <li>创建RecordReader从InputSplit中解析出一个个键值对，这个键值对就是Record。</li>
</ul>

<p>通常在处理文本文件的时候，为了保证记录的完整性，RecorderReader会读取超过InputSplit边界的数据。</p>

<p><img src="http://i5.tietuku.com/392e9f9f99737b4d.jpg" alt="" /></p>

<p>在上图中共有三个InputSplit，在hadoop中默认的InputSplit大小为HDFS中每个Block的大小，所以共产生三个map task，它们读取数据的情况如下：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Start</th>
      <th>Actual Start</th>
      <th>End</th>
      <th>Line(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Mapper1</td>
      <td>B1:0</td>
      <td>B1:0</td>
      <td>B2:150</td>
      <td>L1, L2, L3</td>
    </tr>
    <tr>
      <td>Mapper2</td>
      <td>B2:128</td>
      <td>B2:150</td>
      <td>B3:300</td>
      <td>L4, L5, L6</td>
    </tr>
    <tr>
      <td>Mapper3</td>
      <td>B3:256</td>
      <td>B3:300</td>
      <td>B3:300</td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>

<h3 id="map">Map</h3>

<p>Map阶段，会对每个从record reader处理完的键值对执行用户代码，这些键值对又叫中间键值对。键和值的选择不是任意的，并且对MapReduce job的成功非常重要。键会用来分组，值是reducer端用来分析的数据。这本书会在设计模式方面提供大量的细节去解释键值对的选择。设计模式之间一个主要的区别是键值对的语义。</p>

<h3 id="combiner">Combiner</h3>
<p>Combiner 是一个map阶段分组数据，可选的，局部reducer。它根据用户提供的方法在一个mapper范围内根据中间键去聚合值。例如：数的总和是各个部分数量的和，你可以先计算中间的数目，最后再把所有中间数目加起来。很多情况下，这样能减少数据的网络传输量。发送（hello world，1）三次很显然要比发送（hello world，3）需要更多的网络传输字节量。Combiners可以被广泛的模式替换。很多hadoop开发者忽视combiner，但能获得更好的性能。我们需要指出的是哪一种模式用combiner有好处，哪一种不能用combiner。Combiner不会保证总会执行，所以它是一个整体逻辑。</p>

<h3 id="partitioner">Partitioner</h3>

<p>Partitioner会获取从mapper（或combiner）来的键值对，并分割成分片，每个reducer一个分片。默认用哈希值，典型使用md5sum。然后partitioner根据reduce的个数执行取余运算：key.hashCode() % (number of reducers)。这样能随即均匀的根据key分发数据到reduce，但仍然要保证不同mapper的相同key要到同一个reduce。Partitioner也可以自定义，使用更高级的样式，例如排序。然而，更改partitioner很少用。Partitioner的每个map的数据会写到本地磁盘，并等待对应的reducer检测，拿走数据。</p>

<h3 id="shuffle-and-sort">Shuffle and sort</h3>
<p>Reduce任务开始于shuffle和sort阶段。这一阶段获取partitioner的输出文件，并下载到reduce运行的本地机器。这些分片数据会根据key合并，排序成一个大的数据文件。排序的目的是让相同的key相邻，方便在reduce阶段值得迭代处理。这一阶段不能自定义，由框架自动处理。需要做的只是key的选择和可以自定义个用于分组的比较器。</p>

<h3 id="reduce">Reduce</h3>
<p>Reduce 任务会把分组的数据作为输入并对每个key组执行reduce方法代码。方法会传递key和可以相关的所有值得迭代集合。很多的处理会在这个方法里执行，也就会有很多的模式。一旦reduce方法完成，会发送0或多个键值对到output format。跟map一样，不同的reduce依据不同的逻辑情形而不同。</p>

<h3 id="output-format">Output format</h3>
<p>Output format会把reduce阶段的输出键值对根据record writer写到文件里。默认用tab分割键值对，用换行分割不同行。这里也可以自定义为更丰富的输出格式，最后，数据被写到hdfs。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PID File Analysis]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/pid-file-analysis/"/>
    <updated>2015-07-26T16:57:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/pid-file-analysis</id>
    <content type="html"><![CDATA[<h1 id="pid-">pid 文件浅析</h1>

<p>在Linux系统的目录/var/run下面一般我们都会看到很多的*.pid文件。而且往往新安装的程序在运行后也会在/var/run目录下面产生自己的pid文件。那么这些pid文件有什么作用呢？它的内容又是什么呢？</p>

<!--more-->

<h3 id="pid">pid文件的内容</h3>

<p>pid文件为文本文件，内容只有一行, 记录了该进程的ID。
用cat命令可以看到。</p>

<h3 id="pid-1">pid文件的作用</h3>

<p>防止进程启动多个副本。只有获得pid文件固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。</p>

<h3 id="section">编程技巧</h3>

<p>调用fcntl设置pid文件的锁定F_SETLK状态，其中锁定的标志位F_WRLCK。
如果成功锁定，则写入进程当前PID，进程继续往下执行。
如果锁定不成功，说明已经有同样的进程在运行了，当前进程结束退出。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>pid usage</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
</span><span class="line"><span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="c1">//锁定不成功, 退出......</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">sprintf</span> <span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">pid</span><span class="p">);</span>
</span><span class="line"><span class="n">pidsize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">write</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pidsize</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pidsize</span><span class="p">){</span>
</span><span class="line">    <span class="c1">//写入不成功, 退出......</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">一些注意事项：</h3>

<ol>
  <li>如果进程退出，则该进程加的锁自动失效。</li>
  <li>如果进程关闭了该文件描述符fd， 则加的锁失效。(整个进程运行期间不能关闭此文件描述符)</li>
  <li>锁的状态不会被子进程继承。如果进程关闭则锁失效而不管子进程是否在运行。
 (Locks are associated with processes. A process can only have one kind of lock set for each byte of a given file. When any file descriptor for that file is closed by the process, all of the locks that process holds on that file are released, even if the locks were made using other descripors that remain open. Likewise, locks are released when a process exits, and are not inherited by child processes created using fork.)</li>
</ol>

<h3 id="section-2">其他</h3>

<p><strong>C的fcntl函数：</strong></p>

<pre><code>int fcntl(int fd, int cmd, struct flock *lock);
</code></pre>

<p>参数cmd代表欲垄断的号召</p>

<ul>
  <li>F_DUPFD 复制参数fd的文件描写符，厉行获胜则归来新复制的文件描写符，</li>
  <li>F_GETFD 获得close-on-exec符号，若些符号的FD_CLOEXEC位为0，代表在调用exec()相干函数时文件将不会关闭</li>
  <li>F_SETFD 设置close-on-exec符号，该符号以参数arg的 FD_CLOEXEC位定夺</li>
  <li>F_GETFL 获得open()设置的符号</li>
  <li>F_SETFL 改换open()设置的符号</li>
  <li>F_GETLK 获得文件锁定的事态，依据lock的描写，定夺是否上文件锁</li>
  <li>F_SETLK 设置文件锁定的事态，此刻flcok，构造的l_tpye值定然是F_RDLCK、F_WRLCK或F_UNLCK，
万一无法发生锁定，则归来-1</li>
  <li>F_SETLKW 是F_SETLK的阻塞版本，在无法获得锁时会进去睡眠事态，万一能够获得锁可能捉拿到信号则归来</li>
</ul>

<p>参数lock指针为flock构造指针定义如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>flock structure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">struct</span> <span class="n">flock</span> <span class="p">{</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line">	<span class="kt">short</span> <span class="n">l_type</span><span class="p">;</span>
</span><span class="line">	<span class="kt">short</span> <span class="n">l_whence</span><span class="p">;</span>
</span><span class="line">	<span class="kt">off_t</span> <span class="n">l_start</span><span class="p">;</span> <span class="err">锁定区域的开关位置</span>
</span><span class="line">	<span class="kt">off_t</span> <span class="n">l_len</span><span class="p">;</span> <span class="err">锁定区域的大小</span>
</span><span class="line">	<span class="n">pid_t</span> <span class="n">l_pid</span><span class="p">;</span> <span class="err">锁定动作的历程</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>1_type有三种事态：</p>

<ul>
  <li>F_RDLCK读取锁（分享锁）</li>
  <li>F_WRLCK写入锁（排斥锁）</li>
  <li>F_UNLCK解锁</li>
</ul>

<p>l_whence也有三种措施</p>

<ul>
  <li>SEEK_SET以文件开始为锁定的起始位置</li>
  <li>SEEK_CUR以现在文件读写位置为锁定的起始位置</li>
  <li>SEEK_END以文件尾为锁定的起始位置</li>
</ul>

<p><strong>Python用法:</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>test_fcntl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">signal</span><span class="o">,</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
</span><span class="line">    <span class="n">fcntl</span><span class="o">.</span><span class="n">flock</span><span class="p">(</span><span class="n">pid_file</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_UN</span><span class="p">)</span>
</span><span class="line">    <span class="n">pid_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class="line">    <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">pid_path</span><span class="p">)</span>
</span><span class="line">    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class="line">    <span class="n">pid_path</span> <span class="o">=</span> <span class="s">&#39;test.pid&#39;</span>
</span><span class="line">    <span class="n">pid_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">pid_path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
</span><span class="line">    <span class="n">fcntl</span><span class="o">.</span><span class="n">flock</span><span class="p">(</span><span class="n">pid_file</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_EX</span> <span class="o">|</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_NB</span><span class="p">)</span>
</span><span class="line">    <span class="n">pid_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
</span><span class="line">    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&quot;Hello World&quot;</span>
</span><span class="line">        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Log4j]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/java-log4j/"/>
    <updated>2015-07-26T15:28:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/java-log4j</id>
    <content type="html"><![CDATA[<h2 id="java-log4j-">Java Log4j 使用记录</h2>

<p>Log4j即为Java的日志记录框架，除了Java语言外，它还支持其他的语言接口：C、C++、.Net和PL/SQL。说道日志框架，其他使用较多的日志框架还包括Logback、SLF4J Simple Logging、Java Util Logging，这些日志框架都是大同小异，目的都是用来记录程序运行的状态。它们的区别主要是在用法和性能上，由于日志通常涉及到IO读写磁盘（或者是阻塞或者是异步），这需要耗费时间，假设应用系统的日志比较庞大，对性能要求比较高，那么就需要好好斟酌下使用的框架。这里有个图可以直观感受下几个框架的区别：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/log%20comparision_zpstrg3kc1m.png" alt="image" /></p>

<p>上图中的数字是每秒的日志写入行数，<a href="https://docs.google.com/spreadsheet/ccc?key=0Alceaf46X4GPdHBoLTdYQ29nRDh6V1dRY00zT1FwWWc&amp;usp=sharing">点击更详细的信息</a>。</p>

<!--more-->

<h2 id="hello-word-example">Hello Word Example</h2>

<p>示例是使用maven来组织的。maven用的越多，就越觉得它的方便，不用关心jar包的管理，开发、测试和发布都只需要一行命令，还能还IDE完美的融合。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>pom.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="xml"><span class="line"><span class="nt">&lt;dependency&gt;</span>
</span><span class="line">    <span class="nt">&lt;groupId&gt;</span>log4j<span class="nt">&lt;/groupId&gt;</span>
</span><span class="line">    <span class="nt">&lt;artifactId&gt;</span>log4j<span class="nt">&lt;/artifactId&gt;</span>
</span><span class="line">    <span class="nt">&lt;version&gt;</span>1.2.17<span class="nt">&lt;/version&gt;</span>
</span><span class="line"><span class="nt">&lt;/dependency&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>创建log4j.properties文件，放在resources文件夹下，这个文件夹的路径是src/main/resources。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>log4j.properties</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="properties"><span class="line"><span class="c"># Root logger option</span>
</span><span class="line"><span class="na">log4j.rootLogger</span><span class="o">=</span><span class="s">DEBUG, stdout, file</span>
</span><span class="line">
</span><span class="line"><span class="c"># Redirect log messages to console</span>
</span><span class="line"><span class="na">log4j.appender.stdout</span><span class="o">=</span><span class="s">org.apache.log4j.ConsoleAppender</span>
</span><span class="line"><span class="na">log4j.appender.stdout.Target</span><span class="o">=</span><span class="s">System.out</span>
</span><span class="line"><span class="na">log4j.appender.stdout.layout</span><span class="o">=</span><span class="s">org.apache.log4j.PatternLayout</span>
</span><span class="line"><span class="na">log4j.appender.stdout.layout.ConversionPattern</span><span class="o">=</span><span class="s">%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</span>
</span><span class="line">
</span><span class="line"><span class="c"># Redirect log messages to a log file, support file rolling.</span>
</span><span class="line"><span class="na">log4j.appender.file</span><span class="o">=</span><span class="s">org.apache.log4j.RollingFileAppender</span>
</span><span class="line"><span class="na">log4j.appender.file.File</span><span class="o">=</span><span class="s">C:\\log4j-application.log</span>
</span><span class="line"><span class="na">log4j.appender.file.MaxFileSize</span><span class="o">=</span><span class="s">5MB</span>
</span><span class="line"><span class="na">log4j.appender.file.MaxBackupIndex</span><span class="o">=</span><span class="s">10</span>
</span><span class="line"><span class="na">log4j.appender.file.layout</span><span class="o">=</span><span class="s">org.apache.log4j.PatternLayout</span>
</span><span class="line"><span class="na">log4j.appender.file.layout.ConversionPattern</span><span class="o">=</span><span class="s">%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>说明下ConversionPattern中的符号和参数：</p>

<ol>
  <li><code>%d{yyyy-MM-dd HH:mm:ss}</code> 日期和时间</li>
  <li><code>%-5p</code> 日志优先级, 输出DEBUG、ERROR等. <code>-5</code>是可选的, 格式化输出宽度，为了更好的输出效果.</li>
  <li><code>%c{1}</code> 是日志名称，通过getLogger()设置, 可以参考<a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html">log4j PatternLayout guide</a>.</li>
  <li><code>%L</code> 打印日志的句子在源文件中的行数.</li>
  <li><code>%m%n</code> 打印的日志信息和换行符.</li>
</ol>

<p>上述设置的输出效果是：</p>

<pre><code>2014-07-02 20:52:39 DEBUG className:200 - This is debug message
2014-07-02 20:52:39 DEBUG className:201 - This is debug message2
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>HelloExample.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">import</span> <span class="nn">org.apache.log4j.Logger</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloExample</span><span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">final</span> <span class="kd">static</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">HelloExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">HelloExample</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HelloExample</span><span class="o">();</span>
</span><span class="line">        <span class="n">obj</span><span class="o">.</span><span class="na">runMe</span><span class="o">(</span><span class="s">&quot;billowkiller&quot;</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">runMe</span><span class="o">(</span><span class="n">String</span> <span class="n">parameter</span><span class="o">){</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span><span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;This is debug : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span><span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;This is info : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&quot;This is warn : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;This is error : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">fatal</span><span class="o">(</span><span class="s">&quot;This is fatal : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="k">try</span><span class="o">{</span>
</span><span class="line">            <span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">ArithmeticException</span> <span class="n">ex</span><span class="o">){</span>
</span><span class="line">            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;Sorry, something wrong!&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以调整配置文件中的<code>log4j.rootLogger</code>设置日志输出的级别和<code>appender</code>，级别从低到高有DEBUG、INFO、WARN、ERROR、FATAL，一般使用INFO和ERROR。</p>

<p>顺便说一句，类似<code>logger.isDebugEnabled()</code>这种句子在源码中实在是不太美观。如果debug中间的信息不影响程序的性能还是不要使用这种句子，因为log4j自己会检查需不需要输出debug信息。</p>

<h3 id="tips">Tips</h3>

<ul>
  <li>java -calsspath *.jar 加载多个jar包，而多个jar包中可能包含多个log4j.properties的时候，系统自动加载第一个，忽略后面的。也就是说将你想要使用的log4j.properties所包含的jar文件放在classpath的第一个。</li>
  <li>mvn的package和test可以分别对应两个不同的log4j.properties中，如下：src/main/resources/log4j.properties, src/test/resources/log4j.properties。</li>
  <li><strong>需要注意程序的输出级别，用户可以定义不同的配置文件来输出不同级别的信息</strong>。这一点尤其重要：
    <ul>
      <li>工具是为程序提供服务的，在开发和调试阶段，日志可以帮助我们更好更快地定位bug；在运行维护阶段，日志系统又可以帮我们记录大部分的异常信息，从而帮助我们更好的完善系统。</li>
      <li>定义好级别和输出的日志信息，配合使用<code>grep</code>等命令行工具，可以更好的帮助我们定位错误。</li>
      <li>在设计系统之前需要先确定好日志子系统，在什么情况下程序会发生错误，输出什么样的错误信息，在debug和正常运行的时候日志如何调整，error信息是否需要另外打印。</li>
    </ul>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Static and Dynamic Library]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/29/static-and-dynamic-library/"/>
    <updated>2014-08-29T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/29/static-and-dynamic-library</id>
    <content type="html"><![CDATA[<p>库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库。C默认使用的库就是<code>libc.so</code>。</p>

<p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。</p>

<p>所谓静态、动态是指链接。</p>

<!--more-->

<h2 id="section">编译和链接</h2>

<p>将一个程序编译成可执行程序的步骤：</p>

<ol>
  <li>
    <p><strong>预处理：</strong>主要是处理源代码中以“#”开始的预编译指令，以及删除注释，添加行号和文件名标识。</p>

    <pre><code> gcc -E hello.c -o hello.i
</code></pre>
  </li>
  <li>
    <p><strong>编译：</strong> 把预处理完的文件进行一系列<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>以及<strong>优化</strong>后<strong>生成相应的汇编代码文件</strong>。</p>

    <pre><code> gcc -S hello.i -o hello.s 
</code></pre>
  </li>
  <li>
    <p><strong>汇编：</strong>将汇编代码转变为机器代码。</p>

    <pre><code> as hello.s -o hello.o
 gcc -c hello.s -o hello.o
</code></pre>
  </li>
  <li>
    <p><strong>链接：</strong>链接过程主要包括了<strong>地址和空间分配</strong>、<strong>符号决议</strong>和<strong>重定位</strong>。</p>

    <p>链接所要做的工作也就是打补丁，将模块中引用其他模块变量或函数的地方由0修改成其他模块中的地址。这个修正的过程叫做重定位，每个要被修正的地方叫一个重定位入口。</p>

    <pre><code> ld a.o b.o -e main -o ab
</code></pre>
  </li>
</ol>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/gcc_zps9691e38f.png" alt="gcc过程分解" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/compile_zps2febeeff.gif" alt="" /></p>

<h2 id="section-1">静态链接</h2>

<p>链接器异步都采用一种叫两步链接的方法。也就是整个链接过程分两步。</p>

<ul>
  <li>
    <p>空间与地址分配</p>

    <p>链接器获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p>

    <p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/compile2_zps2aaa528b.png" alt="" /></p>
  </li>
  <li>
    <p>符号解析与重定位</p>

    <p>通过空间与地址的分配可以得知，链接器在完成空间与地址的分配之后就可以确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
  </li>
</ul>

<p>在ELF文件中，有个叫做<strong>重定位表</strong>的数据结构专门用来保存这些与重定位相关的信息，它在ELF文件中往往是一个或多个段。.text和.data段各有自己的重定位表，包含信息有<strong>重定位入口</strong>以及<strong>偏移</strong>。</p>

<p>重定位过程中，每个重定位的入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找有所有输入目标文件的符号表组成的<strong>全局符号表</strong>，找到相应的符号后进行重定位。</p>

<p>在链接器扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在全局符号表中找到，否则连接器就报<strong>符号未定义</strong>错误。</p>

<p><strong>静态库</strong>可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。人们使用<code>ar</code>压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/compile3_zps21c35794.png" alt="" /></p>

<h2 id="section-2">可执行文件的装载</h2>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load1_zps072482ca.png" alt="" />
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load2_zpscd53f782.png" alt="" />
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load3_zpsf9324209.png" alt="" />
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load4_zpsc3f80dea.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load5_zps5d1477cf.png" alt="" /></p>

<p>ELF文件中，段的权限往往只有为数不多的几种组合，基本上是三种：</p>

<ul>
  <li>以代码段为代表的权限为可读可执行的段</li>
  <li>以数据段和.bss段为代表的可读可写段</li>
  <li>以制度数据段为代表的权限为只读的段</li>
</ul>

<p>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间，基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA，这样可以减少页面内部碎片，从而节省了内存空间：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load6_zpsde691d1c.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/load7_zps0008209b.png" alt="" /></p>

<p>操作系统堆的最大申请空间会受到操作系统版本、程序本身大小、用到的动态/共享库数量、大小、程序栈数量、大小的等的影响。甚至有可能每次运行的结果都会不同，因为有些操作系统使用了一种叫做随机地址空间分布的技术，使得进程的堆空间变小。</p>

<h3 id="section-3">程序的执行过程</h3>

<p>首先在用户层面，bash进程会调用<code>fork()</code>系统调用创建一个新的进程，新的进程调用<code>execve()</code>系统调用执行指定的ELF，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。</p>

<p>系统通过文件开头的魔数判断是ELF文件后调用<code>load_elf_binary()</code>;</p>

<ol>
  <li>检测ELF可执行文件格式的有效性</li>
  <li>寻找动态链接的“.interp”段，设置动态连接器路径</li>
  <li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。</li>
  <li>初始化ELF进程环境</li>
  <li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的连接方式，对于静态连接的ELF可执行文件，这个入口就是ELF文件的文件头中的<code>e_entry</code>所指向的地址；对于动态链接的ELF可执行文件，入口点就是动态链接器。</li>
</ol>

<p>指令寄存器设置成程序的入口点，启动程序。</p>

<p><strong>系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。</strong></p>

<p>我们在静态链接时提到过重定位，那时的重定位叫做<strong>链接时重定位</strong>（Link Time Relocation） ， 而现在这种情况经常被称为<strong>装载时重定位</strong>（Load Time Relocation）。</p>

<p>所以说装载时重定位一个很大的缺点就是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。 解决方法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变， 而数据部分可以在进程中拥有一个副本。这种方案被称为 <strong>地址无关代码</strong>（PIC, Position-independent Code）技术。目的是希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变。</p>

<h2 id="section-4">动态链接</h2>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/dl1_zps2e9939ac.png" alt="" /></p>

<p>为什么需要动态库，其实也是静态库的特点导致。</p>

<ul>
  <li>空间浪费是静态库的一个问题。</li>
  <li>另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。</li>
</ul>

<p>动态库在程序编译时并不会被连接到目标代码中，而是等到程序要运行时才进行链接。<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题</strong>。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong>。</p>

<p>动态库特点总结：</p>

<ul>
  <li>动态库把对一些库函数的链接载入推迟到程序运行的时期。</li>
  <li>动态链接的方式使得开发过程中各个模块更加独立、耦合度更小，便于不同的开发者和开发组织之间进行独立的开发和测试。</li>
  <li>程序在运行时可以动态的选择加载各种程序模块，使得插件成为可能。</li>
</ul>

<p>动态链接过程：</p>

<p><strong>链接时重定位（静态链接）；装载时重定位（动态链接）</strong></p>

<p><strong>地址无关代码</strong>：PIC，Position-independent Code，把指令中那些需要修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以再每个进程中拥有个副本。</p>

<p>对于现代机器来说，产生地址无关的代码并不麻烦。我们首先把共享对象模块中的地址引用按照是否为跨模块分成两类： 模块内部引用和模块外部引用；按照不同的引用方式又可以分为指令引用和数据访问。 这样我们就得到了如下4种情况：</p>

<ol>
  <li>模块内部的函数调用、跳转等；</li>
  <li>模块内部的数据访问，比如模块中定义的全局变量、静态变量；</li>
  <li>模块外部的函数调用、跳转等；</li>
  <li>模块外部的数据访问，比如其它模块中定义的全局变量；</li>
</ol>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/dl2_zps9afd4901.png" alt="" /></p>

<p><strong>动态链接比静态链接慢</strong>的主要原因是动态链接下对于全局静态的数据访问要进行复杂的GOT定位,然后间接寻址.</p>

<p><strong>延迟绑定：</strong></p>

<p>由于很多函数在程序执行过程中不一定被用到（错误处理函数，特殊功能模块），ELF采用一种叫做 <strong>延迟绑定（Lazy Binding）</strong>的做法， 基本思想就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。可以大大加快程序的启动速度。</p>

<p>ELF使用PLT（Procedure Linkage Table）的方法来实现延迟绑定。PLT大致的工作原理如下：每个外部函数在PLT中都有一个相应的项，如果链接器在初始化阶段已经初始化该项，并且将函数地址填入该项，那么直接跳转到这个地址，实现函数的正确调用。否则调用_dl_runtime_resolve()函数，该函数利用重定位表完成符号解析和重定位工作。解析结束后将地址填入对应的项中。</p>

<p><strong>ELF中的字段：</strong></p>

<p>在动态链接的ELF可执行文件中，有一个专门的段叫做“.interp”，该段保存了需要的动态链接器需路径，一般是/lib/ld-linux.so.2。</p>

<p>动态链接ELF中最重要的结构应该是“.dynamic”段，这个段里面保存了动态连接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。</p>

<p>为了表示动态链接这些模块之间的符号导出与导入关系，ELF专门有一个叫做动态符号表的段用来保存这些信息。这个段叫做“.dynsym”。</p>

<p>动态链接的文件中，也有类似静态链接的重定位表，分别叫做“.rel.dyn”和“.rel.plt”，他们分别相当于“.rel.text”和“.rel.data”。</p>

<p><strong>动态链接的步骤和实现</strong>：</p>

<p>动态链接的步骤基本分为三步：先启动动态连接器本身，然后装载所有需要的共享对象，最后是重定位和初始化。</p>

<p>但是对于动态链接器本身来说，它的重定位工作是由谁来完成的？ 动态连接器本身通过自举（Bootstrap）来完成。完成基本自举之后，动态连接器将可执行文件和连接器本身的符号表都合并到一个符号表当中，我们可以称它为全局符号表（Global Symbol Table）。</p>

<p>动态连接器按照各个模块之间的依赖关系，当有两个不同的模块定义了同一个符号时怎么办？当一个符号需要被加入全局符号表时，如果相同的符号已经存在，则后加入的符号被忽略。</p>

<p><strong>显示运行时链接：</strong></p>

<p>动态库的装载则是通过一些列由动态连接器提供的API，具体是4个函数：打开动态库（<code>dlopen</code>）、查找符号（<code>dlsym</code>）、错误处理（<code>dlerror</code>）、以及关闭动态库（<code>dlclose</code>）。</p>

<p><code>dlopen()</code>函数用来打开动态库，并将其加载到进程的地址空间，完成初始化过程。</p>

<pre><code>void  *dlopen(const char *filename, int flag);
</code></pre>

<p><code>dlsym()</code>，我们通过该函数找到所需要的符号。</p>

<pre><code>dlsym(void  *handle,  char  *symbol);
</code></pre>

<h3 id="c">显式调用C++动态库注意点</h3>

<p>对C++来说，情况稍微复杂。显式加载一个C++动态库的困难一部分是因为C++的name mangling；另一部分是因为没有提供一个合适的API来装载类，在C++中，您可能要用到库中的一个类，而这需要创建该类的一个实例，这不容易做到。</p>

<p>name mangling可以通过<code>extern "C"</code>解决。C++有个特定的关键字用来声明采用C binding的函数：<code>extern "C"</code> 。用 <code>extern "C"</code>声明的函数将使用函数名作符号名，就像C函数一样。因此，只有非成员函数才能被声明为<code>extern "C"</code>，并且不能被重载。尽管限制多多，<code>extern "C"</code>函数还是非常有用，因为它们可以象C函数一样被<code>dlopen</code>动态加载。冠以<code>extern "C"</code>限定符后，并不意味着函数中无法使用C++代码了，相反，它仍然是一个完全的C++函数，可以使用任何C++特性和各种类型的参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classical Sync Problem]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/23/classical-sync-problem/"/>
    <updated>2014-08-23T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/23/classical-sync-problem</id>
    <content type="html"><![CDATA[<p>简单的记录下，后期再整理吧。</p>

<hr />

<h2 id="section">生产者、消费者</h2>

<h3 id="section-1">多个生产者，单个消费者</h3>

<!--more-->

<p><strong>1. 使用互斥锁 &amp;&amp; 条件变量</strong></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc1_zps5e6026ee.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc2_zps96f163b4.png" alt="" /></p>

<p><strong>2. 使用信号量</strong></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc3_zps90f678c0.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc4_zpsff637264.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc5_zpsc1ce838d.png" alt="" /></p>

<h3 id="section-2">多个生产者，多个消费者</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc6_zps5fd624fc.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc7_zps77aab9e4.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc8_zps7ec189ae.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/pc9_zps88ec073a.png" alt="" /></p>

<h2 id="section-3">多个缓冲区读写</h2>

<p>最简单的双缓冲区示意图</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/db1_zps098b0d0f.png" alt="" /></p>

<p><strong>多缓冲区生产者消费者代码</strong></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/db2_zps9fda343a.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/db3_zps03dac974.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Pattern Abstraction]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/22/design-pattern/"/>
    <updated>2014-08-22T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/22/design-pattern</id>
    <content type="html"><![CDATA[<p>本文是对设计模式的一个备忘录，仅是做了些摘要，具体的设计模式学习还得看GOF。</p>

<p>这儿也有一个还不错的博客<a href="http://blog.csdn.net/zhengzhb/article/category/926691">http://blog.csdn.net/zhengzhb/article/category/926691</a>。</p>

<hr />

<p>面向对象设计（OOD）核心原则是<strong>高内聚低耦合</strong>。</p>

<ul>
  <li><em>高内聚</em>是指某个特定模块（程序，类型）都应完成一系列相关功能，描述了不同程序，类型中方法，方法中不同操作描述的逻辑之间的距离相近。高内聚意味可维护性，可重新性，因为模块对外部的依赖少（功能的完备性）。</li>
  <li><em>耦合</em>是描述模块之间的依赖程度。低耦合是我们的设计目的，但不是不存在耦合不存依赖，依赖是必须的，因为模块之间必须通信交互，不过应该设计依赖于不变或者不易变的接口，无需了解模块的具体实现（OO封装性）。</li>
</ul>

<p>使用<strong>设计模式</strong>是为了提高代码的工程化，提供更加高内聚、低耦合的代码。同时可重用代码、让代码更容易被他人理解、保证代码可靠性。套用一句话就是：</p>

<blockquote>
  <p>每个模式描述了一个在我们周围不断重复发生的问题，已经该问题的解决方案的核心。这样我们就能一次又一次地使用该方案而不必做重复劳动。</p>
</blockquote>

<p>设计模式分为三种类型，共23种。</p>

<ul>
  <li><strong>创建型模式：</strong>单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</li>
  <li><strong>结构型模式：</strong>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li>
  <li><strong>行为型模式：</strong>模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</li>
</ul>

<!--more-->

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/dp1_zps74894e4d.png" alt="" /></p>

<h2 id="section">创建型模式</h2>

<h3 id="factory">工厂模式（Factory）</h3>

<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>当一个类不知道它所必须创建的对象的类的时候。</li>
  <li>当一个类希望由它的子类来指定它所创建的对象的时候。</li>
  <li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/factory_zpsc31117cb.gif" alt="" /></p>

<h3 id="abstract-factory">抽象工厂模式（Abstract Factory）</h3>

<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>一个系统要独立于它的产品的创建、组合和表示时。</li>
  <li>一个系统要由多个产品系列中的一个来配置时。</li>
  <li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>
  <li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/abstractfactory_zpsf3be4cdd.gif" alt="" /></p>

<h3 id="builder">建造者模式（Builder）</h3>

<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
  <li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/builder_zps7d31e2f5.gif" alt="" /></p>

<h3 id="prototype">原型模式（Prototype）</h3>

<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者</li>
  <li>为了避免创建一个与产品类层次平行的工厂类层次时；或者</li>
  <li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/prototype_zpsb4a5c2aa.gif" alt="" /></p>

<h2 id="section-1">结构型模式</h2>

<h3 id="adapter">适配器模式（Adapter）</h3>

<p>将一个类的接口转换成另外一个客户希望的接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li>
  <li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li>
  <li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/adapter_zps1800d0cc.gif" alt="" /></p>

<h3 id="decorator">装饰模式（Decorator）</h3>

<p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
  <li>处理那些可以撤消的职责。</li>
  <li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/Decorator_zpse3f223d4.gif" alt="" /></p>

<h2 id="section-2">行为型模式</h2>

<h3 id="observer">观察者模式（Observer）</h3>

<p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
  <li>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</li>
  <li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/observer_zps892df2a6.gif" alt="" /></p>

<h3 id="state">状态模式（State）</h3>

<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</li>
  <li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/state_zps349fba82.gif" alt="" /></p>

<h3 id="strategy">策略模式（Strategy）</h3>

<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>

<p><strong>适用性</strong></p>

<ul>
  <li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
  <li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。</li>
  <li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
  <li>一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/strategy_zpsc3f3c44b.gif" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Memory Management]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/14/linux-memory-management/"/>
    <updated>2014-08-14T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/14/linux-memory-management</id>
    <content type="html"><![CDATA[<p>reprint from <a href="http://www.kerneltravel.net/journal/v/mem.htm">http://www.kerneltravel.net/journal/v/mem.htm</a></p>

<hr />

<p>看到一篇介绍linux内存管理的好文，忍不住转载，做个记录。内容作了部分删改。</p>

<h2 id="section">摘要</h2>

<p>本章首先以应用程序开发者的角度审视Linux的进程内存管理，在此基础上逐步深入到内核中讨论系统物理内存管理和内核内存的使用方法。力求从外到内、水到渠成地引导网友分析Linux的内存管理与使用。在本章最后，我们给出一个内存映射的实例，帮助网友们理解内核内存管理与用户内存管理之间的关系，希望大家最终能驾驭Linux内存管理。</p>

<!--more-->

<h2 id="section-1">前言</h2>

<p>内存管理一向是所有操作系统书籍不惜笔墨重点讨论的内容，无论市面上或是网上都充斥着大量涉及内存管理的教材和资料。因此，我们这里所要写的Linux内存管理采取避重就轻的策略，从理论层面就不去班门弄斧，贻笑大方了。我们最想做的和可能做到的是从开发者的角度谈谈对内存管理的理解，最终目的是把我们在内核开发中使用内存的经验和对Linux内存管理的认识与大家共享。</p>

<p>当然，这其中我们也会涉及到一些诸如段页等内存管理的基本理论，但我们的目的不是为了强调理论，而是为了指导理解开发中的实践，所以仅仅点到为止，不做深究。</p>

<p>遵循“理论来源于实践”的“教条”，我们先不必一下子就钻入内核里去看系统内 存到底是如何管理，那样往往会让你陷入似懂非懂的窘境（我当年就犯了这个错误！）。所以最好的方式是先从外部（用户编程范畴）来观察进程如何使用内存，等 到大家对内存的使用有了较直观的认识后，再深入到内核中去学习内存如何被管理等理论知识。最后再通过一个实例编程将所讲内容融会贯通。</p>

<h2 id="section-2">进程与内存</h2>

<h3 id="section-3">进程如何使用内存？</h3>

<p>毫无疑问，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。</p>

<p>对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。</p>

<p><strong>代码段：</strong>代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</p>

<p><strong>数据段：</strong>数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</p>

<p><strong>BSS段：</strong>BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。</p>

<p><strong>堆（heap）：</strong>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>

<p><strong>栈：</strong>栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>

<p><img src="http://dl.iteye.com/upload/picture/pic/80993/96d2c983-bec7-34d6-805b-2a8e40506848.png" alt="" /></p>

<p>从用户向内核看，所使用的内存表象形式会依次经历“逻辑地址”——“线性地址”——“物理地址”几种形式（关于几种地址的解释在前面已经讲述了）。逻辑地址经段机制转化成线性地址；线性地址又经过页机制转化为物理地址。（但是我们要知道Linux系统虽然保留了段机制，但是将所有程序的段地址都定死为0-4G，所以虽然逻辑地址和线性地址是两种不同的地址空间，但在Linux中逻辑地址就等于线性地址，它们的值是一样的）。沿着这条线索，我们所研究的主要问题也就集中在下面几个问题。</p>

<ol>
  <li>进程空间地址如何管理？</li>
  <li>进程地址如何映射到物理内存？</li>
  <li>物理内存如何被管理？</li>
</ol>

<p>以及由上述问题引发的一些子问题。如系统虚拟地址分布；内存分配接口；连续内存分配与非连续内存分配等。</p>

<h2 id="section-4">进程内存空间</h2>

<p>Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间（具体的原因请看硬件基础部分）。</p>

<p>在讨论进程空间细节前，这里先要澄清下面几个问题：</p>

<ol>
  <li>4G的进程地址空间被人为的分为两个部分——用户空间与内核空间。用户空间从0到3G（0xC0000000），内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻可以访问到内核空间。</li>
  <li>用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有自己对应的页表（init_mm.pgd），用户进程各自有不同的页表。</li>
  <li>每个进程的用户空间都是完全独立、互不相干的。不信的话，你可以把上面的程序同时运行10次（当然为了同时运行，让它们在返回前一同睡眠100秒吧），你会看到10个进程占用的线性地址一模一样。</li>
</ol>

<h3 id="section-5">进程内存管理</h3>

<p>进程内存管理的对象是进程线性地址空间上的内存镜像，这些内存镜像其实就是进程使用的虚拟内存区域（memory region）。进程虚拟空间是个32或64位的“平坦”（独立的连续区间）地址空间（空间的具体大小取决于体系结构）。要统一管理这么大的平坦空间可绝非易事，为了方便管理，虚拟空间被划分为许多大小可变的(但必须是4096的倍数)内存区域，这些区域在进程线性地址中像停车位一样有序排列。这些区域的划分原则是“将访问属性一致的地址空间存放在一起”，所谓访问属性在这里无非指的是“可读、可写、可执行等”。</p>

<p>如果你要查看某个进程占用的内存区域，可以使用命令<code>cat /proc/&lt;pid&gt;/maps</code>获得。</p>

<p><strong>注意，你一定会发现进程空间只包含三个内存区域，似乎没有上面所提到的堆、bss等，其实并非如此，程序内存段和进程地址空间中的内存区域是种模糊对应，也就是说，堆、bss、数据段（初始化过的）都在进程空间中由数据段内存区域表示。</strong></p>

<p>在Linux内核中对应进程内存区域的数据结构是: vm_area_struct, 内核将每个内存区域作为一个单独的内存对象管理，相应的操作也都一致。采用面向对象方法使VMA结构体可以代表多种类型的内存区域－－比如内存映射文件或进程的用户空间栈等，对这些区域的操作也都不尽相同。</p>

<p>vm_area_strcut结构比较复杂，关于它的详细结构请参阅相关资料。我们这里只对它的组织方法做一点补充说明。vm_area_struct是描述进程地址空间的基本管理单元，对于一个进程来说往往需要多个内存区域来描述它的虚拟空间，如何关联这些不同的内存区域呢？大家可能都会想到使用链表，的确vm_area_struct结构确实是以链表形式链接，不过为了方便查找，内核又以红黑树（以前的内核使用平衡树）的形式组织内存区域，以便降低搜索耗时。并存的两种组织形式，并非冗 余：链表用于需要遍历全部节点的时候用，而红黑树适用于在地址空间中定位特定内存区域的时候。内核为了内存区域上的各种不同操作都能获得高性能，所以同时 使用了这两种数据结构。</p>

<p>下图反映了进程地址空间的管理模型：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/tu1_zps5b8ee942.jpg" alt="" /></p>

<p><strong>进程的地址空间对应的描述结构是“内存描述符结构”,它表示进程的全部地址空间，——包含了和进程地址空间有关的全部信息，其中当然包含进程的内存区域。</strong></p>

<h3 id="section-6">进程内存的分配与回收</h3>

<p>创建进程<code>fork()</code>、程序载入<code>execve()</code>、映射文件<code>mmap()</code>、动态内存分配<code>malloc()/brk()</code>等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际内存，而是虚拟内存，准确的说是“内存区域”。进程对内存区域的分配最终都会归结到<code>do_mmap（）</code>函数上来（<code>brk</code>调用被单独以系统调用实现，不用<code>do_mmap()</code>），</p>

<p>内核使用<code>do_mmap()</code>函数创建一个新的线性地址区间。但是说该函数创建了一个新VMA并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，那么两个区间将合并为一个。如果不能合并，那么就确实需要创建一个新的VMA了。但无论哪种情况， <code>do_mmap()</code>函数都会将一个地址区间加入到进程的地址空间中－－无论是扩展已存在的内存区域还是创建一个新的区域。</p>

<p>同样，释放一个内存区域应使用函数<code>do_ummap()</code>，它会销毁对应的内存区域。</p>

<h3 id="section-7">如何由虚变实！</h3>

<p>从上面已经看到进程所能直接操作的地址都为虚拟地址。当进程需要内存时，从内核获得的仅仅是虚拟的内存区域，而不是实际的物理地址，进程并没有获得物理内存（物理页面——页的概念请大家参考硬件基础一章），获得的仅仅是对一个新的线性地址区间的使用权。实际的物理内存只有当进程真的去访问新获取的虚拟地址时，才会由“请求页机制”产生“缺页”异常，从而进入分配实际页面的例程。</p>

<p>该异常是虚拟内存机制赖以存在的基本保证——它会告诉内核去真正为进程分配物理页，并建立对应的页表，这之后虚拟地址才实实在在地映射到了系统的物理内存上。（当然，如果页被换出到磁盘，也会产生缺页异常，不过这时不用再建立页表了）</p>

<p>这种请求页机制把页面的分配推迟到不能再推迟为止，并不急于把所有的事情都一次做完（这种思想有点像设计模式中的代理模式（proxy））。之所以能这么做是利用了内存访问的“局部性原理”，请求页带来的好处是节约了空闲内存，提高了系统的吞吐率。要想更清楚地了解请求页机制，可以看看《深入理解linux内核》一书。</p>

<p>这里我们需要说明在内存区域结构上的nopage操作。当访问的进程虚拟内存并未真正分配页面时，该操作便被调用来分配实际的物理页，并为该页建立页表项。在最后的例子中我们会演示如何使用该方法。</p>

<h2 id="section-8">系统物理内存管理</h2>

<p>虽然应用程序操作的对象是映射到物理内存之上的虚拟内存，但是处理器直接操作的却是物理内存。所以当应用程序访问一个虚拟地址时，首先必须将虚拟地址转化成 物理地址，然后处理器才能解析地址访问请求。地址的转换工作需要通过查询页表才能完成，概括地讲，地址转换需要将虚拟地址分段，使每段虚地址都作为一个索引指向页表，而页表项则指向下一级别的页表或者指向最终的物理页面。</p>

<p>每个进程都有自己的页表。进程描述符的pgd域指向的就是进程的页全局目录。下面我们借用《linux设备驱动程序》中的一幅图大致看看进程地址空间到物理页之间的转换关系。</p>

<p><img src="http://www.kerneltravel.net/journal/v/mem.files/image003.jpg" alt="" /></p>

<p>上面的过程说起来简单，做起来难呀。因为在虚拟地址映射到页之前必须先分配物理页——也就是说必须先从内核中获取空闲页，并建立页表。下面我们介绍一下内核管理物理内存的机制。</p>

<h3 id="section-9">物理内存管理（页管理）</h3>

<p>Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数个4k（在i386体系结构中）大小的页，从而分配和回收内存的基本单位便是内存页了。利用分页管理有助于灵活分配内存地址，因为分配时不必要求必须有大块的连续内存,系统可以东一页、西一页的凑出所需要的内存供进程使用。虽然如此，但是实际上系统使用内存时还是倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率（频繁刷新会在很大程度上降低访问速度）。</p>

<p>鉴于上述需求，内核分配物理页面时为了尽量减少不连续情况，采用了“伙伴”关系来管理空闲页面。伙伴关系分配算法大家应该不陌生——几乎所有操作系统方面的书都会提到,我们不去详细说它了，如果不明白可以参看有关资料。这里只需要大家明白Linux中空闲页面的组织和管理利用了伙伴关系，因此空闲页面分配时也需要遵循伙伴关系，最小单位只能是2的幂倍页面大小。内核中分配空闲页面的基本函数是<code>get_free_page/get_free_pages</code>，它们或是分配单页或是分配指定的页面（2、4、8…512页）。</p>

<p><strong>注意：</strong> <code>get_free_page</code>是在内核中分配内存，不同于<code>malloc</code>在用户空间中分配，<code>malloc</code>利用堆动态分配，实际上是调用<code>brk()</code>系统调用，该调用的作用是扩大或缩小进程堆空间（它会修改进程的<code>brk</code>域）。如果现有的内存区域不够容纳堆空间，则会以页面大小的倍数为单位，扩张或收缩对应的内存区域，但<code>brk</code>值并非以页面大小为倍数修改，而是按实际请求修改。因此<code>malloc</code>在用户空间分配内存可以以字节为单位分配,但内核在内部仍然会是以页为单位分配的。</p>

<p>另外,需要提及的是，物理页在系统中由页结构<code>struct page</code>描述，系统中所有的页面都存储在数组<code>mem_map[]</code>中，可以通过该数组找到系统中的每一页（空闲或非空闲）。而其中的空闲页面则可由上述提到的以伙伴关系组织的空闲页链表（<code>free_area[MAX_ORDER]</code>）来索引。</p>

<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/kanghua/systemcall.bmp" alt="" /></p>

<h3 id="section-10">内核内存使用</h3>

<p><strong>Slab</strong></p>

<p>所 谓尺有所长，寸有所短。以页为最小单位分配内存对于内核管理系统中的物理内存来说的确比较方便，但内核自身最常使用的内存却往往是很小（远远小于一页）的 内存块——比如存放文件描述符、进程描述符、虚拟内存区域描述符等行为所需的内存都不足一页。这些用来存放描述符的内存相比页面而言，就好比是面包屑与面 包。一个整页中可以聚集多个这些小块内存；而且这些小块内存块也和面包屑一样频繁地生成/销毁。</p>

<p>为了满足内核对这种小内存块的需要，Linux系统采用了一种被称为slab分配器的技术。Slab分配器的实现相当复杂，但原理不难，其核心思想就是“存储池”的运用。内存片段（小块内存）被看作对象，当被使用完后，并不直接释放而是被缓存到“存储池”里，留做下次使用，这无疑避免了频繁创建与销毁对象所带来的额外负载。</p>

<p>Slab技术不但避免了内存内部分片（下文将解释）带来的不便（引入Slab分配器的主要目的是为了减少对伙伴系统分配算法的调用次数——频繁分配和回收必然会导致内存碎片——难以找到大块连续的可用内存），而且可以很好地利用硬件缓存提高访问速度。</p>

<p><strong>Slab并非是脱离伙伴关系而独立存在的一种内存分配方式，slab仍然是建立在页面基础之上，换句话说，Slab将页面（来自于伙伴关系管理的空闲页面链表）撕碎成众多小内存块以供分配，slab中的对象分配和销毁使用<code>kmem_cache_alloc</code>与<code>kmem_cache_free</code>。</strong></p>

<p><strong>Kmalloc</strong></p>

<p>Slab分配器不仅仅只用来存放内核专用的结构体，它还被用来处理内核对小块内存的请求。当然鉴于Slab分配器的特点，一般来说内核程序中对小于一页的小块内存的请求才通过Slab分配器提供的接口<code>Kmalloc</code>来完成（虽然它可分配32 到131072字节的内存）。从内核内存分配的角度来讲，kmalloc可被看成是<code>get_free_page（s）</code>的一个有效补充，内存分配粒度更灵活了。</p>

<p>有兴趣的话，可以到<code>/proc/slabinfo</code>中找到内核执行现场使用的各种slab信息统计，其中你会看到系统中所有slab的使用信息。从信息中可以看到系统中除了专用结构体使用的slab外，还存在大量为<code>Kmalloc</code>而准备的Slab（其中有些为dma准备的）。</p>

<p><strong>内核非连续内存分配（Vmalloc）</strong></p>

<p>伙伴关系也好、slab技术也好，从内存管理理论角度而言目的基本是一致的，它们都是为了防止“分片”，不过分片又分为外部分片和内部分片之说，所谓内部分片是说系统为了满足一小 段内存区（连续）的需要，不得不分配了一大区域连续内存给它，从而造成了空间浪费；外部分片是指系统虽有足够的内存，但却是分散的碎片，无法满足对大块 “连续内存”的需求。无论何种分片都是系统有效利用内存的障碍。slab分 配器使得一个页面内包含的众多小块内存可独立被分配使用，避免了内部分片，节约了空闲内存。伙伴关系把内存块按大小分组管理，一定程度上减轻了外部分片的 危害，因为页框分配不在盲目，而是按照大小依次有序进行，不过伙伴关系只是减轻了外部分片，但并未彻底消除。你自己比划一下多次分配页面后，空闲内存的剩余情况吧。</p>

<p>所以避免外部分片的最终思路还是落到了如何利用不连续的内存块组合成“看起来很大的内存块”——这里的情况很类似于用户空间分配虚拟内存，内存逻辑上连续，其实映射到并不一定连续的物理内存上。Linux内核借用了这个技术，允许内核程序在内核地址空间中分配虚拟地址，同样也利用页表（内核页表）将虚拟地址映射到分散的内存页上。以此完美地解决了内核内存使用中的外部分片问题。内核提供<code>vmalloc</code>函数分配内核虚拟内存，该函数不同<code>于kmalloc</code>，它可以分配较<code>Kmalloc</code>大得多的内存空间（可远大于128K，但必须是页大小的倍数），但相比<code>Kmalloc</code>来说,<code>Vmalloc</code>需要对内核虚拟地址进行重映射，必须更新内核页表，因此分配效率上要低一些（用空间换时间）。</p>

<p>与用户进程相似,内核也有一个名为<code>init_mm</code>的<code>mm_strcut</code>结构来描述内核地址空间，其中页表项<code>pdg=swapper_pg_dir</code>包含了系统内核空间（3G-4G）的映射关系。因此<code>vmalloc</code>分配内核虚拟地址必须更新内核页表，而<code>kmalloc</code>或<code>get_free_page</code>由于分配的连续内存，所以不需要更新内核页表。</p>

<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/kanghua/systemcall2.bmp" alt="" /></p>

<p><code>vmalloc</code>分配的内核虚拟内存与<code>kmalloc/get_free_page</code>分配的内核虚拟内存位于不同的区间，不会重叠。因为内核虚拟空间被分区管理，各司其职。进程空间地址分布从０到３G(其实是到<code>PAGE_OFFSET</code>, 在0x86中它等于0xC0000000)，从3G到<code>vmalloc_start</code>这段地址是物理内存映射区域（该区域中包含了内核镜像、物理页面表<code>mem_map</code>等等）比如我使用的系统内存是64M(可以用free看到)，那么(3G——3G+64M)这片内存就应该映射到物理内存，而<code>vmalloc_start</code>位置应在3G+64M附近（说”附近”因为是在物理内存映射区与<code>vmalloc_start</code>期间还会存在一个8M大小的gap来防止跃界）,<code>vmalloc_end</code>的位置接近4G(说”接近”是因为最后位置系统会保留一片128k大小的区域用于专用页面映射，还有可能会有高端内存映射区，这些都是细节，这里我们不做纠缠)。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/tu2_zpsfa7ec115.jpg" alt="" /></p>

<p>由<code>get_free_page</code>或<code>Kmalloc</code>函数所分配的连续内存都陷于物理映射区域，所以它们返回的内核虚拟地址和实际物理地址仅仅是相差一个偏移量（<code>PAGE_OFFSET</code>），你可以很方便的将其转化为物理内存地址，同时内核也提供了<code>virt_to_phys（）</code>函数将内核虚拟空间中的物理映射区地址转化为物理地址。要知道，物理内存映射区中的地址与内核页表是有序对应的，系统中的每个物理页面都可以找到它对应的内核虚拟地址（在物理内存映射区中的）。</p>

<p>而<code>vmalloc</code>分配的地址则限于<code>vmalloc_start</code>与<code>vmalloc_end</code>之间。每一块k分配的内核虚拟内存都对应一个<code>vm_struct</code>结构体（可别和<code>vm_area_struct</code>搞混，那可是进程虚拟内存区域的结构），不同的内核虚拟地址被4k大小的空闲区间隔，以防止越界——见下图）。与进程虚拟地址的特性一样，这些虚拟地址与物理内存没有简单的位移关系，必须通过内核页表才可转换为物理地址或物理页。它们有可能尚未被映射，在发生缺页时才真正分配物理页面。</p>

<p><img src="http://www.kerneltravel.net/journal/v/mem.files/image013.jpg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickSort and Derivatives]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/09/quicksort/"/>
    <updated>2014-08-09T03:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/09/quicksort</id>
    <content type="html"><![CDATA[<p>记录下快排相关的一些东西。包括普通快排，迭代快排和单链表快排。</p>

<hr />

<!--more-->

<h2 id="section">普通快排</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cm">/* A typical recursive implementation of quick sort */</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* This function takes last element as pivot, places the pivot element at its correct position in sorted array, and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot */</span>
</span><span class="line"><span class="kt">int</span> <span class="n">partition</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">            <span class="n">swap</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">swap</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* A[] --&gt; Array to be sorted, l  --&gt; Starting index, h  --&gt; Ending index */</span>
</span><span class="line"><span class="kt">void</span> <span class="n">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">){</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</span><span class="line">        <span class="n">quickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="n">quickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这种实现方式有很多可以值得改进的地方：</p>

<ol>
  <li>上面的实现使用最后一个元素作为pivot，这对于已经排好序的数组来说是个灾难。可以随机选取一个元素或者直接用中位数来替代。</li>
  <li>为了减少递归层次，可以先递归数组中个数少的一半。</li>
  <li>对于小数组来说，插入排序可能更快。可以综合下插入和快排。</li>
  <li>使用了递归和函数调用栈来存储中间值，并且还需要存储其他的信息。此外还包括存储函数调用的活动记录，恢复上层函数执行的费用。</li>
</ol>

<p>可以使用迭代来替代递归。</p>

<h3 id="section-1">迭代快排</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cm">/* This function is same in both iterative and recursive*/</span>
</span><span class="line"><span class="kt">int</span> <span class="n">partition</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="err">，</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">){</span>
</span><span class="line">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">            <span class="n">swap</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">swap</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="n">quickSortIterative</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="c1">// initialize top of stack</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">stack</span><span class="p">[</span> <span class="n">h</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">];</span> <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// push initial values of l and h to stack</span>
</span><span class="line">    <span class="n">stack</span><span class="p">[</span> <span class="o">++</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>  <span class="n">stack</span><span class="p">[</span> <span class="o">++</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Keep popping from stack while is not empty</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span> <span class="n">top</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">){</span>
</span><span class="line">        <span class="c1">// Pop h and l</span>
</span><span class="line">        <span class="n">h</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span> <span class="n">top</span><span class="o">--</span> <span class="p">];</span>  <span class="n">l</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span> <span class="n">top</span><span class="o">--</span> <span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span> <span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">l</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">stack</span><span class="p">[</span> <span class="o">++</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">stack</span><span class="p">[</span> <span class="o">++</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">stack</span><span class="p">[</span> <span class="o">++</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stack</span><span class="p">[</span> <span class="o">++</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">文艺快排</h2>

<p>思路和数据的快速排序一样，都需要找到一个pivot元素、或者节点。然后将数组或者单向链表划分为两个部分，然后递归分别快排。</p>

<p>针对数组进行快排的时候，交换交换不同位置的数值，在分而治之完成之后，数据就是排序好的。那么单向链表是什么样的情况呢？除了交换节点值之外，是否有其他更好的方法呢？可以修改指针，不进行数值交换。这可以获取更高的效率。</p>

<p>在修改指针的过程中，会产生新的头指针以及尾指针，要记录下来。在partition之后，要将小于pivot的的部分、pivot、以及大于pivot的部分重新串起来成为一个singly linked list。</p>

<p>在partition时，我们用最后的节点作为pivot。当我们扫描链表时，如果节点值大于pivot，将节点移到尾部之后；如果节点小于，保持不变。</p>

<p>在递归排序时，我们先调用partition将pivot放到正确的为止并返回pivot，然后，递归左边，递归右边，最后在合成一个单链表。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span>
</span><span class="line">                      <span class="k">struct</span> <span class="n">node</span> <span class="o">**</span><span class="n">newHead</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">**</span><span class="n">newEnd</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">pivot</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</span><span class="line">   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">   <span class="k">while</span><span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">pivot</span><span class="p">)</span>
</span><span class="line">   <span class="p">{</span>
</span><span class="line">       <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">       <span class="p">{</span>
</span><span class="line">          <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">newHead</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="o">*</span><span class="n">newHead</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line">           <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line">           <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">       <span class="p">}</span>
</span><span class="line">       <span class="k">else</span>
</span><span class="line">       <span class="p">{</span>
</span><span class="line">           <span class="k">if</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
</span><span class="line">               <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">           <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">           <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">           <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line">           <span class="n">tail</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line">           <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">       <span class="p">}</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">newHead</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">newHead</span><span class="p">)</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span><span class="line">   <span class="p">(</span><span class="o">*</span><span class="n">newEnd</span><span class="p">)</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
</span><span class="line">   <span class="k">return</span> <span class="n">pivot</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">quickSortRecur</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">head</span> <span class="o">||</span> <span class="n">head</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
</span><span class="line">       <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">newHead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">newEnd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">pivot</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newHead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newEnd</span><span class="p">);</span>
</span><span class="line">   <span class="k">if</span><span class="p">(</span><span class="n">newHead</span> <span class="o">!=</span> <span class="n">pivot</span><span class="p">)</span>
</span><span class="line">   <span class="p">{</span>
</span><span class="line">      <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">newHead</span><span class="p">;</span>
</span><span class="line">       <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">pivot</span><span class="p">)</span>
</span><span class="line">           <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">       <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">       <span class="n">newHead</span> <span class="o">=</span> <span class="n">quickSortRecur</span><span class="p">(</span><span class="n">newHead</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span><span class="line">       <span class="n">tmp</span> <span class="o">=</span> <span class="n">getTail</span><span class="p">(</span><span class="n">newHead</span><span class="p">);</span>
</span><span class="line">       <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span>  <span class="n">pivot</span><span class="p">;</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="n">pivot</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">quickSortRecur</span><span class="p">(</span><span class="n">pivot</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">newEnd</span><span class="p">);</span>
</span><span class="line">   <span class="n">returnn</span> <span class="n">ewHead</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">quickSort</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">**</span><span class="n">headRef</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">   <span class="p">(</span><span class="o">*</span><span class="n">headRef</span><span class="p">)</span> <span class="o">=</span> <span class="n">quickSortRecur</span><span class="p">(</span><span class="o">*</span><span class="n">headRef</span><span class="p">,</span> <span class="n">getTail</span><span class="p">(</span><span class="o">*</span><span class="n">headRef</span><span class="p">));</span>
</span><span class="line">   <span class="k">return</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Number Theory Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/09/Number-theory-introduction/"/>
    <updated>2014-08-09T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/09/Number-theory-introduction</id>
    <content type="html"><![CDATA[<h2 id="catalan">Catalan数</h2>

<p>卡塔兰数是组合数学中一个常在各种计数问题中出现的数列。卡塔兰数的一般项公式为：</p>

<p><img src="http://upload.wikimedia.org/math/d/1/1/d118d8cea7b639dfd5244fcba65910cf.png" alt="" /></p>

<p>它的另外一个表达式是：</p>

<p><img src="http://upload.wikimedia.org/math/f/7/9/f7943e307a891716ca1266a5f5957cdd.png" alt="" /></p>

<p><strong>递推关系：</strong></p>

<p><img src="http://upload.wikimedia.org/math/6/2/1/6217b3c99a3243afcd5d8dbd58186822.png" alt="" /></p>

<p><img src="http://upload.wikimedia.org/math/8/a/4/8a49332e4a46b3a2c7accec81160f5e3.png" alt="" /></p>

<!--more-->

<h3 id="section">组合数学中的应用</h3>

<ol>
  <li>长度2n的dyck word的个数。Dyck word是一个有n个X和n个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。以下为长度为6的dyck words: <code>XXXYYY</code> <code>XYXXYY</code> <code>XYXYXY</code> <code>XXYYXY</code> <code>XXYXYY</code></li>
  <li>将上例的X换成左括号，Y换成右括号，Cn表示所有包含n组括号的合法运算式的个数</li>
  <li>
    <p>Cn表示有n个节点组成不同构二叉树的方案数。下图中，n等于3，圆形表示节点，月牙形表示什么都没有。</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/0/01/Catalan_number_binary_tree_example.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示有2n+1个节点组成不同构满二叉树（full binary tree）的方案数。</p>

    <p>证明：
 令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含n个1、n个0的2n位二进制数共有<img src="http://upload.wikimedia.org/math/c/9/2/c92da943df73dc077dbee5514376346a.png" alt="" />个，下面考虑不满足要求的数目。</p>

    <p>考虑一个含n个1、n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况），则后面的0-1排列中必有n-m个1和n-m-1个0。将2m+2及其以后的部分0变成1、1变成0，则对应一个n+1个0和n-1个1的二进制数。反之亦然（相似的思路证明两者一一对应）。从而：</p>

    <p><img src="http://upload.wikimedia.org/math/4/8/2/4828faf1c29e4b699529f2275cc63453.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示所有在n × n格点中不越过对角线的单调路径的个数。一个单调路径从格点左下角出发，在格点右上角结束，每一步均为向上或向右。计算这种路径的个数等价于计算Dyck word的个数：X代表“向右”，Y代表“向上”。下图为n = 4的情况：</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Catalan_number_4x4_grid_example.svg/450px-Catalan_number_4x4_grid_example.svg.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示通过连结顶点而将n + 2边的凸多边形分成三角形的方法个数。下图中为n = 4的情况：</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Catalan-Hexagons-example.svg/400px-Catalan-Hexagons-example.svg.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示用n个长方形填充一个高度为n的阶梯状图形的方法个数。下图为n = 4的情况：</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Catalan_stairsteps_4.svg/400px-Catalan_stairsteps_4.svg.png" alt="" /></p>
  </li>
</ol>

<h3 id="section-1">面试题</h3>

<p><strong>12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？</strong></p>

<p>我们先把这12个人从低到高排列，然后，选择6个人排在第一排，那么剩下的6个肯定是在第二排。</p>

<p>用0表示对应的人在第一排，用1表示对应的人在第二排，那么含有6个0，6个1的序列，就对应一种方案。问题转换为，这样的满足条件的01序列有多少个。</p>

<p><strong>给乘积X1X,X3……Xn加括号的方法数</strong></p>

<p><strong>n+m个人排队买票，并且满足$n \ge m$，票价为50元，其中n个人各手持一张50元钞票，m个人各手持一张100元钞票，除此之外大家身上没有任何其他的钱币，并且初始时候售票窗口没有钱，问有多少种排队的情况数能够让大家都买到票。</strong></p>

<p>这个题目是Catalan数的变形，不考虑人与人的差异，如果m=n的话那么就是我们初始的Catalan数问题，也就是将手持50元的人看成是+1，手持100元的人看成是-1，任前k个数值的和都非负的序列数。</p>

<p>这个题目区别就在于$n&gt;m$的情况，此时我们仍然可以用原先的证明方法考虑，假设我们要的情况数是$D_{n+m}$，无法让每个人都买到的情况数是$U_{n + m}$，那么就有$D_{n + m} + U_{n +m} = {n + m \choose n}$，此时我们求$U_{n + m}$，我们假设最早买不到票的人编号是k，他手持的是100元并且售票处没有钱，那么将前k个人的钱从50元变成100元，从100元变成50元，这时候就有$n+1$个人手持50元，$m-1$个手持100元的，所以就得到$U_{n + m} = {n + m \choose n + 1}$，于是我们的结果就因此得到了，表达式是$D_{n + m} = {n + m \choose n} - {n + m \choose n + 1}$。</p>

<h2 id="section-2">欧拉函数</h2>

<p>在数论中，对正整数n，欧拉函数$\varphi(n)$是小于或等于n的正整数中与n互质的数的数目。例如$\varphi(8)=4$，因为1,3,5,7均和8互质。</p>

<ul>
  <li>
    <p>$\varphi(1)=1$（小于等于1的正整数中唯一和1互质的数就是1本身）。</p>
  </li>
  <li>
    <p>若$n$是质数$p$的$k$次幂，$\varphi(n)=\varphi(p^k)=p^k-p^{k-1}=(p-1)p^{k-1}$，因为除了$p$的倍数外，其他数都跟$n$互质。</p>
  </li>
  <li>
    <p>若$n = p_1^{k_1} p_2^{k_2} \cdots p_r^{k_r}$, 则$\varphi(n) = \prod_{i=1}^r p_i^{k_i-1}(p_i-1) = \prod_{p\mid n} p^{\alpha_p-1}(p-1) = n\prod_{p|n}\left(1-\frac{1}{p}\right)$。
其中$\alpha_p$是使得$p^{\alpha}$整除$n$的最大整数$\alpha（这里\alpha_{p_i} = k_i）$。</p>

    <p>例如$\varphi(72)=\varphi(2^3\times3^2)=72\times(1 - \frac{1}{2})\times(1 - \frac{1}{3})=24$</p>
  </li>
  <li>
    <p>对任何两个互质的正整数$a, m（即 gcd(a,m) = 1），m\ge2$，有$a^{\varphi(m)} \equiv 1 \pmod m$。即<strong>欧拉定理</strong>。</p>
  </li>
  <li>
    <p>当$m$是质数$p$时，此式则为：$a^{p-1} \equiv 1 \pmod p$。即<strong>费马小定理</strong>。</p>
  </li>
</ul>

<p><strong>欧拉函数的程序:</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="n">phi</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 求素因子</span>
</span><span class="line">            <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">/</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// 运用通项求解欧拉函数</span>
</span><span class="line">            <span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="n">x</span> <span class="o">/=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 每个素因子只计算一次</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">/</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 防质数</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>1-n中所有树的欧拉phi函数值。</strong>并不需要一次计算。可以用与筛法求素数类似的方法，在$O(nloglogn)$时间内计算完毕。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="n">phi_table</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">phi</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// 处理素因子phi[i]</span>
</span><span class="line">                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line">                 <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// 先除后乘，防止中间过程超出范围</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modules in Network Programming]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/04/modules-in-network-programming/"/>
    <updated>2014-08-04T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/04/modules-in-network-programming</id>
    <content type="html"><![CDATA[<p>发现自己总喜欢把各种东西混合在一块，所以这又是一篇长文…</p>

<p>本文将会介绍网络编程中的几种模型，包括<strong>I/O模型、服务器编程模型、事件模型、并发模型</strong>。</p>

<hr />

<h2 id="io">I/O模型</h2>

<p>I/O模型包括<strong>阻塞模型、非阻塞模型、信号量驱动模型、多路复用模型、异步模型</strong>。</p>

<p>总体来说包括两大类：</p>

<ol>
  <li><strong>同步I/O，向程序通知的是I/O就绪事件</strong>，由程序完成读写。包括前四类I/O模型。</li>
  <li><strong>异步I/O，向程序通知的是I/O完成事件</strong>，读写操作由内核完成。</li>
</ol>

<!--more-->

<h3 id="section">阻塞模型</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/06fig01_zpsae5d27ed.gif" alt="" /></p>

<p>在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>

<p>其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用 read 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（read 调用返回）。</p>

<p><strong>阻塞模型在阻塞的时候可能会被信号量中断！！</strong></p>

<h3 id="section-1">非阻塞模型</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/06fig02_zps85e3fe38.gif" alt="" /></p>

<p>非阻塞的实现是I/O命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。这个方法可以引入I/O操作的延时，因为数据在内核中变为可用到用户调用 read 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。</p>

<p>当一个应用程序在一个非阻塞的描述符上反复的调用system call的时候，我们称之为<strong>轮询（polling）</strong>。</p>

<h3 id="io-1">I/O复用模型</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/06fig03_zps1ba406e3.gif" alt="" /></p>

<p>I/O复用模型会用到select或者poll函数，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的是，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>

<h3 id="io-2">信号驱动I/O模型</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/06fig04_zpsb2f0f6ff.gif" alt="" /></p>

<p>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>

<h3 id="io-3">异步I/O模型</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/06fig05_zps636d96a6.gif" alt="" /></p>

<p>调用<code>aio_read</code>函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。</p>

<p>这个操作和信号驱动的区别就是：<strong>异步模式等操作完毕后才通知用户程序而信号驱动模式在数据到来时就通知用户程序。</strong></p>

<h3 id="io-4">几种I/O模型的比较</h3>

<p><img src="http://www.blogjava.net/images/blogjava_net/lihao336/o_untitled6_thumb.png" alt="" /></p>

<h2 id="section-2">服务器编程模型</h2>

<p>有个简单的总结<a href="http://www.cnblogs.com/hnrainll/archive/2011/10/13/2210481.html">http://www.cnblogs.com/hnrainll/archive/2011/10/13/2210481.html</a></p>

<h3 id="section-3">多进程服务器模型</h3>

<p>服务器进程接受连接，fork一个子进程为客户服务，然后等待下一个连接。
多进程模型<strong>适用于单个客户服务需要消耗较多的CPU资源</strong>，例如需要进行大规模或长时间的数据运算或文件访问。多进程模型具有<strong>较好的安全性</strong>。</p>

<pre><code>pid_t pid;
int listenfd, connfd;

listenfd = Socket( ... );
Bind(listenfd, ...);
Listen(listenfd, LISTENQ)

while(1) {
	connfd = Accept(listenfd, ...); /* probably blocks */
	if( (pid = Fork()) == 0 ) {
		Close(listenfd); /* child closes listenning socket */
		process(connfd); /* process the request */
		Close(connfd);   /* done with this client */
		exit(0);		 /* terminate */
	}
	Close(connfd);       /* parent closes connected socket */
}
</code></pre>

<p>需要仔细体会下，为什么父进程要加最后一个<code>Close</code>。</p>

<h3 id="section-4">单线程模型</h3>

<p>具体实现方式在UNP3e第30章中。</p>

<p>在高性能的网络程序中，使用得最为广泛的恐怕要数“non-blocking IO + IO multiplexing”这种模型，即 Reactor 模式。</p>

<p>在“non-blocking IO + IO multiplexing”这种模型下，程序的基本结构是一个事件循环 (event loop)。它的优点很明显，编程简单，效率也不错。不仅网络读写可以用，连接的建立（connect/accept）甚至 DNS 解析都可以用非阻塞方式进行，以提高并发度和吞吐量 (throughput)。<strong>对于 IO 密集的应用是个不错的</strong>。</p>

<h3 id="section-5">多线程模型</h3>

<p>和多进程模型类似，服务器进程接受连接，新建一个线程为客户服务，然后等待下一个连接。和多进程相比，由于进程消耗的资源比线程大的多，因此，<strong>在需要为较多客户端服务的时候，优先使用多线程</strong>。</p>

<p>具体大概有这么几种做法：</p>

<ol>
  <li>每个请求创建一个线程，使用阻塞式 IO 操作。在 Java 1.4 引入 NIO 之前，这是 Java 网络编程的推荐做法。可惜伸缩性不佳。</li>
  <li>使用线程池，同样使用阻塞式 IO 操作。与 1 相比，这是提高性能的措施。</li>
  <li>使用 non-blocking IO + IO multiplexing。即 Java NIO 的方式。non-blocking IO + one loop per thread 模式。</li>
  <li>Leader/Follower 等高级模式</li>
</ol>

<h2 id="section-6">事件处理模型</h2>

<p>一般地,I/O多路复用机制都依赖于一个<strong>事件多路分离器</strong>(Event Demultiplexer)。<u>分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler)</u>。开发人员预先注册需要处理的事件及其<strong>事件处理器</strong>（或回调函数）；事件分离器负责将请求事件传递给事件处理器。两个与事件分离器有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。</p>

<p><strong>Reactor框架中用户定义的操作是在实际操作之前调用的</strong>。比如你定义了操作是要向一个SOCKET写数据，那么当该SOCKET可以接收数据的时候，你的操作就会被调用；而<strong>Proactor框架中用户定义的操作是在实际操作之后调用的</strong>。比如你定义了一个操作要显示从SOCKET中读入的数据，那么当读操作完成以后，你的操作才会被调用。</p>

<h3 id="reactor">Reactor</h3>

<p>在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。</p>

<p><strong>以读操作为例：</strong></p>

<ul>
  <li>注册读就绪事件和相应的事件处理器</li>
  <li>事件分离器等待事件</li>
  <li>事件到来，激活分离器，分离器调用事件对应的处理器。</li>
  <li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/reactor_zpsc844d1e5.png" alt="" /></p>

<h3 id="proactor">Proactor</h3>

<p>在Proactor模式中，处理器–或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。</p>

<p><strong>以读操作为例：</strong></p>

<ul>
  <li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
  <li>事件分离器等待操作完成事件</li>
  <li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li>
  <li>事件分离器呼唤处理器。</li>
  <li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li>
</ul>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/proactor_zpsc40c6bf2.png" alt="" /></p>

<h3 id="section-7">总结</h3>

<p>可以看出，两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。</p>

<h3 id="ioproactor">同步I/O模拟Proactor</h3>

<p>原理：主线程执行数据读写操作，读写完成后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的知识对读写的结果进行逻辑处理。</p>

<p>使用同步I/O模拟出的Proactor模式的工作流程如下：</p>

<ol>
  <li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
  <li>主线程调用<code>epoll_wait</code>等待socket上有数据可读。</li>
  <li>当socket上有数据可读时，<code>epoll_wait</code>通知主线程。主线程从socket循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
  <li>水木在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li>
  <li>主线程调用<code>epoll_wait</code>等待socket可写。</li>
  <li>当socket可写时，<code>epoll_wait</code>通知主线程，主线程往socket上写入服务器处理客户请求结果。</li>
</ol>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/aproactor_zps46fafc76.png" alt="" /></p>

<h2 id="section-8">并发模型</h2>

<h3 id="section-9">半异步、半同步</h3>

<p>半异步、半同步模式是reactor模式的一个进化，非完全异步，而是通过队列把reactor分成了2个部分：同步部分，异步部分。</p>

<p>同步，是因为队列是block的，这部分采用多线程，提高吞吐量
reactor部分是单线程的异步的。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/hahs_zps02b41fb9.png" alt="" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/hahs1_zpsb6c7b413.png" alt="" /></p>

<h3 id="leaderfollower">Leader/Follower</h3>

<p>多线程网络服务最简单的方式就是一个连接一个线程，这种模型当客户端连接数快速增长是就会出现性能瓶颈。当然，这时候，我们理所当然会考虑使用线程池，而任何池的使用，都会带来一个管理和切换的问题。 在java 1.4中引入了NIO编程模型，它采用了Reactor模式，或者说观察者模式，由于它的读写操作都是无阻塞的，使得我们能够只用一个线程处理所有的IO事件，这种处理方式是同步的。为了提高性能，当一个线程收到事件后，会考虑启动一个新的线程去处理，而自己继续等待下一个请求。这里可能会有性能问题，就是把工作交给别一个线程的时候的上下文切换，包括数据拷贝。Leader-Follower模型可以用来解决这个问题。</p>

<p><img src="http://my.csdn.net/uploads/201206/30/1341045549_7751.jpg" alt="" /></p>

<p>所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>

<p>显然地，通过预先分配一个线程池，Leader/Follower设计避免了动态线程创建和销毁的额外开销。将线程放在一个自组织的池中，而且无需交换数据，这种方式将上下文切换、同步、数据移动和动态内存管理的开销都降到了最低。</p>

<p>不过，这种模式在处理短暂的、原子的、反复的和基于事件的动作上可以取得明显的性能提升，比如接收和分发网络事件或者向数据库存储大量数据记录。事件处理程序所提供的服务越多，其体积也就越大，而处理一个请求所需的时间越长，池中的线程占用的资源也就越多，同时也需要更多的线程。相应的，应用程序中其它功能可用的资源也就越少，从而影响到应用程序的总体性能、吞吐量、可扩展性和可用性。</p>

<p>在大多数LEADER/FOLLOWERS设计中共享的事件源封装在一个分配器组件中。如果在一个设计中联合使用了LEADER/FOLLOWERS和REACTOR事件处理基础设施，由reactor组件进行分发。封装事件源将事件分离和分派机制与事件处理程序隔离开来。每个线程有两个方法：一个是join方法，使用这个方法可以把新初始化的线程加入到池中。新加入的线程将自己的执行挂起到线程池监听者条件(monitor condition)上，并开始等待被提升为新的Leader。在它变成一个Leader之后，它便可以访问共享的事件源，等待执行下一个到来的事件。另一个是promote_new_leader方法，当前的Leader线程使用这个方法可以提升新的Leader，其做法是通过线程池监听者条件通知休眠的Follower。收到通知的Follower继续执行(resume)线程池的join方法，访问共享事件源，并等待下一个事件的到来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Probability Problem]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/02/probability-problem/"/>
    <updated>2014-08-02T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/02/probability-problem</id>
    <content type="html"><![CDATA[<p><strong>概念：贝叶斯公式</strong></p>

<p>贝叶斯定理是关于随机事件$A$和$B$的条件概率（或边缘概率）的一则定理。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/BILLOWKILLER-PC/e824b899a9014c086ec5068f097b02087bf4f419_zps22b92ed4.gif" alt="" /></p>

<table>
  <tbody>
    <tr>
      <td>其中$P(A</td>
      <td>B)$是在$B$发生的情况下$A$发生的可能性。</td>
    </tr>
  </tbody>
</table>

<h2 id="section">一、抛硬币问题</h2>

<p><strong>问题1 有一苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面者吃。问先抛这吃到苹果的概率是多少？</strong></p>

<p>假设第一个人吃到苹果的概率是P。第一次抛硬币若为正面则先抛者赢；若为负面且后抛者也为负面，则主动权回到先抛者，回到原问题。</p>

<p>得到关系：P = 1/2 + 1/2 * 1/2 * P  </p>

<p>得出 P = 2/3</p>

<p><strong>问题2 游戏规则为，连续2次抛到硬币朝上，则游戏结束。问平均抛多少次游戏可以结束？</strong></p>

<!--more-->

<p>平均抛多少次，即是求问题的期望。</p>

<p>首先先抛一枚硬币，如果是花，那么需要重头开始；如果是字，那么再抛一枚硬币，新抛的这枚如果也是字，则游戏结束，如果是花，那么又需要重头开始。根据这个过程，设抛硬币的期望次数为T，可以得到关系：T = 1/2(1 + T) + 1/4 * 2 + 1/4(2 + T)</p>

<p>得出 T = 6 </p>

<p><strong>问题3 连续抛 k 次朝上的解法：</strong></p>

<p>假设连续k次正面朝上的期望为Ek，在连续出现k次正面朝上后，下次一也为正面的期望为</p>

<p>E(k+1) = 1/2 (Ek + 1) + 1/2(Ek + 1 + E(k+1))</p>

<p>推到出公式 (E(k+1) +2) /(Ek +2) = 2 得出 Ek = 2^(k+1) -2</p>

<p><strong>问题4 A和B2人投硬币,正面A得1元,反面B得一元.起始时A有1元,B有100元.游戏持续进行,直到其中1人破产才终止.</strong></p>

<ol>
  <li>
    <p>如果硬币正反概率相同,游戏的期待长度(expected duration)是几次投掷?</p>

    <p>目前认为只有奇数次才可能破产。<code>1*0.5 + 3*0.5^3 + 5*0.5^5+...</code></p>
  </li>
  <li>
    <p>如果硬币是不公正的,正面概率为P,反面概率为Q.(P+Q=1), 那么游戏的期待长度(expectedduration)是几次投掷?</p>

    <p>那么问题的答案是计算E(T(n)),即该事件的期望值。</p>

    <p>第1次出现破产的概率是p  //只可能A破产</p>

    <p>第2次出现            0  //因为A第1次赢了1个，共2个了，最多只能输1个，还会剩1个</p>

    <p>第3次出现            <code>q×p×p</code></p>

    <p>第4次出现            0</p>

    <p>第5次                <code>q*q*p*p*p</code></p>

    <p>第99次               q(49次方)×P(50次方)</p>

    <hr />

    <p>在100次以下投掷次数时，不可能是B破产，只有可能是A破产</p>

    <p>第100次时            只有B破产可能  即  q（100次方）</p>

    <p>第101次              q(50次方)×P(51次方) </p>

    <p>第102次              q(102次方)*p</p>

    <p><strong>综上所述，奇数次时，唯A可能破产，偶数次&gt;=100时，唯B可能破产</strong>。</p>

    <p>E（T(n))=<code>∑ n*T(n)  n=1...+∞</code>
         =<code>∑奇数次  +∑偶数次</code>
          =<code>p/(1-p*q)+q(100次方)/(1-P*q)</code></p>

    <p>其中q=1-p
 问题1把p=q=1/2 代入即可。</p>
  </li>
</ol>

<h2 id="section-1">二、骰子问题</h2>

<p><strong>问题1 一个骰子，6面，1个面是 1， 2个面是2， 3个面是3， 问平均掷多少次能使1,2,3都至少出现一次？</strong></p>

<p>这是一个求数学期望的问题，最终是求1，2，3出现至少一次的最短长度的期望。</p>

<p>这样分叉树的每个节点是一个期望状态，而每个分叉是一次投掷结果。将后续期望出现1、2、3各至少一次的情形记作L123（即题目所求），将后续期望出现1、2各至少一次（3无关）情形记作L12，而1至少一次（2，3无关）情形L1，其余数值符号类推，则树结构如下（列出4级结构已经足够）：</p>

<pre><code>           L123
	   /1    |2    \3
      L23    L13    L12
   /1  |2  \3 
  L23  L3   L2
		  /1 |2 \3  
         L2  P2  L3  

L123 = p1 (L23+ 1) + p2 (L13+1) + p3 (L12 + 1) = p1*L23 +p2*L13+ p3*L12 + 1
L23 = p1*L23 +p2*L3+ p3*L2 + 1
L13 = p1*L3 +p2*L13+ p3*L1 + 1
L12 = p1*L2 +p2*L1+ p3*L12 + 1
L1 = p1 + p2*(L1+1) + p3*(L1 +1) =p2*L1+ p3*L1 + 1
L2 = p1*L2 + p3*L2 + 1
L3 = p1*L3 + p2*L3 + 1

解得：
L1 = 6， L2 = 3， L3 = 2
L12 = 7， L13 = 13/2， L23 = 19/56
L123 = 219/30 = 7.3
</code></pre>

<h3 id="section-2">扑克牌问题</h3>

<p><strong>数学证明的随机洗牌算法</strong></p>

<pre><code>for (i = 0; i &lt; N; ++i){
	k = rand() % ( i + 1)
	if (i != k)
		switch(Poker[k], Poker[i]);
}
</code></pre>

<p>分析：</p>

<p>第一次取第一张牌(i=0)保持位置不变。第二次取第二张牌(i=1)，随机生成0-1的随机数k，如果随机生成数不为1，则交换下标为k和i的牌，否则不进行交换。</p>

<p>假设现在取第Z张牌(i = Z - 1)， k= rand()%Z, 如果k!=i则交换下标为k和i的两张牌。</p>

<p>这个算法粗看起来有点像蓄水池抽样的操作方法。这样我们来看一下每张牌出现位置的概率。</p>

<p>第一次计算时第一张牌(i=0)出现在第一个位置的概率为1。</p>

<p>第二次计算时第二张牌(i=1)很明显出现在两个位置中的概率都是1/2。</p>

<p>我们就是要证明第Z（Z&lt;=N)次计算时每张牌出位位置的概率为1/Z。</p>

<p>下面采用归纳法来证明。</p>

<ol>
  <li>
    <p>很明显Z=1时结论成立。</p>
  </li>
  <li>
    <p>假设当Z = K时结论也成立。</p>

    <p>当Z=K+1时，易知第Z张牌出现在任意位置的概率为1/Z。</p>

    <p>前K个数能够保留当前位置的概率为（1 - 1/(K+1)), 那么任意一张牌出现在任意位置的概率为(1/K) *（1 - 1/(K+1)) = 1/(K+1)。</p>
  </li>
  <li>
    <p>同样当Z=N时该算法也成立。</p>
  </li>
</ol>

<h2 id="section-3">其他</h2>

<p><strong>从n个数中生成m个不重复的随机数</strong></p>

<p>对于第一个数，可以用概率m/n选取；但是对于下一个，必须考虑之前的数是否被选取而以(m-1)/(n-1)或m/(n-1)的概率选取。</p>

<p>可用下列代码得到结果：</p>

<pre><code>void random_generate(int n, int m)  
{  
    int i=1,t，remain;  
    while(n-i&gt;m)  
    {  
        t = rand()%(n-i);  
        if(t&lt;m){  
            printf("%d ",i);  
            m--;  
        }  
        i++;  
    }  
    while(++i&lt;=n)printf("%d ",i);  
}  
</code></pre>

<p><strong>利用等概率Rand互换</strong></p>

<pre><code>#Rand5到Rand3
def Rand3():
  x = -1
  while not 0 &lt;= x &lt; 3:
    x = Rand5()
  return x

#Rand5到Rand7
def Rand7():
  x = -1
  while not 0 &lt;= x &lt; 21:
    x = Rand5() * 5 + Rand5()
  return x % 7
</code></pre>

<p><strong>单次遍历，等概率随机选取问题</strong></p>

<p><a href="http://www.gocalf.com/blog/random-selection.html">http://www.gocalf.com/blog/random-selection.html</a></p>

<p><strong>条件概率：两个都是男孩的概率</strong></p>

<p><a href="http://www.gocalf.com/blog/the-probability-of-two-boys.html">http://www.gocalf.com/blog/the-probability-of-two-boys.html</a></p>

<p><strong>平均要取多少个(0,1)中的随机数才能让和超过1</strong></p>

<p><img src="http://hi.csdn.net/attachment/201203/13/0_1331634834uu6L.gif" alt="" /></p>

<p><strong>一个口袋内有10个红色球，20个蓝色球，30个绿色球，你随机地
把球一个一个取出来，请问红色球最先被拿完的概率？也就是当第10个红
色球被取出时，口袋内至少还有一个蓝色球和一个绿色球的概率。</strong></p>

<p>60个球随机排列，红球先取完就等于说后面至少还有一个蓝球，
一个绿球。<strong>如果把这个排列倒过来看，就是说看见红球前先看见
蓝球和绿球</strong>。这样一来就容易了。总共有两种情况，先蓝后绿再
红，或者先绿后蓝再红。</p>

<p>先蓝的概率是<code>1/3</code>，绿红两色中先绿再红的概率是<code>3/4</code> （先蓝以后
其它蓝球不影响绿红的概率）。所以第一种情况的概率是<code>1/3×3/4=1/4</code></p>

<p>先绿的概率是1/2，蓝红两色中先蓝再红的概率是<code>2/3</code> （先绿以后
其它绿球不影响蓝红的概率）。所以第二种情况的概率是<code>1/2×2/3=1/3</code></p>

<p>所以，总概率是<code>1/4+1/3=7/12</code>.</p>

<p>仔细看一看上面的解法，我们会发现红蓝绿球的数量不重要，比例最重
要。也就是说如果有100红，200蓝，300绿，答案还是一样的。</p>

<p><strong>在圆环上随机取N个点，请问这N个点正好都在同一半圆环内的概
率是多少？要注意的是这个半圆环可以是任意半圆环。</strong></p>

<p>起来无从下手，但很多概率组合题都是如此，只要想对了思路就容易了。</p>

<p>一共N个点，固定一个点，从这点开始顺时针，逆时针各有一个半圆，其它N-1个点都落在同
一个（比如顺时针）半圆上的概率是1/2^（N-1). 总共N个点，所以总概率是N/2^（N-1）。</p>

<p><strong>你分别写好5封信给5个朋友，你在5个信封上分别写上他们的地址，
如果你把5封信随机地放进5个信封，请问所有5封信都寄错人的概率是多少？</strong></p>

<p>这题是著名的Derangement问题。关键步骤是要找到递推公式。</p>

<p>如果假设N个人有S_n种 derangement。考虑第N+1个与每一个的交换。我们可以证明<code>S_(n+1) = n*(S_n + S_(n-1))</code></p>

<p>有了这个递推公式以后，可以证明Derangement的概率是<code>p_n = sum((-1)^k/k!, k=0,n)</code></p>

<p>对这道题来说，N=6. 当N趋于无穷大时，<code>p_n趋于e^(-1)</code></p>

<p><strong>一个骰子6面分别是1到6，请问你平均要投多少次才能让每个数字都
投中过？</strong></p>

<p>掷第一次可以得到一个数，第二次掷出不同的数的概率是5/6，所以掷出第
二个数的期望长度是6/5，掷出第三个不同的数的概率是4/6，所以掷出第二
个数的期望长度是6/4，以此类推，所以掷出所有六个数的期望长度是</p>

<pre><code>1+6/5+6/4+6/3+6/2+6/1=6×（1/6+1/5+1/4+1/3+1/2+1/1） = 14.7
</code></pre>

<p>当然这个题也可以推广到任意N面的骰子。
在第一个数已经出现的情况下，抛出第二个数的期望次数是</p>

<pre><code>E(x) = 5/6 + 1/6*5/6*2 + 1/6^2 * 5/6 *3 + 1/6^3 * 5/6 * 4 +....
E(x) = 6/5
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Notes]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/22/network-programming/"/>
    <updated>2014-07-22T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/22/network-programming</id>
    <content type="html"><![CDATA[<p>记录Linux网络编程中的一些知识点…</p>

<hr />

<h3 id="section">网络编程可能会遇到的三种情况</h3>

<ol>
  <li>当<code>fork</code>子进程时，必须捕获<code>SIGCHLD</code>信号。</li>
  <li>当捕获信号时，必须处理被中断的系统调用；</li>
  <li>
    <p><code>SIGCHLD</code>的信号处理函数必须正确编写，应使用<code>waitpid</code>函数以免留下僵死进程。</p>

    <p><code>waitpid</code>是可以非阻塞的等待信号终止，因此可以使用循环调用。</p>
  </li>
</ol>

<!--more-->

<h3 id="socket">网络socket</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/socket_zpsdcdfab1b.png" alt="" /></p>

<p><strong>对应的TCP分组</strong></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/TCP_zpsb7790efe.png" alt="" /></p>

<h3 id="shutdown">shutdown函数</h3>

<p>终止网络连接的通常方法是调用<code>close</code>函数。不过<code>close</code>有两个限制，可以使用<code>shutdown</code>来避免。</p>

<ol>
  <li><code>close</code>把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。使用<code>shutdown</code>可以不管引用计数就激发TCP的正常连接终止序列。</li>
  <li><code>close</code>终止读和写两个方向的数据传送。</li>
</ol>

<p>说明：</p>

<ul>
  <li><code>shutdown</code>根本没有关闭socket,任何与socket关联的资源直到调用closesocket才释放。</li>
  <li>TCP连接的socket是全双工的，也就是说它可以发送和接收数据，但是一个方向上的数据流动和另一个方向上的数据流动是不相关的，shutdown函数的功能也就是体现在这里，它通过设置how选择关闭哪条数据通道(发送通道和接收通道)，如果关闭了发送通道，那么这个socket其实还可以通过接收通道接受数据.</li>
  <li>当通过以how=1(<code>SHUT_WR</code>)的方式调用<code>shutdown</code>，就可以保证对方收到一个EOF，而不管其他的进程是否已经打开了套接字，而调用<code>close</code>或closesocket就不能保证，因为直到套接字的引用计数减为0时才会发送FIN消息给对方，也就是说，直到所有的进程都关闭了套接字。</li>
</ul>

<p><strong>为了保证在连接撤销之前，保证双方都能接收到对等方的所有数据，在调用closesocket之前，先调用shutdown关闭发送数据通道。</strong></p>

<h3 id="tcpclosewait">tcp中close_wait状态出现的原因</h3>

<p><code>close_wait</code>出现的原因: 就是某一方在网络连接断开后，对等方没有检测到这个错误（对方断开）而没有调   用 closesocket，导致了这个状态的出现.</p>

<p>模拟这样一个环境:服务器192.168.1.112:4500在接收到一个客户端的连接后，休眠五秒后，服务器关闭与客户 端通讯的socket后正常退出，而客户端在连接服务器后，等待用户输入字符后，发送给客户端。现在有这样几个问题:</p>

<ol>
  <li>
    <p>服务器在休眠五秒后，正常退出了，但是由于客户端还在等待用户输入，此时服务器端TCP的状态是什么？(<code>FIN_WAIT_2</code>)，客户端的TCP状态是什么?(<code>CLOSE_WAIT</code>)</p>
  </li>
  <li>
    <p>服务器在休眠五秒后，正常退出了，在服务器退出后，如果客户端异常退出，那么服务器端TCP的状态是什么？客户端的TCP状态是什么?</p>
  </li>
</ol>

<pre><code>   在服务器正常退出后，客户端异常退出，那么客户端就会向服务器发送RST标志，然后客户端和服务器端的TCP状态都是`CLOSED`
</code></pre>

<ol>
  <li>服务器在休眠五秒后，正常退出了，在服务器退出后,从客户端输入数据后，向服务器发送，此时服务器怎样处理这个数据?</li>
</ol>

<pre><code>   客户端通过PSH标志向服务器段发送数据，能够发送成功，但因为服务器的TCP处于(`FIN_WAIT_2`)状态，此时服务器会向客户端发送一个RST标示，并且服务器端口状态和客户端的TCP状态都变为`CLOSED`。
</code></pre>

<ol>
  <li>在服务器休眠的过程中，杀死服务器进程，服务器端TCP状态是什么?客户端的TCP状态是什么?</li>
</ol>

<pre><code>在服务器休眠的过程中，杀死服务器进程，此时服务器方会向客户端发送一个RST标志，服务器TCP状态是`CLOSED`，客户端的TCP状态也是`CLOSE`.
在服务器休眠五秒后，如果不关闭与客户端通讯的Socket直接正常退出，此时，服务器方也向客户端发送了RST标志。
</code></pre>

<p>对于上面的四个问题，必须注意到服务器正常断开的时候，向客户端发送的FIN根本不能被客户端的所正常处理，因为客户端正处于接收用户的输入。所以由于每次都是服务器主动断开，但是服务器TCP状态却有可能不能进入到<code>Time_Wait</code>状态。</p>

<h3 id="section-1">服务器终止可能出现的情况</h3>

<ol>
  <li><code>accept、read、write、select、open</code>等慢系统调用中断，系统调用可能返回<code>EINTR</code>错误。需要重启被中断的系统调用。并且编写捕获信号的程序时，必须对慢系统调用返回<code>EINTR</code>有所准备。</li>
  <li>三路握手完成后，客户TCP发送一个RST。服务器进程在调用<code>accept</code>的时候RST到达。accept返回一个错误给服务器进程，POSIX指出返回的errno值必须是<code>ECONNABORTED</code>（“software caused connection abort.”）。服务器忽略它，再次调用accept。</li>
  <li>服务器进程终止。服务端调用<code>kill</code>命令杀死服务器子进程。子进程中所有打开的描述符都被关闭，进而会向客户发送一个FIN，客户TCP则响应一个ACK。而客户进程此时阻塞在<code>fgets</code>调用上。由于FIN的接收并没有告知客户服务器进程已经终止，所以客户进程照常发送数据。此时服务端响应RST。客户进程看不到这个RST，因为它在调用<code>writen</code>后立即调用<code>readline</code>，并且由于接收到FIN，<strong>所调用的readline立即返回0（EOF）</strong>。于是以出错信息（“server terminated prematurely”）退出。</li>
  <li>如果客户不理会<code>readline</code>函数返回的错误，写更多的数据到服务器上。当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个<code>SIGPIPE</code>信号。该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止。</li>
  <li>服务器主机崩溃。客户端到服务端之间网络断掉，或者服务端断电等，物理连接断掉了，这种情况下客户端不会退出（此情况称为<strong>半开连接</strong>），<code>send</code>函数正常执行，不会感觉到自己出错。因为由于物理网络断开，服务端不会给客户端回应错误消息。此时，客户TCP持续重传数据分节，试图从服务器上接收一个ACK。最终返回的错误是<code>ETIMEDOUT</code>。然而如果某个中间路由器判定服务器主机已不可达，从而响应一个“destination unreachable”ICMP消息，那么返回的错误是<code>EHOSTUNREACH</code>或<code>ENETUNREACH</code>。</li>
  <li>服务器主机崩溃后重启。服务进程对客户端<code>send</code>来的消息会产生RST响应。客户收到RST时，客户正阻塞于<code>read</code>调用，导致该调用返回<code>ECONNESET</code>错误。</li>
  <li>服务器主机关机。unix系统关机时，<code>init</code>进程通常先给所有进程发送<code>SIGTERM</code>信号（可捕获），等待固定一段时间后，给所有仍在运行的进程发送<code>SIGKILL</code>信号。接下里就和3一样。</li>
</ol>

<p>下图是检测各种TCP条件的方法</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/2014-08-01183756__zpse1970a67.jpg" alt="" /></p>

<h3 id="solinger">SO_LINGER套接字选项</h3>

<p>在默认情况下，当调用<code>close</code>关闭socket的使用，<code>close</code>会立即返回；但是，如果send buffer中还有数据，系统会试着先把send buffer中的数据发送出去，然后close才返回。</p>

<p><code>SO_LINGER</code>选项则是用来修改这种默认操作的。于SO_LINGER相关联的一个结构体如下:</p>

<pre><code>#include &lt;sys/socket.h&gt;
struct linger {
      int l_onoff  //0=off, nonzero=on(开关)
      int l_linger //linger time(延迟时间)
}
</code></pre>

<p>当调用<code>setsockopt</code>之后,该选项产生的影响取决于<code>linger</code>结构体中<code>l_onoff</code>和<code>l_linger</code>的值:</p>

<ul>
  <li>当<code>l_onoff</code>被设置为0的时候,将会关闭<code>SO_LINGER</code>选项,即TCP或则SCTP保持默认操作:<code>close</code>立即返回、<code>l_linger</code>值被忽略.</li>
  <li><code>l_lineoff</code>值非0，<code>l_linger</code>为0，那么当<code>close</code>某个连接时TCP将终止该连接。send buffer中未被发送的数据将被丢弃,并向对方发送一个RST信息.值得注意的是，由于这种方式，是非正常的4中握手方式结束TCP链接，所以，TCP连接将不会进入<code>TIME_WAIT</code>状态，这样会导致新建立的可能和就连接的数据造成混乱。</li>
</ul>

<p>设置<code>SO_LINGER</code>套接字选项后，<code>close</code>的成功返回只是告诉我们先前发送的数据（和FIN）已由对端TCP确认，而不能告诉我们对端应用进程是否已读取数据。如果不设置该套接字选项，那么我们连对断TCP是否确认了数据都不知道。
让客户知道服务器已读取其数据的一个方法是改为调用<code>shutdown</code>，并设置它的第二个参数为<code>SHUT_WR</code>，而不是调用<code>close</code>。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/1_zps7ad163b0.png" alt="" /></p>

<p>关闭连接的本地端（客户端）时，根据所调用的函数（<code>close</code>和<code>shutdown</code>）以及是否设置了<code>SO_LINGER</code>套接字选项，<strong>可在以下3个不同的时机返回</strong>。</p>

<ol>
  <li><code>close</code>立即返回，根本不等待（默认情况）。</li>
  <li><code>close</code>一直拖延到接受了对于客户端FIN的ACK才返回。</li>
  <li>后跟一个<code>read</code>调用的<code>shutdown</code>一直等到接受对端FIN才返回。</li>
</ol>

<p><strong>下图汇总了对shutdown的两种可能调用和对close的三种可能调用，以及它们对TCP套接字的影响。</strong>
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/_zps2eb27157.png" alt="" /></p>

<h3 id="soreuseaddr">SO_REUSEADDR套接字选项</h3>

<p>SO_REUSEADDR套接字选项能起到以下功能。</p>

<ol>
  <li>
    <p>SO_REUSEADDR允许一个server程序listen监听并bind到一个端口,既是这个端口已经被一个正在运行的连接使用了.</p>

    <p>例如，以下情况：</p>

    <ol>
      <li>一个监听(listen)server已经启动</li>
      <li>当有client有连接请求的时候,server产生一个子进程去处理该client的事物.</li>
      <li>server主进程终止了,但是子进程还在占用该连接处理client的事情.虽然子进程终止了,但是由于子进程没有终止,该socket的引用计数不会为0，所以该socket不会被关闭.</li>
      <li>server程序重启.</li>
    </ol>

    <p><strong>所有的TCP server都必须设定此选项,用以应对server重启的现象.</strong></p>
  </li>
  <li>
    <p>SO_REUSEADDR允许多个server绑定到同一个port上,只要这些server指定的IP不同</p>

    <p>SO_REUSEADDR需要在bind调用之前就设定。另外，还可以在绑定IP通配符。但是最好是先绑定确定的IP，最后绑定通配符IP。运行在这些端口上的服务器实例可以相同，也可以不同。在TCP中，不允许建立起一个已经存在的相同的IP和端口的连接。但是在UDP中，是允许的，特别是在多播中。</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Summary of TCP/IP ILLustrated Volume 1]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/18/TCP-IP/"/>
    <updated>2014-07-18T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/18/TCP-IP</id>
    <content type="html"><![CDATA[<p>Modified from several blogs. Sorry for failing to detailed list.</p>

<hr />

<p>要快速学习一本书，最简单的途径是在网上找一些靠谱的读书笔记、总结之类的博文，然后细细研读，再根据重要的或者未详尽描述的知识点在书中阅读。根据这样的学习方法，总结了《TCP/IP详解 卷1：协议》这本书。</p>

<p>介绍是以图为驱动的，接下来就开始吧。</p>

<h2 id="tcpip">tcp/ip协议簇</h2>

<p><img src="http://dl.iteye.com/upload/attachment/598180/ebd73be4-de65-38cc-adde-514a3d486844.jpg" alt="" /></p>

<!--more-->

<p>上图左侧是数据包在各个网络层的状态，右侧是数据包在各个网络层的传递。其中，以太网口通过以太网地址来决定丢弃还是交付通过以太网口的数据包（此时称为以太网帧）；以太网驱动程序通过检验和来决定将其丢弃还是交付给上一层；接着，驱动程序通过以太网首部中的“类型”字段对以太网帧进行分用，确定这是一个ip数据报，还是一个ARP/RARP请求/应答；如果是后者，则通过协议进行应答；如果是ip数据报，则脱去帧头帧尾，将其交付到Ip层。IP层首先进行检验和计算以决定交付还是丢弃报文，然后通过ip首部中的“协议”字段确定其是UDP数据报、TCP段还是ICMP、IGMP报文，从而对IP数据报进行分用。如果是ICMP或IGMP，则根据协议对其进行处理，如果是TCP或UDP，则去其头部，将其交付到运输层；TCP/UDP则是通过端口号将数据分用到对该端口进行监听的应用程序。</p>

<h2 id="section">链路层</h2>

<h3 id="section-1">以太网帧</h3>

<p><img src="http://dl.iteye.com/upload/attachment/598848/99c6503e-20d5-34f3-976f-8c1fc239d179.jpg" alt="" /></p>

<p>上图是以太网帧的封装格式。其中的“类型”字段正是用于IP数据报、ARP报文和RARP报文的分用。可以看到，每个以太网帧有最小长度和最大长度，最小长度为64字节，是为了检测冲突；最大长度是1518，最大传输单元MTU为1500字节。</p>

<h3 id="arp--rarp">ARP &amp; RARP</h3>

<p>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址。</p>

<p><strong>ARP</strong>（地址解析协议）是设备<strong>通过自己知道的IP地址来获得自己不知道的物理地址</strong>的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，网络上的无盘工作站就是这种情况，设备知道的只是网络接口卡上的物理地址。这种情况下应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。
RARP以与ARP相反的方式工作。<strong>RARP发出要反向解析的物理地址并希望返回其对应的IP地址</strong>，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p>

<p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存，这个高速缓存存放了最近IP地址到硬件地址之间的映射记录。高速缓存中的每一项的生存时间为20分钟，开始时间从被创建时开始算起。可以使用<code>arp -a</code>来检查ARP高速缓存。下图为ARP的分组格式。</p>

<p><img src="http://dl.iteye.com/upload/attachment/599192/e13ec54f-0994-358e-9772-fcfb934e2741.jpg" alt="" /></p>

<ul>
  <li>对于arp请求，其以太网帧首部中的<strong>硬件地址为全1</strong>，<strong>代表广播</strong>，请求主机向它所在的网络广播一份arp请求。</li>
  <li>ARP请求从一个网络发往另一个网络，连接2个网络的路由可以回答该请求，这个过程叫做委托ARP或<strong>代理ARP</strong>。</li>
  <li>arp请求还有另外一个特性叫<strong>免费arp</strong>，它是指主机发送arp查找自己的ip地址。
    <ul>
      <li>一个主机可以通过它来确定另一个主机是否设置了相同的ip地址。检测<strong>网络存在ip冲突</strong>。</li>
      <li>如果发送免费arp的主机正好改变了硬件地址，那么这个分组就可以使其他主机高速缓存中旧的硬件地址<strong>进行相应的更新</strong>。</li>
    </ul>
  </li>
</ul>

<h2 id="section-2">网络层</h2>

<h3 id="ip">IP协议</h3>

<p><strong>IP提供不可靠、无连接的数据报传送服务</strong>。<strong>不可靠是指它不能保证IP数据报能成功地到达目的地</strong>，如果发生某种错误时（如路由器暂时用完了缓冲区），IP有一个简单的处理算法：丢弃该数据报，然后发送ICMP消息给信源端。<strong>无连接的意思是，IP数据报不维护任务关于后续数据报的状态信息</strong>，每个数据报的处理是相互独立的。首先看一下IP数据报的格式：</p>

<p><img src="http://dl.iteye.com/upload/attachment/598868/830a6b5c-cf71-39e2-bd0f-6b5bfa25e2ab.jpg" alt="" /></p>

<p>特地说明下检验和是怎么产生的。TCP和IP协议中都有校验和字段。IP协议根据IP首部计算的检验和码，它不对首部后面的数据进行计算。为了计算一份数据报的IP检验和，首先把检验和字段置为0，然后对首部中每16bit进行二进制反码求和。而TCP、UDP协议的检验和需要对数据进行计算，并且要伪造一个IP头，包括IP地址、报文长度等数据。</p>

<p>IP协议的协议字段包含了被IP包封装了的协议，这个逆过程称为<strong>分用</strong>。包括TCP、UDP、ICMP及IGMP等。</p>

<h3 id="ip-1">IP路由选择</h3>

<p>路由器与主机的本质区别在于，主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据。IP可以从TCP、 UDP、ICMP、IGMP接口数据报（即本地待发送的数据），也可以从一个网络接口接收数据报。IP层在内存中有一个<strong>路由表</strong>，当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数 据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么（1）主机将丢弃报文；（2）路由器对数据报进行转发。</p>

<p>路由表中的每一项包括：(通过<code>netstat -rn</code>可以查到该路由表）</p>

<ol>
  <li>目的IP地址，它既可以是一个完整的主机地址，也可以是一个网络地址，主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的主机。</li>
  <li>下一跳路由器的ip地址，或者有直接连接的网络IP地址。</li>
  <li>标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由是路由器还是一个直接相连的接口。总共有五种不同的标 志：U（该路由可用）、G（该路由是到一个网关）、H（该路由是到一个主机）、D（该路由是由重写向报文创建的）、M（该路由已被重定向报文修改）。</li>
</ol>

<p>IP路由选择主要完成以下这些功能：</p>

<ol>
  <li>搜索路由表，寻找能与目的IP地址完全匹配的表目，如果找到，就把报文发往该地址；</li>
  <li>搜索路由表，寻找能与目的网络号相匹配的表目，如果找到，则把报文发送给该表目指定的下一站路由器直接连接的网络接口；</li>
  <li>搜索路由表，寻找标为“默认”的表目，如果找到，把报文发送给该表目指定的下一站路由器。</li>
</ol>

<p>如果上面这些步骤都没有成功，那么该数据报就不能被发送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。</p>

<p>下图描述了IP层处理过程的简单流程：</p>

<p><img src="http://dl.iteye.com/upload/attachment/599650/5ba5f055-2428-35fa-8791-c03dae480fce.jpg" alt="" /></p>

<p>系统通过三种途径改变路由表的表项，一个是<strong>route命令</strong>，由管理员手动配置路由，一个是<strong>ICMP重定向报文</strong>，这是一种只能由路由器生成的ICMP差错报文，最后一个则是<strong>路由守护程序</strong>，路由守护程序是一个应用程序，它通过发送ICMP路由器请求报文，接收ICMP路由器通告报文来获知相邻的网络情况。</p>

<h3 id="icmp">ICMP</h3>

<p>ICMP是Internet控制报文协议，用于查询和传输出错报告控制信息。</p>

<p>其中<strong>ICMP查询报文</strong>包括：</p>

<ul>
  <li>回显应答/请求， <strong>ping程序使用的报文</strong></li>
  <li>路由器通告/请求，用于IP选路（另一种是RIP路由选择信息协议）</li>
  <li>时间戳请求/应答，允许系统向另一个系统查询当前的时间</li>
  <li>子网掩码请求/应答， 用于无盘系统在引导过程中获取自己的子网掩码</li>
</ul>

<p><strong>ICMP差错报文</strong>：</p>

<ul>
  <li>不可达报文</li>
  <li>超时报文</li>
  <li>重定向差错报文，修改路由表</li>
  <li>源站抑制差错，系统接收数据报的速度大于数据处理的数据</li>
</ul>

<p><strong>ICMP超时+ICMP端口不可达+TTL是traceroute程序的工作原理。</strong>traceroute程序发送一份TTL字段为1的IP数据报文给目的主机，处理这份数据报的第一个路由器将其TTL值减1，丢弃该数据报，并发回一份ICMP超时报文，通过报文中的信源地址我们将得到该路由器的地址；接着，traceroute发送一份TTL值为2的IP数据报文给目的主机，这样，第二个路由器将发回一份ICMP超时报文，….，直到最后该报 文到达目的主机并被接收，那么如何判断报文已经到达目的主机了呢？traceroute将选择一个不可能的值作为目的端口号（大于30000），使目的主机的任何一个应用程序都不可能使用该端口，这样，目的主机收到该报文时，将产生一份“ICMP端口不可达”报文给，这样，当traceroute收到的 ICMP报文是“目的端口不可达”时，可以判断已经完成了整个traceroute的过程。记得IP首部中的“选项”部分还可以设置“严格的源站选路”和 “宽松的源站选路”选项，可以在traceroute发送的IP数据报首部中加入该选项，来规划traceroute的路径。</p>

<h3 id="section-3">互联网的地址、广播、多播</h3>

<p><img src="http://dl.iteye.com/upload/attachment/599740/8fca4629-889a-3533-9abe-bd3915fdbb6f.jpg" alt="" /></p>

<ul>
  <li>A类   0.0.0.0 – 127.255.255.255</li>
  <li>B类 <strong>128</strong>.0.0.0 – 191.255.255.255</li>
  <li>C类 <strong>192</strong>.0.0.0 – 223.255.255.255</li>
  <li>D类 <strong>224</strong>.0.0.0 – 239.255.255.255</li>
  <li>E类 <strong>240</strong>.0.0.0 – 247.255.255.255</li>
</ul>

<p>有三类地址：<strong>单播地址，多播地址和广播地址</strong>。主机号为全0代表网络号，主机号为全1代表在该网络的广播。有<strong>四种广播地址</strong>：</p>

<ol>
  <li>受限的广播地址255.255.255.255.该地址用于主机配置过程中IP数据报的目的地址，在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样数据报仅出现在地址网络中。</li>
  <li>指向网络的广播地址，主机号为全1.如A类广播地址为netid.255.255.255，一个路由器必须转发指向网络的广播。</li>
  <li>指向子网的广播。指向子网的广播地址为主机号为全1且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码，例如，如果路由 器收到发往128.1.2.255的数据报，当B类网络128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但如果该子 网的掩码为255.255.254.0，该地址就不是指向子网的广播地址。</li>
  <li>指向所有子网的广播。指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来，指向所有子网的广播地址的子网号和主机号全为1。例如，如果目的子网掩码为255.255.255.0，那么IP地址128.1.255.255就是一个指向所有子网的广播地址，然而，如 果网络没有划分子网，这就是一个指向网络的广播。</li>
</ol>

<p>广播给网络中的主机产生了很多负担，<strong>广播的数据报要直到UDP层才被确定是否为主机所需要</strong>（没有监听的端口）然后才会被丢弃。多播是介于单播与广播之间的一种方式。</p>

<p>能够接收发往一个特定多播组地址数据的主机集合称为主机组。一个主机组可以跨越多个网络，主机组中成员可以随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。
下图是多播组地址到以太网地址的转换：</p>

<p><img src="http://dl.iteye.com/upload/attachment/599747/65577750-0fa4-3a4c-addd-dcdf7b62e2f9.jpg" alt="" /></p>

<h3 id="igmp">IGMP协议</h3>

<p>Internet组管理协议（IGMP）是因特网协议家族中的一个<strong>组播协议</strong>，用于 IP主机向任一个直接相邻的路由器报告他们的组成员情况。它规定了处于不同网段的主机如何进行多播通信，其前提条件是路由器本身要支持多播。</p>

<p>它用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。IGMP不包括组播路由器之间的组成员关系信息的传播与维护，这部分工作由各组播路由协议完成。</p>

<p>参与IP组播的主机可以在任意位置、任意时间、成员总数不受限制地加入或退出组播组。组播路由器不需要也不可能保存所有主机的成员关系，它只是通过IGMP协议了解每个接口连接的网段上是否存在某个组播组的接收者，即组成员。而主机方只需要保存自己加入了哪些组播组。多播路由器并不关心有多少主机属于一个多播组，它只是想知道给定接口上的多播组是否还有人对这个多播组感兴趣。</p>

<h3 id="section-4">选路协议</h3>

<p>当相邻的路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器之间必须采用选路协议进行通信，这样的协议有很多种，如RIP、OSPF，路由守护进程运行选路协议，并与其相邻的一些路由器进行通信。路由守护程序将选路策略加入到系统中，选择路由并加入到内核的路由表中。如果守护程序发现前往同一信宿存在多条路由，那么它将（以某种方法）选择最佳路由并加入内核路由表中。如果路由守护程序发现一条链路已经断开，它可以删除受影响的路由或加入另一条路由以绕过该问题。</p>

<p>在像Internet这样的系统中，目前采用了许多不同的选路协议。Internet是以一组自治系统的方式组织的，每个自治系统通常由单个实体管 理。常常将一个公司或大学校园定义为一个自治系统。每个自治系统可以选择该自治系统中各个路由器之间的选路协议，这种协议称之为内部网关协议（IGP）， 常用的IGP有RIP和OSPF。不同自治系统的路由器之间进行通信协议称为外部网关协议（BGP）。</p>

<h2 id="section-5">传输层</h2>

<p>终于到了传输层，先来个开胃菜UDP，再介绍TCP。</p>

<h3 id="udp-">UDP 用户数据报协议</h3>
<p>下图是UDP首部的格式：</p>

<p><img src="http://dl.iteye.com/upload/attachment/599727/3174ddc1-a81b-36ea-ac8e-a72a8418188d.jpg" alt="" /></p>

<p>当UDP数据报的长度超过网络的MTU时，必须对其进行分片。如果IP层设置了DF位但是通过某个网络时需要分片，将会产生ICMP“不可达（需要分片）”的差错报文。</p>

<p>分片需要注意的是：(1)在分片时，除最后一片外，其他每一 、片中的数据部分（除IP首部外的其余部分）必须是8整数倍；(2)运输层首部只出现在第一片中。UDP比较简陋，所有包丢失、重传问题都必须由上层应用程序来管理。</p>

<h3 id="tcp-">TCP 传输控制协议</h3>

<p>TCP提供<strong>面向连接的，可靠的</strong>字节流服务， 它设计了各种机制以实现丢包、重发、乱序、链路传输错误等传输过程中可能出现的错误。</p>

<p><strong>1. TCP报文格式</strong></p>

<p><img src="http://dl.iteye.com/upload/attachment/599787/eccadd8c-6160-3bda-837c-704c0d09c0b0.jpg" alt="" /></p>

<p>其中6个标志比特，它们中的多个可以被同时设置为1：</p>

<ul>
  <li>URG：紧急指针有效，与后面的紧急指针结合起来</li>
  <li>ACK：确认序号有效</li>
  <li>PSH：接收方尽快将这个报文段交给应用层</li>
  <li>RST：重建连接</li>
  <li>SYN：同步序号用来发起一个连接</li>
  <li>FIN：发端完成发送任务，将要关闭连接</li>
</ul>

<p>其他字段有：</p>

<ul>
  <li>窗口大小表明接收端当前的接收能力，以字节为单位，16位窗口限制了最大值为65535字节，在选项字段中，有一个窗口刻度选项，允许这个值按比例放大。</li>
  <li>紧急指针是一个正的偏移量，和序号中的值相加表示紧急指针最后一个字节的序号。</li>
  <li>选项字段可以包括<strong>最长报文大小（MSS）</strong>，这是最常见的可选字段。每个连接方通常都在通信的第一个报文段中指明这个选项，表明本端所能接收的最大长度的报文段；还有窗口扩大选项以及时间戳选项。</li>
</ul>

<p><strong>2. 连接与终止</strong></p>

<p><img src="http://dl.iteye.com/upload/attachment/599805/5991ccb8-afaa-3670-9f00-4da6f24a38ea.jpg" alt="" /></p>

<p>tcp连接的其中一方发起主动连接，它填写目的端口和源端口号，初始化序列号，设置SYN位，并设置了mss选项，将该TCP段发给连接的另一方。 另一方收到tcp段后，与主动连接方做了同样的事情，同时携带ACK，把对主动连接方的初始序号加1填入确认序列号字段，发送给主动连接方。主动连接方向 被动连接方发去一个ack，连接由此建立。</p>

<p>图中还演示了连接关闭的过程，终止一个连接需要四次握手。任何一方在最后的发送数据段中设置FIN位来终止这个方向的连接。当一端收到一个FIN， 它必须通知应用层另一端已经终止了那个方向的数据传输，也就是说，不再会有数据从那个方向传来，但它仍然能够发送数据，收到FIN方回复一个ack。</p>

<p>由图我们还可以看到，SYN和FIN各占用了一个序号。</p>

<p>图中的端口A、B还让我们想起一个问题，如果不存在用户进程在监听端口B（<strong>即端口B没有打开</strong>）时，主机A将会收到什么呢？在UDP中，发送端将收到一份ICMP端口不可达报文，那么在TCP连接中呢？TCP使用复位，即在回应发送端的TCP段中设置了RST位，携带ack主动发送端的确认序列号，自己的序列号为0。发送端收到这样的tcp段后，即知道连接被拒绝了。</p>

<p>那如果<strong>主机B根本就不存在</strong>呢？这时主机A将过一段时间再发送一个SYN到主机B请求连接，一般建立一个连接的最长时间限制为75秒。</p>

<p>如果一方已经关闭或导演终止而另一方却不知道，我们将这样的TCP连接称为<strong>半打开</strong>的。比方说在主机A（客户端）上运行telnet程序，通过它和主机B（服务器）连接，由于突然停电，主机A没有向主机B的telnet端口发送FIN消息，结果主机B就以为与主机A的连接还在。主机A重新启动后再次与主机B连接将会启动新的服务器程序，这样<strong>将会导致主机B上产生很多半打开的TCP连接</strong>。如果是服务器主机B突然当掉了，而客户端A并不知道，它继续向主机B发送数据，假如主机B很快恢复了，然而先前的所有连接信息都丢失了，收到来自主机A的消息时，它<strong>回复以RST消息</strong>（相当于没有端口在监听）。</p>

<p>TCP支持同时打开或同时关闭，不过同时打开将经历4次握手。同时关闭进入<code>TIME_WAIT</code>状态，要再经过2MSL超时才关闭。</p>

<p><img src="http://blog.chinaunix.net/photo/91603_100713212857.jpg" alt="同时打开" /></p>

<p><img src="http://blog.chinaunix.net/photo/91603_100713213550.jpg" alt="同时关闭" /></p>

<p><strong>3. TCP的状态变迁</strong></p>

<p><img src="http://blog.chinaunix.net/photo/91603_100707001221.jpg" alt="" /></p>

<p>状态图中比较重要的一点就是，主动关闭方在收到对方的对自己FIN的ACK以及对方的FIN后，进入一个状态叫<code>TIME_WAIT</code>，这种状态也称为<code>2MSL</code> 等待状态。每个TCP实现必须选择一个报文段最大生存时间MSL(Maximum Segment Lifetime)，它是任何报文段被丢弃前在网络内的最长时间。对于一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在<code>TIME_WAIT</code>状态停留的时间为2倍的MSL，<strong>以防这个ACK丢失的时候，可以重发一个ACK（对应另一端收不到ACK重发最后的FIN消息）</strong>。这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务的IP地址和端口号）不能再被使用，这个连接只能在2MSL结束后才能被使用。</p>

<p><img src="http://blog.chinaunix.net/photo/91603_100708211823.jpg" alt="" /></p>

<p><strong><code>TIME_WAIT</code>是执行主动关闭的那一段进入的状态，存在的理由有两个</strong>：</p>

<ol>
  <li>可靠地实现TCP全双工连接的终止，也就是上面的那个理由。</li>
  <li>
    <p>运行老的重复分节在网络中消逝。</p>

    <p>防止上一个连接到达的TCP误解为现在的连接的TCP。<code>TIME_WAIT</code>存在2MSL，而两个方向上的TCP都最多存活MSL秒即被丢弃。</p>
  </li>
</ol>

<p><strong>4. 呼叫连接请求队列</strong></p>

<p>TCP处理呼入连接请求规则:</p>

<ol>
  <li>正等待连接的一端有一个固定长度的连接队列，该队列中的连接已经完成3次握手，但还没有被应用层接收。</li>
  <li>
    <p>应用层指定这个连接队列的最大长度，这个值通常叫做积压值(backlog)。取值范围为0至5的整数。</p>

    <p>不同环境下，backlog的含义与实现都将不同：</p>

    <blockquote>
      <p>The behaviour of the backlog parameter on TCP sockets changed with Linux 2.2. Now it specifies the queue length for completely established sockets waiting to be accepted， instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using the tcp_max_syn_backlog sysctl. When syncookies are enabled there is no logical maximum length and this sysctl setting is ignored.</p>
    </blockquote>
  </li>
  <li>当一个请求连接到达(SYN)，TCP根据连接队列中的连接数确认是否接收这个连接。但这时的最大排队连接数并不等于积压值。</li>
  <li>如果连接队列中的连接数少于最大排队的连接数，TCP将确认建立连接。在客户端主动连接成功而服务端应用层还没接收这个连接时，客户端发送的数据将保存在服务端的TCP缓存队列。</li>
  <li>如果连接队列没有空间，TCP将丢弃收到的SYN请求，不发回任何报文(包括RST)。客户端将超时重传SYN请求，等待连接队列有空间。</li>
</ol>

<p>TCP服务器无法使客户端的主动打开失效。因为服务器接收到请求时，TCP的三次握手已经完成。所以对于限定远程IP地址的服务器，必须在客户端三次握手建立连接后才能判断是否合法。</p>

<p><strong>5. TCP的数据流</strong></p>

<p>建立完连接后，两台主机开始进行数据的传输。传输的数据可以分成两种，一种是<strong>交互式数据的传输</strong>，如通过telnet发送指令；一种是<strong>大量数据的传输</strong>，如通过ftp传输文件。TCP显然需要同时能够处理这两种类型的数据，但使用的算法有所不同。</p>

<p><img src="http://blog.chinaunix.net/photo/91603_100717121935.jpg" alt="交互式输入" /></p>

<p>上图为没有优化的字符输入回显的数据传输过程。一共需要四个报文段。</p>

<p>上图第二，三个报文段可以合并—按键确认和按键回显一起发送。这种技术叫做<strong>经受时延的确认</strong>。
通常TCP在接收到数据时并不立即发送ACK，将以不大于TCP定时器的延时等待是否有数据一起发送，有时也称这种现象为<strong>数据捎带ACK</strong>。</p>

<p>ACK延时等待时间不大于TCP定时器的原因：
假如TCP使用200ms的定时器，该定时器将相对于内核引导的200ms固定时间溢出，由于将要确定的数据随机到达，TCP将在下一次内核的200ms定时器溢出时得到通知，所以ACK实际等待的时间为1~200ms中任一刻。</p>

<p><strong>Nagle算法对发送方要求TCP连接上最多只有一个未被确认的未完成小分组</strong>，在该分组确认到达之前不能发送其他的小分组。且同时TCP收集这些小分组，在确认到达后以一个大的分组发出去。
该算法可以减少网络上的微小分组，降低拥塞出现的可能。但相应的，也会增加更多的时延。流程:</p>

<ol>
  <li>发送端TCP将从应用进程接收到的第一数据块立即发送，不管其大小，哪怕只有一个字节。</li>
  <li>发送端输出第一块数据后开始收集数据，并等待确认。</li>
  <li>确认未达到时，若收集数据达到窗口的一半或一个MSS段，立即发送。</li>
  <li>确认到达后，把缓冲区中的数据组成一个TCP段，然后发送。</li>
</ol>

<p><strong>对于成块的数据流，TCP更应该关注的是流量的控制。</strong>发送端有发送缓冲区（即从应用程序到tcp），接收端有接收缓冲区，并不是接收到的数据马上就能被应用程序处理，如果发送端不断地发送数据，而接收端的缓冲区已经被占满，它必须通知发送端在缓冲区有空隙前，请不要再发送数据了。在TCP中，缓冲区被形象地比喻成一个可以滑动的窗口，TCP通过一些算法来根据窗口的大小发送数据，<strong>滑动窗口协议</strong>。这是端到端的。还有另外一种情况，就是，当发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题，一些中间路由器必须缓冲分区，并有可能耗存储器的空间。因此，连接建立时，双方应该慢慢了解去往对方的路况，然后以一个比较合适的速率大小发送块数据。TCP支持一种被称为“<strong>慢启动</strong>”的算法，该算法通过观察到新分组进入网速的速率应该与另一端返回确认的速率相同而进行工作。慢启动为发送方的TCP增加了另一个窗口：<strong>拥塞窗口</strong>，当与另一个网络建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ack，拥塞窗口就增加一个报文段，发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口是接收方使用的流量控制。</p>

<p><strong>PUSH标志：</strong>如果待发送数据会清空发送缓冲区，该包将自动设置PUSH标志。</p>

<ol>
  <li>发送方将发送缓冲区的数据立即发送给接收方。</li>
  <li>接收方将接收缓冲区的数据立即提交给接收进程。</li>
</ol>

<p><strong>6. TCP的超时与重传</strong></p>

<p><img src="http://blog.chinaunix.net/photo/91603_100803210729.jpg" alt="" /></p>

<ul>
  <li>RTT(往返时间)：指发送端发送TCP报文段开始到接收到对方的确定所使用的时间。</li>
  <li>RTO(超时重传时间)：发送端发送TCP报文段后，在RTO时间内没有收到对方确定，即重传该报文段。</li>
</ul>

<p><strong>拥塞避免算法</strong></p>

<p>拥塞避免算法和慢启动算法通常一起使用。维持两个变量：拥塞窗口( cwnd )  慢启动门限( ssthresh )。</p>

<ol>
  <li>对一个给定的连接，初始化cwnd为1个报文段， ssthresh为65535个字节.</li>
  <li>TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小.拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制.前者是发送方感受到的网络拥塞的估计，后者则与接收方在该连接上的可用缓存大小有关.</li>
  <li>当拥塞发生时(超时或收到重复确认)，ssthresh被设置为当前窗口大小的一半(cwnd和接收方通告窗口大小的最小值，但最少为2个报文段).此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动).</li>
  <li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免.如果cwnd &lt;= ssthresh，则正在进行慢启动，否则正在进行拥塞避免.</li>
</ol>

<p><strong>cwnd增加方式</strong></p>

<ul>
  <li>慢启动初始cwnd为1，每收到一个确定就加1.成指数增长.</li>
  <li>拥塞避免算法在每个RTT内增加 1/cwnd 个报文，成线性增长.</li>
  <li>慢启动根据收到的ACK次数增加cwnd，而拥塞避免算法在一个RTT不管收有多少ACK也只增加一次.</li>
</ul>

<p><strong>快速重传和快速恢复算法</strong></p>

<p>如果收到3个重复ACK，可认为该报文段已经丢失，此时无需等待超时定时器溢出，直接重传丢失的包，这就叫<strong>快速重传算法</strong>.而<strong>接下来执行的不是慢启动而是拥塞避免算法</strong>，这就叫<strong>快速恢复算法</strong>.</p>

<ol>
  <li>当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半.重传丢失的报文段，设置cwnd为ssthresh加上3倍的报文段大小.</li>
  <li>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组(如果新的cwnd允许发送).</li>
  <li>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh(在第1步中设置的值).这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认.另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认.这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半.</li>
</ol>

<p><strong>7. TCP的四个定时器</strong></p>

<p>对每个连接，TCP管理4个不同的定时器：</p>

<ol>
  <li>
    <p><strong>重传定时器</strong>，用于等待另一端的确认。</p>

    <p>当发送端发送出数据后，经过一段时间后假如仍然没有收到接收端的确认，那么就重传该数据块</p>
  </li>
  <li>
    <p><strong>坚持定时器</strong>，使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口</p>

    <p>当接收方的窗口大小为0时，发送方将不能再向它发送数据，直到接收方用一个窗口大小为非0的消息来通告发送端。可是，万一这个消息丢失了呢？接收方就一直这样等着发送方发来数据，而发送端就一直等着接收方发来窗口大于0的消息，两方就都僵在那里了。为了避免这种情况的出现，便有了坚持定时器，<strong>发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。坚持定时器的定时时间也是指数退避的。</strong></p>

    <p><strong>糊涂窗口综合症</strong>是指接收方一旦有非0的窗口大小就向发送方通告，从而引起发送端发送少量的数据这样的情况。可以在任何一方采取措施避免出现这种状况：</p>

    <ol>
      <li>在接收方，接收方不通告小窗口，一般是除非窗口可以增加一个报文段大小或可以增加接收方缓冲区空间的一半，不然通告窗口大小为0.</li>
      <li>在发送方，发送方除非收到一个比较大的窗口（如一个报文段小大、是接收方通告窗口大小一半的报文段）或者是还没有未被确认的数据的情况下，才会发送数据。</li>
    </ol>

    <p>接收方和发送方两方同时进行决策，因为接收方不能通告一个不合理的窗口大小（比方说，原先的窗口大小是1500，报文段长度为1024，发送方发送 了1024字节的数据后，这时候接收方的窗口大小是476，小于一个报文大小，但是如果通告窗口大小为0，岂不是很不合理？），因此在收到这个的窗口通告消息后，就轮到发送方使用它的策略了，发送方设定一个坚持定时器，在这个定时器的时间内，除非收到足够大的通告窗口，否则不发送数据。当然，如果定时器超时了，发送方还是要发送小数据量的报文的。</p>
  </li>
  <li>
    <p><strong>保活定时器</strong>，检测到一个空闲连接的另一端何时崩溃或重启。</p>

    <p>前面我们提到“半打开”的连接，这种情况很可能占用服务器很多端口，因此一般由服务器使用保活选项。如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户主机将必须以下四种状态之一：</p>

    <ol>
      <li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两个小时后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2个小时再复位。</li>
      <li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应，服务器将不能收到对探查的响应，并在75秒后超时。服务器总共发送10个探查，每个间隔75称。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
      <li>客户主机崩溃并且已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li>
      <li>客户主机正常运行，但是从服务器不可达。这跟情况2是一样的。</li>
    </ol>
  </li>
  <li>
    <p><strong>2MSL的时间测量器</strong></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some NB Translations]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/17/Some-NB-translation/"/>
    <updated>2014-07-17T20:07:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/17/Some-NB-translation</id>
    <content type="html"><![CDATA[<ul>
  <li><a href="http://blog.csdn.net/eroswang/article/details/1787456">Unix编程常见问题解答</a></li>
  <li><a href="http://blog.csdn.net/eroswang/article/details/1790351">从程序员角度看ELF</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux thundering herd]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/17/thundering-herd/"/>
    <updated>2014-07-17T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/17/thundering-herd</id>
    <content type="html"><![CDATA[<p><em>modified from <a href="http://blog.csdn.net/russell_tao/article/details/7204260">http://blog.csdn.net/russell_tao/article/details/7204260</a></em></p>

<hr />

<h2 id="section">惊群现象</h2>

<p>什么是“惊群”？简单说来，多线程/多进程（linux下线程进程也没多大区别）等待同一个socket事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p>

<p>惊群通常发生在server 上，当父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。每当用户发起一个TCP连接时，多个子进程同时被唤醒，然后其中一个子进程accept新连接成功，余者皆失败，重新休眠。</p>

<p>那么，我们不能只用一个进程去accept新连接么？然后通过消息队列等同步方式使其他子进程处理这些新建的连接，这样惊群不就避免了？没错，惊群是避免了，但是效率低下，因为这个进程只能用来accept连接。对多核机器来说，仅有一个进程去accept，这也是程序员在自己创造accept瓶颈。所以，我仍然坚持需要多进程处理accept事件。</p>

<h2 id="linux">linux解决的惊群</h2>

<p>其实，在linux2.6内核上，<strong>accept系统调用已经不存在惊群了</strong>（至少我在2.6.18内核版本上已经不存在）。大家可以写个简单的程序试下，在父进程中bind,listen，然后fork出子进程，所有的子进程都accept这个监听句柄。这样，当新连接过来时，大家会发现，仅有一个子进程返回新建的连接，其他子进程继续休眠在accept调用上，没有被唤醒。</p>

<p>对于一些已知的惊群问题，内核开发者增加了一个“<strong>互斥等待</strong>”选项。一个互斥等待的行为与睡眠基本类似，主要的不同点在于：</p>

<ul>
  <li>当一个等待队列入口有 WQ_FLAG_EXCLUSEVE 标志置位, 它被添加到等待队列的尾部. 没有这个标志的入口项, 相反, 添加到开始.</li>
  <li>当 wake_up 被在一个等待队列上调用时, 它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止。也就是说，对于互斥等待的行为，比如如对一个listen后的socket描述符，多线程阻塞accept时，系统内核只会唤醒所有正在等待此时间的队列的第一个，队列中的其他人则继续等待下一次事件的发生，这样就避免的多个线程同时监听同一个socket描述符时的惊群问题。</li>
</ul>

<h2 id="nginx">nginx解决惊群</h2>

<p>但是很不幸，通常我们的程序没那么简单，不会愿意阻塞在accept调用上，我们还有许多其他网络读写事件要处理，linux下我们爱用epoll解决非阻塞socket。所以，即使accept调用没有惊群了，我们也还得处理惊群这事，因为epoll有这问题。上面说的测试程序，如果我们在子进程内不是阻塞调用accept，而是用<code>epoll_wait</code>，就会发现，新连接过来时，多个子进程都会在<code>epoll_wait</code>后被唤醒！</p>

<p>nginx就是这样，master进程监听端口号（例如80），所有的nginx worker进程开始用<code>epoll_wait</code>来处理新事件（linux下），如果不加任何保护，一个新连接来临时，会有多个worker进程在<code>epoll_wait</code>后被唤醒，然后发现自己accept失败。</p>

<p>nginx在同一时刻只允许一个nginx worker在自己的epoll中处理监听句柄。它的负载均衡也很简单，当达到最大connection的7/8时，本worker不会去试图拿accept锁，也不会去处理新连接，这样其他nginx worker进程就更有机会去处理监听句柄，建立新连接了。而且，由于timeout的设定，使得没有拿到锁的worker进程，去拿锁的频繁更高。</p>

<h2 id="nginx-1">nginx的锁</h2>

<p>在用户空间进程间锁实现的原理很简单，就是能弄一个让所有进程共享的东西，比如mmap的内存，比如文件，然后通过这个东西来控制进程的互斥。</p>

<p>nginx的实现分为两种情况：</p>

<ul>
  <li>一种是支持原子操作的情况，也就是由mmap的内存区域来进行控制的</li>
  <li>一种是不支持原子操作，这是是使用文件锁来实现。 </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux reentrant function]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/15/linux-reentrant-function/"/>
    <updated>2014-07-15T06:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/15/linux-reentrant-function</id>
    <content type="html"><![CDATA[<p>这种情况出现在多任务系统当中，在任务执行期间捕捉到信号并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时中断。如果从信号处理程序返回，则继续执行进程断点处的正常指令序列，从重新恢复到断点重新执行的过程中，函数所依赖的环境没有发生改变，就说这个函数是可重入的，反之就是不可重入的。简单来说，<strong>可重入函数可以被中断的函数</strong>。</p>

<p>在进程中断期间，系统会保存和恢复进程的上下文，然而恢复的上下文仅限于返回地址，cpu寄存器等之类的少量上下文，而函数内部使用的诸如全局或静态变量，buffer等并不在保护之列，所以如果这些值在函数被中断期间发生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。打个比方，比如<code>malloc</code>，将如一个进程此时正在执行<code>malloc</code>分配堆空间，此时程序捕捉到信号发生中断，执行信号处理程序中恰好也有一个<code>malloc</code>，这样就会对进程的环境造成破坏，因为malloc通常为它所分配的存储区维护一个链接表，插入执行信号处理函数时，进程可能正在对这张表进行操作，而信号处理函数的调用刚好覆盖了进程的操作，造成错误。</p>

<p><strong>基本上下面的函数是不可重入的：</strong></p>

<ul>
  <li>函数体内使用了静态的数据结构；</li>
  <li>函数体内调用了malloc()或者free()函数；</li>
  <li>函数体内调用了标准I/O函数。</li>
  <li>进行了浮点运算。许多的处理器/编译器中，浮点一般都是不可重入的 （浮点运算大多使用协处理器或者软件模拟来实现）。</li>
</ul>

<p><strong>两种情况需要考虑：</strong></p>

<ol>
  <li>信号处理程序A内外都调用了同一个不可重入函数B；B在执行期间被信号打断，进入A (A中调用了B),完事之后返回B被中断点继续执行，这时B函数的环境可能改变，其结果就不可预料了。</li>
  <li>多线程共享进程内部的资源，如果两个线程A，B调用同一个不可重入函数F，A线程进入F后，线程调度，切换到B，B也执行了F，那么当再次切换到线程A时，其调用F的结果也是不可预料的。</li>
</ol>

<p><strong>在信号处理程序中即使调用可重入函数也有问题要注意</strong>。作为一个通用的规则，当在信号处理程序中调用可重入函数时，应当在其前保存<code>errno</code>，并在其后恢复<code>errno</code>。（<strong>因为每个线程只有一个errno变量，信号处理函数可能会修改其值，要了解经常被捕捉到的信号是SIGCHLD，其信号处理程序通常要调用一种wait函数，而各种wait函数都能改变errno。</strong>）</p>

<p>如果一个函数对多个线程来说是可重入的，则说这个函数是<strong>线程安全的</strong>。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的，那么就可以说函数式<strong>异步-信号安全的</strong>。</p>

<p>一下是来自<em>《深入理解计算机系统》</em>的摘抄：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/threadsafe1_zps14eaee56.png" alt="" />
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/threadsafe2_zpsb753bebc.png" alt="" />
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/threadsafe3_zps6a9ec8f8.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
