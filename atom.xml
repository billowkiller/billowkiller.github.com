<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2016-07-01T15:02:45+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Funny Facts about Rating]]></title>
    <link href="http://billowkiller.github.io/blog/2016/04/09/rating/"/>
    <updated>2016-04-09T16:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2016/04/09/rating</id>
    <content type="html"><![CDATA[<p>本文分析Wilson score confidence interval，它在Reddit评论评分中的应用，另外分析了Hacker News、Reddit的评分算法。先来看下错误的评分。</p>

<p>Case 1: 网站的内容排名，得分高的排前面，得分低的排后面。如何计算得分。</p>

<p><strong>Solution 1:  Score = (Positive ratings) - (Negative ratings)</strong></p>

<u>未考虑内容的受欢迎程度。</u>

<!--more-->

<blockquote>
  <p>Suppose one item has 600 positive ratings and 400 negative ratings: 60% positive. Suppose item two has 5,500 positive ratings and 4,500 negative ratings: 55% positive. This algorithm puts item two above item one.</p>
</blockquote>

<p><strong>Solution 2: Score = Average rating = (Positive ratings) / (Total ratings)</strong></p>

<u>数据较多的时候比较适合，但是数据量少的时候会有比较大的Bias。</u>

<blockquote>
  <p>Average rating works fine if you always have a ton of ratings, but suppose item 1 has 2 positive ratings and 0 negative ratings. Suppose item 2 has 100 positive ratings and 1 negative rating. This algorithm puts item two below item one.</p>
</blockquote>

<p><strong>Correct Solution: Score = Lower bound of <a href="https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Wilson_score_interval">Wilson score confidence interval</a> for a Bernoulli parameter</strong></p>

<u>We need to balance the proportion of positive ratings with the uncertainty of a small number of observations. </u>

<p><img src="http://www.evanmiller.org/images/rating-equation.png" alt="" /></p>

<p>Here $\hat{p}$ is the observed fraction of positive ratings, $z_{\alpha/2}$ is the $(1-\alpha/2)$ quantile of the standard normal distribution, and $n$ is the total number of ratings. </p>

<p>上式适合于二元评分机制，并不适用于例如5-star评分。</p>

<p>Wilson score confidence interval除了排序问题，还可以应用在如下地方：</p>

<ul>
  <li>Detect spam/abuse: What percentage of people who see this item will mark it as spam?</li>
  <li>Create a “best of” list: What percentage of people who see this item will mark it as “best of”?</li>
  <li>Create a “Most emailed” list: What percentage of people who see this page will click “Email”?</li>
</ul>

<h3 id="hacker-news-ranking-algorithm">Hacker News ranking algorithm</h3>

<p>Hacker News由Lisp的一种方言Arc实现，代码现在是开源的。它实现的内容得分公式为：</p>

<script type="math/tex; mode=display">Score = \frac{P-1}{(T+2)^G}</script>

<ul>
  <li>P = points of an item (and -1 is to negate submitters vote)</li>
  <li>T = time since submission (in hours)</li>
  <li>G = Gravity, defaults to 1.8</li>
</ul>

<p>Gravity和Time对内容得分有很大影响：</p>

<ul>
  <li>T增加导致得分降低，这是新闻老化的效果</li>
  <li>当Gravity增加的时候，上述降低会来的更快</li>
</ul>

<p>查看Time和Gravity的影响，在<a href="http://www.wolframalpha.com">Wolfram Alpha</a>的输入框中输入：</p>

<pre><code>plot(
    (30 - 1) / (t + 2)^1.8, 
    (60 - 1) / (t + 2)^1.8,
    (200 - 1) / (t + 2)^1.8
) where t=0..24
</code></pre>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-5-26/75012257.jpg" alt="" /></p>

<pre><code>plot(
    (p - 1) / (t + 2)^1.8, 
    (p - 1) / (t + 2)^0.5,
    (p - 1) / (t + 2)^2.0
) where t=0..24, p=10
</code></pre>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-5-26/43469961.jpg" alt="" /></p>

<h3 id="reddit-ranking-algorithm">Reddit ranking algorithm</h3>

<p>在Hacker News中新闻和评论都是采用同样的评分算法，而在Reddit中，它们采用不同的算法。</p>

<p>Reddit 同样是开源的，并且使用Python实现，为了加速计算，评分算法使用 Pyrex 实现。先来看下新闻的评分算法，hot algorithm：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-5-26/36257254.jpg" alt="" /></p>

<ul>
  <li>同样，submission time对评分的影响很大，人们总是喜欢新鲜的事情</li>
  <li>和Hacker News不同，新闻评分并不会随着时间流逝而降低，虽然它会比较新的新闻得分低。</li>
</ul>

<p>对于同样的votes，但是submission time不同的新闻，它们的得分可以参考：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-5-26/83965192.jpg" alt="" /></p>

<p>公式中的logarithm表示，最开始的votes拥有比较大的权重：开始的10 upvotes和接下的100 upvotes具有相同的权重，接下是 1000 upvotes。这就是upvotes的平滑效果。</p>

<p>比较有意思的是Reddit中的downvotes，它认为具有比较多upvotes和downvotes的新闻代表争议，它们的得分应该会比只有upvotes的新闻得分低。看看downvotes的影响：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-5-26/95155391.jpg" alt="" /></p>

<p>下面看下Reddit的评论的评分算法：</p>

<p>Reddit认为hot algorithm并不适用于comment，原因如下：</p>

<ul>
  <li>In a comment system you want to rank the best comments highest regardless of their submission time</li>
</ul>

<p>Reddit用到我们上面提到过的Wilson score interval，由这个interval得到the confidence sort，解释如下：</p>

<ul>
  <li>The confidence sort treats the vote count as a statistical sampling of a hypothetical full vote by everyone</li>
  <li>The confidence sort gives a comment a provisional ranking that it is 85% sure it will get to</li>
  <li>The more votes, the closer the 85% confidence score gets to the actual score</li>
  <li>Wilson’s interval has good properties for a small number of trials and/or an extreme probability</li>
</ul>

<blockquote>
  <p>If a comment has one upvote and zero downvotes, it has a 100% upvote rate, but since there’s not very much data, the system will keep it near the bottom. But if it has 10 upvotes and only 1 downvote, the system might have enough confidence to place it above something with 40 upvotes and 20 downvotes — figuring that by the time it’s also gotten 40 upvotes, it’s almost certain it will have fewer than 20 downvotes. And the best part is that if it’s wrong (which it is 15% of the time), it will quickly get more data, since the comment with less data is near the top.</p>
</blockquote>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-5-26/41802353.jpg" alt="" /></p>

<h3 id="references">REFERENCES</h3>

<p><a href="http://www.evanmiller.org/how-not-to-sort-by-average-rating.html">How Not To Sort By Average Rating</a></p>

<p><a href="https://medium.com/hacking-and-gonzo/how-hacker-news-ranking-algorithm-works-1d9b0cf2c08d#.utg0mohjf">How Hacker News ranking algorithm works</a></p>

<p><a href="https://medium.com/hacking-and-gonzo/how-reddit-ranking-algorithms-work-ef111e33d0d9#.ub7osc36n">How Reddit ranking algorithms work</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kafka Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2016/04/06/kafka/"/>
    <updated>2016-04-06T14:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2016/04/06/kafka</id>
    <content type="html"><![CDATA[<p>Kafka最早是由LinkedIn开发的一个分布式发布-订阅消息系统，现在已经是Apache的一个开源项目。它具有以下的一些特点：</p>

<ul>
  <li>作为分布式系统，很容易 scale out</li>
  <li>消息以时间复杂度为O(1)的方式持久化到磁盘，支持离线消费和实时消费</li>
  <li>发布和订阅都支持高吞吐量，单机支持每秒100K条以上消息的传输</li>
  <li>支持多个订阅端，并且可以在异常情况下自动对这些消费者进行负载均衡</li>
</ul>

<p>消息系统的好处包括：</p>

<ul>
  <li>解耦生产者和消费者</li>
  <li>持久化直到消息已经被完全处理</li>
  <li>扩展性</li>
  <li>灵活性 &amp; 峰值处理能力</li>
  <li>可恢复性，系统的一部分组件失效时，不会影响到整个系统。</li>
  <li>顺序保证</li>
  <li>缓冲，有助于控制和优化数据流经过系统的速度。</li>
  <li>异步通信</li>
</ul>

<!--more-->

<h2 id="section">名词解释</h2>

<ul>
  <li>
    <p>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker</p>
  </li>
  <li>
    <p>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
  </li>
  <li>
    <p>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</p>
  </li>
  <li>
    <p>Producer：负责发布消息到Kafka broker</p>
  </li>
  <li>
    <p>Consumer：消息消费者，向Kafka broker读取消息的客户端。</p>
  </li>
  <li>
    <p>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
  </li>
</ul>

<h2 id="section-1">架构图</h2>

<p><img src="http://cdn.infoqstatic.com/statics_s1_20160405-0343u1/resource/articles/kafka-analysis-part-1/zh/resources/0310020.png" width="500px" /></p>

<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>

<p><img src="http://cdn.infoqstatic.com/statics_s1_20160405-0343u1/resource/articles/kafka-analysis-part-1/zh/resources/0310025.png" width="500px" /></p>

<p>上图示意消费者和生产者的工作方式。同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。</p>

<p><img src="http://sookocheff.com/img/kafka/kafka-in-a-nutshell/log-anatomy.png" width="500px" /></p>

<p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。每条消息都被append到某个Partition中，具体存储到哪一个Partition是根据Partition机制。如果Partition机制比较合理，不同的消息可以并行写入不同broker的不同Partition里，能极大的提高了吞吐率。另因为磁盘限制，Kafka提供两种策略删除旧数据：一是基于时间，二是基于Partition文件大小。</p>

<h3 id="kafka-delivery-guarantee">Kafka delivery guarantee</h3>

<p>Producer向broker发送消息时，默认情况下一条消息从Producer到broker是确保了 <code>At least once</code>，但如果设置Producer为异步发送则实现 <code>At most once</code>。<code>Exactly once</code>还未实现（生成一种消息主键，幂等重试）。</p>

<p>Consumer在从broker读取消息后，可以选择<code>autocommit</code>或<code>手动commit</code>。区别在于一个是读完消息先commit再处理消息，一个是读完消息先处理再commit。前者实现 <code>At most once</code>，后者实现 <code>At least once</code>，但如果消息的处理有幂等性，则可以理解为<code>Exactly once</code>。如果要做到严格<code>Exactly once</code>，则让offset和操作输入存在同一个地方，保证数据的输出和offset的更新要么都完成，要么都不完成，参考Spark Kafka的DirectAPI的实现。</p>

<h2 id="high-available">High Available</h2>

<p>Kafka的HA包括Data Replication和Leader Election两方面。</p>

<h3 id="data-replication">Data Replication</h3>

<p><img src="http://cdn4.infoqstatic.com/statics_s2_20160405-0343u1/resource/articles/kafka-analysis-part-2/zh/resources/0416000.png" width="500px" /></p>

<p>为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。一个典型的部署方式是一个Topic的Partition数量大于Broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。Kafka分配Replica的算法如下：</p>

<ol>
  <li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li>
  <li>将第i个Partition分配到第（i mod n）个Broker上</li>
  <li>将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上</li>
</ol>

<p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR(in-sync replica)中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW(high watermark)并且向Producer发送ACK。HW会从leader持续发送到follower并被保存到每个broker的磁盘中。</p>

<p>对于Producer而言，它可以选择是否等待消息commit，这可以通过request.required.acks来设置。这种机制确保了只要ISR有一个或以上的Follower，一条被commit的消息就不会丢失。</p>

<p>Consumer读消息也是从Leader读取，只有被commit过的消息（offset低于HW的消息）才会暴露给Consumer。</p>

<h3 id="leader-election">Leader Election</h3>

<p>Kafka在ZooKeeper中动态维护了一个ISR（in-sync replicas），这个ISR里的所有Replica都跟上了leader，只有ISR里的成员才有被选为Leader的可能。在这种模式下，对于f+1个Replica，一个Partition能在保证不丢失已经commit的消息的前提下容忍f个Replica的失败。对比Majority Vote则需要2f+1个Replica。</p>

<p>Kafka中，如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除，包括两种情况：长时间未向leader发送fetch request，消息lag超过阈值。
为了防止ISR里面的慢节点，Producer选择是否被commit阻塞。</p>

<p>选举时候，Kafka会在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。这种方式改善每个follower都使用zk watch的方法进行选举的问题：</p>

<ul>
  <li>brain split</li>
  <li>herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</li>
  <li>ZooKeeper负载过重 </li>
</ul>

<h2 id="kafka-">Kafka 网络模型</h2>

<p>Kafka使用的网络模型是典型的reactor模式，一个acceptor处理新来的连接请求，分配给N个processor处理，每个processor都有selector从socket中读取数据，生成request对象放到requestChannel中。requestChannel包含一个requestQueue和一个responseQueues，requestQueue是一个blocking queue，它的大小为<code>queued.max.requests</code>；responseQueues 包含N个blocking queue，对应每个processor。Kafka会有M个Handler threads用于处理responseQueues中的request，并且生成response放到对应的response队列中，处理过程如下：KafkaRequestHandler循环从RequestChannel中取Request并交给kafka.server.KafkaApis处理具体的业务逻辑。。</p>

<p>这里面涉及的数目在配置文件中都有体现，上述的每个acceptor包括processor在Kafka中称为NIO socket server，数量在<code>listeners</code>中定义，例如<code>PLAINTEXT://myhost:9092, SSL://:9091 </code>。N 取值 <code>background.threads</code>，M 取值 <code>num.io.threads</code>。</p>

<p>在 NIO socket server 中会给每个processor的responseQueue都注册一个ResponseListener，一旦有Response产生就会通知对应的processor发送Response到客户端。</p>

<h2 id="kafka-clients-operations">Kafka Clients’ Operations</h2>

<p>这一章节介绍一个Kafka client对于Kafka Resources可能的操作类型。</p>

<p>Operation包括以下几种：Read, Write, Create, Delete, Alter, Describe, ClusterAction。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-4-12/80246194.jpg" width="450px" /></p>

<p><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-4+-+Command+line+and+centralized+administrative+operations">KIP-4</a></p>

<h3 id="createdelete">Create/Delete</h3>

<p>Create/Delete就是创建和删除Topics。</p>

<p>具体过程如下：</p>

<ol>
  <li>broker发送<code>TopicMetadataRequest</code>到controller。</li>
  <li>Controller在ZooKeeper的/brokers/topics节点上注册Watch，一旦某个Topic被创建或删除，则Controller会通过Watch得到新创建/删除的Topic的Partition/Replica分配。</li>
  <li>对于删除Topic操作，Topic工具会将该Topic名字存于/admin/delete_topics。若delete.topic.enable为true，则Controller注册在/admin/delete_topics上的Watch被fire，Controller通过回调向对应的Broker发送StopReplicaRequest，若为false则Controller不会在/admin/delete_topics上注册Watch，也就不会对该事件作出反应。</li>
  <li>对于创建Topic操作，Controller从/brokers/ids读取当前所有可用的Broker列表，对于set_p中的每一个Partition：
    <ul>
      <li>从分配给该Partition的所有Replica（称为AR）中任选一个可用的Broker作为新的Leader，并将AR设置为新的ISR（因为该Topic是新创建的，所以AR中所有的Replica都没有数据，可认为它们都是同步的，也即都在ISR中，任意一个Replica都可作为Leader）</li>
      <li>将新的Leader和ISR写入/brokers/topics/[topic]/partitions/[partition]</li>
    </ul>
  </li>
  <li>直接通过RPC向相关的Broker发送LeaderAndISRRequest。</li>
</ol>

<p>创建Topic顺序图如下所示。</p>

<p><img src="http://cdn4.infoqstatic.com/statics_s1_20160405-0343u1/resource/articles/kafka-analysis-part-3/zh/resources/0606003.png" width="500px" /></p>

<p>有两点说明：</p>

<ul>
  <li>对于<code>auto.create.topics.enable=false</code>的Kafka，如果对未存在的topic进行produce，则会导致producer <code>org.apache.kafka.common.errors.TimeoutException</code>错误。</li>
  <li>除了使用broker进行创建Topic，还可以通过Kafka的AdminUtils直接指定zk、topic、partitions，replicationFactor，把相关信息写入zk来创建Topic。</li>
</ul>

<h3 id="alterdescribe">Alter/Describe</h3>

<p>alter/describe 是对配置修改或查看的操作，包括Topic和Client两个部分。改变方法也是通过Kafka的AdminUtils和ConfigCommand，指定zk、topic或要修改的properties。</p>

<h3 id="clusteraction">ClusterAction</h3>

<p>包括LeaderAndIsrRequest，StopReplicaRequest，UpdateMetadataRequest，ControlledShutdownRequest</p>

<h3 id="read">Read</h3>

<p>consumer 订阅Topic数据。consumer根据consumer group的分配算法如下</p>

<pre><code>rebalance process for consumer C_i in group G
For each topic T that C_i subscribes to {
 remove partitions owned by C_i from the ownership registry
 read the broker and the consumer registries from Zookeeper
 compute P_T = partitions available in all brokers under topic T
 compute C_T = all consumers in G that subscribe to topic T
 sort P_T and C_T
 let j be the index position of C_i in C_T and let N = |P_T|/|C_T|
 assign partitions from j*N to (j+1)*N - 1 in P_T to consumer C_i
 for each assigned partition p {
 set the owner of p to C_i in the ownership registry
 let O_p = the offset of partition p stored in the offset registry
 invoke a thread to pull data in partition p from offset O_p
 }
}
</code></pre>

<p>当订阅topic的时候，kafka会注册一个<code>ConsumerRebalanceListener</code>，当发生以下任何一个事件的时候，会引发上述的rebalance算法：</p>

<ul>
  <li>Number of partitions change for any of the subscribed list of topics</li>
  <li>Topic is created or deleted</li>
  <li>An existing member of the consumer group dies</li>
  <li>A new member is added to an existing consumer group via the join API</li>
</ul>

<p>Kafka的Consumer API可以透明地处理上述情况，另外还包括server的fail，partition的聚合。</p>

<p>读取数据发生在<code>poll</code>函数中，每次调用时，consumer都会使用上次消费的offset作为这次的起始offset，并且顺序的读取记录。当然上次消费的offset也可以由<code>seek</code>函数直接指定。</p>

<p>读取数据在Kafka内部是一个FetchRequest，处理的过程为
* authorize
* FetchResponse
* recordAndMaybeThrottle(quota控制)</p>

<h3 id="write">Write</h3>

<p>producer 发布数据的动作。produce的api接口可以选择同步或异步，默认情况下<code>send</code>接口是异步的，它将数据放到缓冲区后就立即返回，等到数据到达一定带下后再发送出去，节约IO开销。可以直接在send()后调用get()，这样可以达到同步的效果。另外一个重要的参数是acks，用来设置produce 请求完成的标准，也就是数据要写到几个broker中才算是完成。</p>

<p>发布数据在Kafka内部是一个ProducerRequest，处理过程为：</p>

<ul>
  <li>authorize</li>
  <li>produceResponse</li>
  <li>recordAndMaybeThrottle(quota控制)</li>
</ul>

<h3 id="partition-and-key">Partition and Key</h3>

<p>这里说下partition和key的关系。注意到，在kafka的api中会有一个key的概念，而实际上kafka只是一个消息的订阅和发布系统，和key应该扯不上一点关系，那么这个key有什么用呢，不用key会有什么影响。</p>

<p>看下没有指定key或者key为null的时候kafka是怎么处理的。首先kafka会随机选择一个partition，然后在一个默认的时间（10min）内所有的数据都会写到这个partition内。这会造成数据不均衡的分布在各个partition中。这时可以通过减少metadata refresh interval 缩短这个默认时间来减轻数据不均衡的现象。</p>

<p>不过更实际的还是指定一个key，因为kafka默认的是使用hashing-based partitioner，可能还会造成数据不均衡。这时候就需要使用自定义的partition，并指定<code>partitioner.class</code>。</p>

<h2 id="authorize">Authorize</h2>

<h3 id="authorizer">Authorizer接口</h3>

<p>Kafka带有Authorizer接口，这个是所有实现授权的插件都必须要实现的接口。启动的时候会读<code>authorizer.class</code>配置，<code>authorizer.class</code>就是实现授权的具体类。</p>

<p>Kafka的授权逻辑是<code>Principal P is [Allowed/Denied] Operation O From Host H On Resource R</code>，P是用户，O是上文提到的各种Operation，Host就是client地址，R是Kafka资源，包括cluster、topic、consumer-group。</p>

<p>Kafka本身自带一个<code>SimpleAclAuthorizer</code>，用它来实现一些简单资源的访问，例如</p>

<blockquote>
  <p>Principals User:Bob and User:Alice are allowed to perform Operation Read and Write on Topic Test-Topic from IP 198.51.100.0 and IP 198.51.100.1</p>
</blockquote>

<h3 id="ranger">Ranger</h3>

<p>Ranger的Kafka plugin也是实现了Authorizer接口。Ranger的实现机制简单的介绍下，Ranger整体分为Admin和Plugin：</p>

<ol>
  <li>Ranger Plugin运行在服务进程内，在Kafka中，Ranger plugin代码就运行在broker内。</li>
  <li>Policy通过Ranger Admin存储在database中，plugin轮询地向admin请求最新的policy；policy存储在本地的一个文件中。</li>
  <li>在service请求到来的时候，ranger plugin中的policy engine会evaluate request，判断是否合法。</li>
</ol>

<p>Ranger的policy engine分为role based和tag based，kafka中使用的是tag based，evaluae的流程图如下：</p>

<p><img src="https://cwiki.apache.org/confluence/download/attachments/61322361/Ranger-Policy-Evaluation-Flow-with-Tags.png?version=2&amp;modificationDate=1444869949000&amp;api=v2" width="600px" /></p>

<p>Ranger Kafka 目前支持的功能还是比较少的，如下图：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-4-12/11458053.jpg" width="600px" /></p>

<p>这些功能在Kafka自带的<code>SimpleAclAuthorizer</code>都是可以实现的。</p>

<h2 id="saslkerberos-and-ssl-implementation">Sasl/Kerberos and SSL implementation</h2>

<p>sasl 是broker的认证机制，ssl是数据传输的加密和认证机制。从协议的角度来说，kafka支持以下四种：</p>

<ul>
  <li>
    <p>PLAINTEXT (non-authenticated, non-encrypted)</p>

    <p>This channel will provide exact behavior for communication channels as previous releases</p>
  </li>
  <li>
    <p>SSL</p>

    <p>SSL  implementation. Authenticated principal in the session will be from the certificate presented or the peer host. </p>
  </li>
  <li>
    <p>SASL+PLAINTEXT</p>

    <p>SASL authentication will be used over plaintext channel. Once the sasl authentication established between client and server . Session will have client’s principal as authenticated user. There won’t be any wire encryption in this case as all the channel communication will be over plain text .</p>
  </li>
  <li>
    <p>SASL+SSL</p>

    <p>SSL will be established initially and  SASL authentication will be done over SSL. Once SASL authentication is established users principal will be used as authenticated user .  This option is useful if users want to use SASL authentication ( for example kerberos ) with wire encryption.</p>
  </li>
</ul>

<p>实现SSL需要做如下配置：</p>

<ol>
  <li>Generate SSL key and certificate for each Kafka broker
    <ul>
      <li>Ensure that common name (CN) matches exactly with the fully qualified domain name (FQDN) of the server. The client compares the CN with the DNS domain name to ensure that it is indeed connecting to the desired server, not the malicious one.</li>
    </ul>
  </li>
  <li>Creating your own CA</li>
  <li>Signing the certificate</li>
  <li>Configuring Kafka Brokers</li>
  <li>Configuring Kafka Clients
    <ul>
      <li>需要将生成的<code>kafka.client.truststore.jks</code>拷贝到client</li>
      <li>如果进行双向认证则还需要生成和配置<code>kafka.client.keystore.jks</code></li>
    </ul>
  </li>
</ol>

<p>实现SASL需要：</p>

<ol>
  <li>Kerberos
    <ul>
      <li>客户端需要安装 kerberos client</li>
    </ul>
  </li>
  <li>Create Kerberos Principals
    <ul>
      <li>需要对应的用户principal</li>
    </ul>
  </li>
  <li>Make sure all hosts can be reachable using hostnames</li>
</ol>

<p>具体过程参考<a href="http://kafka.apache.org/documentation.html#security">http://kafka.apache.org/documentation.html#security</a></p>

<p><strong>zookeeper安全性</strong></p>

<ol>
  <li>不开通ibgw（端口），bcc无法直接访问</li>
  <li>zookeeper限制ip段，</li>
  <li>增加zookeeper authentication</li>
</ol>

<p>对每个resource都应该能够实现管理和控制。</p>

<h2 id="references">REFERENCES:</h2>

<p><a href="https://cwiki.apache.org/confluence/display/RANGER/Kafka+Plugin">https://cwiki.apache.org/confluence/display/RANGER/Kafka+Plugin</a></p>

<p><a href="https://kafka.apache.org/090/configuration.html">https://kafka.apache.org/090/configuration.html</a></p>

<p><a href="https://kafka.apache.org/090/ops.html">https://kafka.apache.org/090/ops.html</a></p>

<p><a href="https://kafka.apache.org/090/security.html">https://kafka.apache.org/090/security.html</a></p>

<p><a href="http://kafka.apache.org/documentation.html">http://kafka.apache.org/documentation.html</a></p>

<p><a href="http://people.csail.mit.edu/matei/courses/2015/6.S897/readings/kafka.pdf">Kafka: A distributed messaging system for log processing</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Table Join Semantics]]></title>
    <link href="http://billowkiller.github.io/blog/2016/03/19/table-join/"/>
    <updated>2016-03-19T14:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2016/03/19/table-join</id>
    <content type="html"><![CDATA[<p>这篇文章主要是记录下各种不同 <code>join</code> 的语义。</p>

<p>在最高层面上，<code>join</code> 分为三种：</p>

<ul>
  <li>INNER</li>
  <li>OUTER</li>
  <li>CROSS</li>
</ul>

<!--more-->

<hr />

<ol>
  <li>
    <p><code>INNER JOIN</code> - fetches data if present in both the tables.</p>
  </li>
  <li>
    <p><code>OUTER JOIN</code> are of 3 types:</p>

    <ul>
      <li><code>LEFT OUTER JOIN</code> - fetches data if present in the left table.</li>
      <li><code>RIGHT OUTER JOIN</code> - fetches data if present in the right table.</li>
      <li><code>FULL OUTER JOIN</code> - fetches data if present in either of the two tables.</li>
    </ul>
  </li>
  <li>
    <p><code>CROSS JOIN</code>, as the name suggests, does [n X m] that joins everything to everything. Similar to scenario where we simply lists the tables for joining (in the FROM clause of the SELECT statement), using commas to separate them.</p>
  </li>
</ol>

<p>重点关注前两种，因为在语法中它们包含 <code>join</code> 这个关键词。语法如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;join_type&gt; ::= 
</span><span class="line">    [ { INNER | { { LEFT | RIGHT | FULL } [ OUTER ] } } [ &lt;join_hint&gt; ] ]
</span><span class="line">    JOIN</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>OUTER</code>是一个可选词，有没有对于语义并没有什么区别。解释下上面的语法，可以看到以下的用法是等价的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">A LEFT JOIN B            A LEFT OUTER JOIN B
</span><span class="line">A RIGHT JOIN B           A RIGHT OUTER JOIN B
</span><span class="line">A FULL JOIN B            A FULL OUTER JOIN B
</span><span class="line">A INNER JOIN B           A JOIN B</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://i.stack.imgur.com/qje6o.png" width="500px" /></p>

<p>结果可以看到是这样的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Table A | Table B     Table A | Table B      Table A | Table B      Table A | Table B
</span><span class="line">   1    |   5            1    |   1             1    |   1             1    |   1
</span><span class="line">   2    |   1            2    |   2             2    |   2             2    |   2
</span><span class="line">   3    |   6            3    |  null           3    |  null           -    |   -
</span><span class="line">   4    |   2            4    |  null           4    |  null           -    |   -
</span><span class="line">                        null  |   5             -    |   -            null  |   5
</span><span class="line">                        null  |   6             -    |   -            null  |   6
</span><span class="line">
</span><span class="line">                      OUTER JOIN (FULL)     LEFT OUTER (partial)   RIGHT OUTER (partial)</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark Tunning]]></title>
    <link href="http://billowkiller.github.io/blog/2016/02/01/spark-tunning/"/>
    <updated>2016-02-01T17:23:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2016/02/01/spark-tunning</id>
    <content type="html"><![CDATA[<p>记录一些spark的调优参数</p>

<!--more-->

<ol>
  <li>一个集群有N个节点，每个拥有a cores，mGB的memory
    <ul>
      <li>num-executor N*3-1， 每个节点包含3个executor，AM的那个节点两个</li>
      <li>executor-cores min(5, a-1)</li>
      <li>executor-memory   (m-1)/3 *  (1-spark.yarn.executor.memoryOverhead)，  默认为0.07。</li>
    </ul>
  </li>
  <li>
    <p>driver默认内存改成2G（原先1G）；</p>
  </li>
  <li>
    <p>默认开启预测执行：</p>

 	spark.speculation true
 	spark.speculation.quantile 0.75
 	spark.speculation.multiplier 1.5
  </li>
  <li>
    <p>调高默认parallelism 数量</p>

 	spark.default.parallelism 300
  </li>
  <li>
    <p>调整默认GC策略至G1 GC </p>

    <p>需要测试一些数据来看一下环境里最适合的GC策略，测试结果显示G1没有提升</p>

 	CMS vs parallel GC vs G1 GC
 	G1 GC: InitiatingHeapOccupancyPercent、 ConcGCThreads
  </li>
  <li>
    <p>timeout参数优化</p>

 	spark.core.connection.ack.wait.timeout 
 	spark.core.connection.auth.wait.timeout
 	spark.akka.timeout 
 	spark.akka.askTimeout 
 	spark.shuffle.io.connectionTimeout 
  </li>
  <li>
    <p>frameSize 优化</p>

 	spark.akka.frameSize 100
  </li>
  <li>
    <p>codec 优化</p>

 	spark.io.compression.codec org.apache.spark.io.LZ4CompressionCodec
  </li>
  <li>
    <p>gc log打印</p>

    <pre><code>	-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/var/logs/spark/spark_gc.log   
</code></pre>
  </li>
  <li>heap dump</li>
</ol>

 		-xx:+HeapDumpOnOutOfMemoryError

<ol>
  <li>调整permsize</li>
</ol>

 		–driver-java-options “-XX:MaxPermSize=512m”

<ol>
  <li>
    <p>native lzo</p>
  </li>
  <li>
    <p>减小数据结构内存</p>

    <p>内存少于32G，设置JVM参数-XX:+UseCompressedOops以便将8字节指针修改成4字节，设置JVM参数-XX:+UseCompressedStrings以便采用8比特来编码每一个ASCII字符</p>
  </li>
</ol>

<h3 id="spark-terasort-by-databricks">Spark Terasort by Databricks</h3>

<p>Spark sorted the same data <strong>3X faster using 10X fewer machines</strong>. All the sorting took place on disk (HDFS), without using Spark’s in-memory cache. </p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-7-1/9096505.jpg" width="600px" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extract-Transform-Load Application Scenarios]]></title>
    <link href="http://billowkiller.github.io/blog/2016/01/13/etl/"/>
    <updated>2016-01-13T14:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2016/01/13/etl</id>
    <content type="html"><![CDATA[<h1 id="etl">实时流ETL应用场景</h1>

<p>现有的企业级数据量在不断增大，用户也在寻求大数据解决方案来处理这些日益增长的数据。那么什么是大数据处理的架构呢。Cloudera总结的很好，大数据架构是建立在一系列开发可靠、可扩张、完整的自动化data pipeline上，下面的一张图给了很好的解释：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-1-25/11725472.jpg" width="500px" /></p>

<!--more-->

<p>data pipeline目的在于获取数据并能够发掘其中的价值。数据工程师决定数据从何处来，如何进入数据处理层，以及如何处理，如何存储和进一步展示。当然还需要包括必不可少的集群设计、系统调优等。上图中后端的分析工具通常为BI展示或其他分析工具，中间的处理通常由Spark、Hadoop进行，前端的数据获取包括批量和实时的两种。</p>

<p>在BMR中，我们已经为您处理了底层的集群设计、系统调优，打通数据交互层等工作，您只需要专注于如何在业务上挖掘数据潜在的价值即可。</p>

<h2 id="section">应用场景举例</h2>

<p>百度的IDMapping接入层每天的PV达到上亿，每天产生的日志量达到100GB，日志中的信息包括用户的访问IP、访问时间、响应时间、用户请求、应答内容等。IDMapping由10台nginx服务器构成、分别部署在不同的服务器上。其中的日志格式如下：</p>

<p>数据格式如下：</p>

<pre><code>$remote_addr - [$time_local] "$request" $status $body_bytes_sent "$http_referer"  $http_cookie" $remote_user "$http_user_agent" $request_time  $host $msec
</code></pre>

<p>下面是一条具体日志：</p>

<pre><code>10.81.78.220 - [04/Oct/2015:21:31:22 +0800] "GET /u2bmp.html?dm=37no6.com/003&amp;ac=1510042131161237772&amp;v=y88j6-1.0&amp;rnd=1510042131161237772&amp;ext_y88j6_tid=003&amp;ext_y88j6_uid=1510042131161237772 HTTP/1.1" 200 54 "-" "-" 9CA13069CB4D7B836DC0B8F8FD06F8AF "ImgoTV-iphone/4.5.3.150815 CFNetwork/672.1.13 Darwin/14.0.0" 0.004 test.com.org 1443965482.737
</code></pre>

<p>负责人希望能够通过这些日志信息实时地获取服务的PV、UV等统计信息以及访问用户IP的所在地信息等，并且希望可以查询任意时间的用户访问信息，以此满足日常运营的需求，后续还可能添加告警和日运营报表等功能。</p>

<h2 id="section-1">解决方案</h2>

<p>在BMR中我们集成了Flume、Kafka、Spark、Hbase组件，可以很好的满足应用场景中IDMapping负责人的集群需求。我们设计了如下的大数据处理的pipeline。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-1-26/97268179.jpg" width="750px" /></p>

<p>每台机器上的日志数据通过flume实时地推送到Kafka集群中，在spark集群中订阅这些日志数据，经过ETL处理后存储到Hbase中。前端展示系统可以通过Hbase的Restful接口实时的获取数据。同时，可以提交新的spark streaming application修改原有的数据处理模型，也可以在后端也可以对数据进一步加工：通过集群内部的mahout、spark mllib或对接其他的BI系统，例如Palo、Saiku。</p>

<p>以下是前端获取数据后的展示效果图：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-1-24/88317070.jpg" width="350px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-23/77070404.jpg" width="400px" /></p>

<p>接下来通过三步骤对这个解决方案在BMR中的实现进行详细的阐述。</p>

<h3 id="step-1-">Step 1 创建集群</h3>

<p>创建包括Spark和Streaming组件的集群。在生产环境中建议分别创建Kafka和Spark集群。可以参考<a href="https://bce.baidu.com/doc/BMR/GettingStarted.html#.E5.88.9B.E5.BB.BA.E9.9B.86.E7.BE.A4">文档</a>。</p>

<h3 id="step-2-">Step 2 数据准备</h3>

<p>数据获取表示如何将nginx产生的日志通过flume导入到BMR集群中。我们执行下面的命令：</p>

<pre><code>wget http://bmr.bj.bcebos.com/tools/flume/flume-1.6.0.tar.gz
vim $FLUME_HOME/conf/flume-conf.properties
$FLUME_HOME/bin/flume-ng agent --conf conf --conf-file $FLUME_HOME/conf/flume-conf.properties --name agent
</code></pre>

<p>以上的命令分别表示获取flume、编辑配置文件、运行flume agent。其中配置文件参考<a href="http://wiki.baidu.com/pages/viewpage.action?pageId=158727265">http://wiki.baidu.com/pages/viewpage.action?pageId=158727265</a>，将<code>agent.sources.s.command</code>改为<code>tail $NGINX_HOME/logs/access.log</code>。</p>

<h3 id="step-3-">Step 3 数据处理</h3>
<p>建立新的spark集群，当然在测试阶段您也可以直接使用kafka集群中的spark进行处理，在实际应用中推荐使用新的spark集群。</p>

<ol>
  <li>下载spark streaming代码，进行编译，将编译结果<code>bmr-spark-kafka-samples-1.0-SNAPSHOT-jar-with-dependencies.jar</code>放到bos中。</li>
  <li>
    <p>从console页面进去到对应集群的作业列表页面，然后点击“添加作业”，如果使用系统提供的输入数据和jar包，可以按照如下方式填写参数：</p>

    <blockquote>
      <p>作业类型：Spark</p>
    </blockquote>

    <blockquote>
      <p>名称：FKSTest</p>
    </blockquote>

    <blockquote>
      <p>bos输入地址： bos://${PATH}/bmr-spark-kafka-samples-1.0-SNAPSHOT-jar-with-dependencies.jar</p>
    </blockquote>

    <blockquote>
      <p>失败后操作：继续</p>
    </blockquote>

    <blockquote>
      <p>Spark-submit: –class com.baidubce.bmr.sample.DirectFKSTest</p>
    </blockquote>

    <blockquote>
      <p>应用程序参数：ng1889b62-master-instance-f5lvbago topic</p>
    </blockquote>

    <p>其中应用程序参数分别代表集群master的hostname和kafka topic。 </p>
  </li>
  <li>
    <p>您可以通过集群页面的<code>Resource Manager Web UI</code>查看spark UI查看作业运行的状态。（进入页面所需要的用户名密码会通过短信形式发送到您手机上）
 <img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-1-25/49196148.jpg" alt="" /></p>
  </li>
  <li>
    <p>查看hbase中的数据：</p>

    <pre><code> hbase(main):001:0&gt; list
 hbase(main):002:0&gt; scan 'PVUV', {COLUMN=&gt;['statistics:PV:toInt', 'statistics:UV:toInt']}
</code></pre>
  </li>
</ol>

<h2 id="spark-streaming">关于Spark Streaming中实时流的说明建议</h2>

<p>在Spark Streaming中有两种API用于处理与kafka之间的交互。</p>

<ul>
  <li>一种是spark1.2.0引进的<code>KafkaUtils.createStream</code>，这种方式可以将kafka或其他流式输入先写入磁盘再分片处理，防止重启driver造成数据丢失。换句话说，可以保证At least Once语义，前提是开启<code>Write Ahead Logs</code>，方法如下
    <ul>
      <li>在代码中通过<code>streamingContext.checkpoint</code>配置checkpoint目录</li>
      <li>配置<code>spark.streaming.receiver.writeAheadLog.enable</code>为<code>true</code></li>
    </ul>
  </li>
  <li>另外一种则是spark1.3.0引进的Direct API。这种方式保证的是<code>Exactly Once</code>语义，解决上种方式中<code>consumer offset</code>和数据Logs存储不一致性造成的数据重复计算。这种方式通过将<code>offset</code>存入
checkpoints中，来保证接收数据的一致性。</li>
</ul>

<p>使用<code>KafkaUtils.createStream</code>需要有一下两种考虑：</p>

<ul>
  <li>提高streaming的吞吐量，我们通常会使用多个consumer来并行的获取数据，每个consumer分配到一个executor的单核上，最后将所有得到的Stream进行<code>Union</code>操作。
如果不进行<code>Union</code>则会导致<code>Transformation</code>数量增多<code>#consumer</code>倍。</li>
  <li>另外也要考虑RDD中partition的数量，减少partition数量有助于减少task个数以及调度时间。partition的数量是由batchInterval和spark.streaming.blockInterval共同决定的，根据spark官方指导，通常partition数目
为cores的2到3倍比较合适，所以可以调整适当的参数控制partition的个数。</li>
</ul>

<p>而在DirectAPI中会自动定期的根据kafka的topic+partition查询最新的offset，定义需要处理的offset范围。所以不需要考虑创建多少receivers，也不需要考虑partition的数量。在API中每个kafka partition都是自动地并行读取，并且对应每个RDD partition，从而简化Streaming处理的并行模式。</p>

<p>但是DirectAPI并不会在zookeeper中更新offset，所以基于zookeeper的kafka监控工具无法查看日志处理的进度。但您也可以查询checkpoint，将offset写入zookeeper中。</p>

<p>这两种使用方式在Sample中都有详细的例子可以参考，分别是<code>com.baidubce.bmr.sample.FKSTest</code>和<code>com.baidubce.bmr.sample.DirectFKSTest</code>。</p>

<h2 id="section-2">总结</h2>

<p>虽然针对不同的目标和业务案例使用流式处理的方式也不同，但其主要场景包括：</p>

<ul>
  <li>流ETL——将数据推入存储系统之前对其进行清洗和聚合。</li>
  <li>触发器——实时检测异常行为并触发相关的处理逻辑。</li>
  <li>数据浓缩——将实时数据与静态数据浓缩成更为精炼的数据以用于实时分析。</li>
  <li>复杂会话和持续学习——将与实时会话相关的事件组合起来进行分析。</li>
</ul>

<p>在上述例子中我们介绍了BMR中流ETL的场景。
在BMR中，我们提供了Hadoop生态圈中的全栈组件包括Hadoop、Spark、Hbase、Hive、Pig、Kafka、Mahout等，
您可以根据自己的业务场景灵活地选择不同的组件。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2015/12/20/hadoop-intro/"/>
    <updated>2015-12-20T17:23:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/12/20/hadoop-intro</id>
    <content type="html"><![CDATA[<p>看图说话，用一些图表来记录Hadoop。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/22389512.jpg" width="500px" /></p>

<!--more-->

<h3 id="mapreduce">MapReduce</h3>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/71525619.jpg" width="500px" /></p>

<p>schema-on-read表示hadoop更容易处理非结构化或半结构化的数据，因为可以在数据处理的时候进行解析，因此在加载数据的时候更加轻量化。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/99564088.jpg" width="500px" /></p>

<h3 id="hdfs">HDFS</h3>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/60582298.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/98566811.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/1953976.jpg" width="500px" /></p>

<p>NameNode维护整个文件系统的文件目录树，文件目录的元信息和文件的数据块索引。这些信息以 FSImage 和 EditLog 方式存储在本地文件系统中。 FSImage 是某一时刻的镜像，后续修改都是放在 EditLog 中。 Second NameNode 会间隔将 FSImage 和 EditLog 进行合并后放在 NameNode 上。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/94295030.jpg" width="500px" /></p>

<h3 id="yarn">Yarn</h3>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/80769446.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/31902359.jpg" width="400px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/37369292.jpg" width="500px" /></p>

<h3 id="hadoop-io">HADOOP IO</h3>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/15159126.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/90632065.jpg" width="500px" /></p>

<p>其他流行的兼容Hadoop的序列化框架还有：Avro、Thrift、google protobuf</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/11927837.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/70087429.jpg" width="500px" /></p>

<h3 id="hadoop-jobs">HADOOP JOBS</h3>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/38335644.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/37931472.jpg" width="500px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-29/10857296.jpg" width="500px" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop Tunning]]></title>
    <link href="http://billowkiller.github.io/blog/2015/12/01/hadoop-tunning/"/>
    <updated>2015-12-01T09:50:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/12/01/hadoop-tunning</id>
    <content type="html"><![CDATA[<p>Hadoop的调优涉及到整个MapReduce的各个过程，并且要对每个参数的意义和Counter信息有一定的了解。也就是说，根据Counter的信息推测哪些MapReduce阶段可能存在性能瓶颈，并且根据这个瓶颈理解对应的Hadoop 框架中的处理逻辑，进而可以调整相关参数的大小或程序的行为。</p>

<p>从大面上来看，MapReduce的瓶颈可能存在以下图中的各个部分。</p>

<p><img src="http://ww2.sinaimg.cn/large/74311666jw1eyjx8zpfz2j20rq0cegna.jpg" width="500px" /></p>

<!--more-->

<p>在开始调优之旅前，先来个开胃小菜。进行调优的过程中，我们首先要知道整个job的运行情况。</p>

<p>Hadoop 2中的JobHistory是能够提供作业运行时各个参数指标的展示工具，可以通过这个UI界面查看所有的Counter。另一方面如果不方便通过界面的方式查看，则可以利用Hadoop自带的命令行工具查看，方法是<code>hadoop job -history &lt;history file&gt;</code>, 这个history file的位置通常是在mapreduce.jobhistory.done-dir目录下，可以用如下方式查找<code>hadoop fs -lsr &lt;done-dir&gt; | grep job_1398974791337_0037</code>。</p>

<h2 id="map-optimizations">Map Optimizations</h2>

<p>在Map端的优化通常会涉及到输入的数据和它的处理过程，以及你的应用程序代码。Mapper需要读取作业的输入，输入文件的不同也会影响到作业运行的效率，例如文件是否是splittable，数据的本地性和input split的数量等等。</p>

<h3 id="data-locality">Data Locality</h3>

<p>在分布式计算中有条著名的准则<strong>Pushing compute to the data</strong>，map的task应该尽可能的被安排在数据存放的节点上。可以用Counter来判断作业是否符合这条准则:</p>

<ul>
  <li>HDFS_BYTES_READ：这个值应当不大于input file的block size</li>
  <li>DATA_LOCAL_MAPS：这个值应当为1</li>
  <li>RACK_LOCAL_MAPS：这个值应当为0</li>
</ul>

<p>以下几种情况可能会发生non-local read:</p>

<ul>
  <li>不能分割的大文件，这样mapper就必须从不同的节点中读取blocks。</li>
  <li>文件格式支持split，但是用的input format不对。典型的情况是LZOP格式，需要先建立索引后再进行读取。</li>
  <li>Yarn的调度器不能在某个节点上产生map container，通常是由于集群under load。</li>
</ul>

<p>解决方法是：</p>

<ul>
  <li>尽量保持unsplittable文件的大小接近一个block的大小。</li>
  <li>设置yarn的<code>scheduler.capacity.node-locality-delay</code>，引入跳过的调度次数，来增加map task分配到数据节点上的概率。</li>
  <li>使用Twitter提供的LZO Input Format来处理lzop数据，或者使用bzip2格式的文件。</li>
</ul>

<h3 id="map-number-overwhelm">Map Number Overwhelm</h3>

<p>当输入有很多的input split的时候，每个input split都需要一个mapper来执行，而每个mapper都是一个单独的进程。这样会给调度器和集群带来极大的压力。原因通常有两个：</p>

<ul>
  <li>input data由很多的小文件组成，Hadoop会为每个小文件生成一个mapper，最终时间会大量消耗在启动进程上。</li>
  <li>每个文件并不是很小（和block size相当），但总体的数据量很大，横跨上千个HDFS的blocks。这样每个block也会分配给单独的mapper。</li>
</ul>

<p>如果是第一种情况，可以先聚合这个小文件，或者使用类似avro的文件格式来存储。或者直接用<code>CombineFileInputFormat</code>来处理以上这两种情况，它可以在一个mapper里处理多个HDFS block的数据。<code>CombineFileInputFormat</code>会首先检查input files的所有blocks，简历每个block到data nodes的映射关系，接着将同一个节点上的blocks聚合到一个input split中以保持data locality。它有三个配置项来调整：</p>

<ul>
  <li>mapreduce.input.fileinputformat.split.minsize.per.node</li>
  <li>mapreduce.input.fileinputformat.split.minsize.per.rac</li>
  <li>mapreduce.input.fileinputformat.split.maxsize</li>
</ul>

<p>以上的默认配置会造成每个节点上尽量形成一个最大的input split，影响作业的并行性，可以用以上几个配置来调整。<code>CombineFileInputFormat</code>还包括两个具体的类：</p>

<ul>
  <li><code>CombineTextInputFormat</code></li>
  <li><code>CombineSequenceFileInputFormata</code></li>
</ul>

<h3 id="input-split-computation">Input Split Computation</h3>

<p>如果提交作业的client是在集群局域网之外，那么input split的计算可能带来高成本。</p>

<p>当输入的数据源是HDFS时，client需要做如下事情，包括file listing, file status retrieving，input files数量比较多的时候，整个过程带来数据传输的延迟是比较可观的。</p>

<p>可以通过设置<code>yarn.app.mapreduce.am.compute-splits-in-cluster</code>将input split的计算交给AppMaster处理，这是在集群内部进行的。</p>

<h2 id="shuffle-optimizations">Shuffle Optimizations</h2>

<h3 id="using-the-combiner">Using the Combiner</h3>

<p>combiner可以有效的减少mapper和reducer之间通信的数据量。</p>

<h3 id="using-binary-comparators">Using Binary Comparators</h3>

<p>MapReduce在做sorting或者merging的时候，使用<code>RawComparator</code>比较map output key。内置的<code>Writable</code> classes（<code>Text</code>、<code>IntWritable</code>）有byte-level的比较器，无需将二进制的数据重新组装成实际的对象，所以能够快速进行序列化对象的比较。</p>

<p>用户可以在自己构造的<code>Writable</code>对象里面实现<code>WritableComparable</code>接口，这处理起来会比较容易，但是另一方面要注意MapReduce中map output data是以byte的形式存储的，这会导致在shuffle和sort的阶段需要从byte到object的转化才可以完成对象的比较。</p>

<p>可以看到在Hadoop的内置<code>Writable</code>对象不仅实现了<code>WritableComparable</code>接口，还自定义继承自<code>WritableComparator</code>的比较器。<code>WritableComparator</code>有什么作用呢，可以看下它的一些方法申明。</p>

<pre><code>public class WritableComparator implements RawComparator {
    public int compare(byte[] b1, int s1, int l1,
                       byte[] b2, int s2, int l2); 
}
</code></pre>

<p>可以看到这是byte-level的Comparator，<code>Writable</code>对象正是覆盖了这里面的compare方法。在内置的<code>Writable</code>对象中都实现了<code>WritableComparator</code>，所以无需担心内置对象的效率。但是自己所构造的对象也可以实现<code>WritableComparator</code>方法来提高效率。</p>

<p>例如一个拥有firstName和lastName的Person对象：</p>

<pre><code>private String firstName;
private String lastName;

@Override
public void write(DataOutput out) throws IOException {
    out.writeUTF(lastName);
    out.writeUTF(firstName);
}
</code></pre>

<p><img src="http://i5.tietuku.com/e5eba32886b5773d.png" width="600px" /></p>

<pre><code>public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2,
                     int l2) {
    int lastNameResult = compare(b1, s1, b2, s2);
    if (lastNameResult != 0) {
        return lastNameResult;
    }
    int b1l1 = readUnsignedShort(b1, s1);
    int b2l1 = readUnsignedShort(b2, s2);
    return compare(b1, s1 + b1l1 + 2, b2, s2 + b2l1 + 2);
}

public static int compare(byte[] b1, int s1, byte[] b2, int s2) {
    int b1l1 = readUnsignedShort(b1, s1);
    int b2l1 = readUnsignedShort(b2, s2);
    return compareBytes(b1, s1 + 2, b1l1, b2, s2 + 2, b2l1);
}

public static int readUnsignedShort(byte[] b, int offset) {
    int ch1 = b[offset];
    int ch2 = b[offset + 1];
    return (ch1 &lt;&lt; 8) + (ch2);
}
</code></pre>

<h3 id="tunning-the-shuffle-internals">Tunning the shuffle internals</h3>

<p>在mapper中，output record首先被存储在一个内存buffer中，当这个buffer增长到一定大小的时候，数据被spill到磁盘中的一个文件。整个过程持续到mapper完成所有的output record生成。过程如下：</p>

<p><img src="http://i5.tietuku.com/952140624345e77f.png" width="500px" /></p>

<p>在整个阶段中，I/O相关的splling和merging是最耗时的，所以理想状况应该是所有的output数据都可以装入buffer中，这样只有一个文件被spill到磁盘。这对所有的作业来说自然是不大可能，但是如果mapper可以通过filter或者project的方法减少input data，那么可以好好调整下<code>mapreduce.task.io.sort.mb</code>的大小，因为这个数据直接关系buffer的大小。可以通过检查下面的Counters来调整map端的shuffle：</p>

<ul>
  <li>MAP_OUTPUT_BYTES  用这个数据来估计是否可以调整<code>mapreduce.task.io.sort.mb</code>来装入map的output record</li>
  <li>SPILLED_RECORDS/MAP_OUTPUT_RECORDS  这两个数据的理想情况是一致的，表示只有一个spill发生。</li>
  <li>FILE_BYTES_READ/FILE_BYTES_WRITTEN  比较这两个数据和MAP_OUTPUT_BYTES可以理解在splling和merging阶段发生的读写副作用</li>
</ul>

<p>在reduce方面，map的output通过每个节点上运行的shuffle service进程被发送到对应的reducer。在reducer中，map output是被写入到一个内存buffer中，在数据接收的过程中buffer中的数据被排好序，并在到达一定数据量的时候写入磁盘。同时有一个后台进程负责不断merge这个小的spllied file到merged files中，当所有的fetcher获取了所有的outputs，会有一个最终的merging发生，这时候数据也就从merged files到reducer了。也就是如下图的这个过程：</p>

<p><img src="http://i5.tietuku.com/d11419d045f44d9a.png" width="500px" /></p>

<p>通map端的调优一样，reduce端也是尽量将数据存入内存中，减少splling和merging发生的次数，但是这个过程并不如map端一样明显，因为数据是在边接收边merging的。默认情况下，无论数据是否可以装入内存中，splling总会发生，所以可以调整<code>mapreduce.reduce.merge.memtomem.enabled</code>为true启动memory-to-memory的merge。map端的Counter同样适用于reduce。</p>

<p>以下的参数可以用来调整Hadoop的shuffle行为：</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Default</th>
      <th>Map or Reduce</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mapreduce.task.io.sort.mb</td>
      <td>100 (MB)</td>
      <td>Map</td>
      <td>The total amount of buffer memory in megabytes to use when buffering map outputs. This should be approximately 70% of the map task’s heap size.</td>
    </tr>
    <tr>
      <td>mapreduce.map.sort.spill.percent</td>
      <td>0.8</td>
      <td>Map</td>
      <td>Note that collection will not block if this threshold is exceeded while a spill is already in progress, so spills may be larger than this threshold when it is set to less than 0.5.</td>
    </tr>
    <tr>
      <td>mapreduce.task.io.sort.factor</td>
      <td>10</td>
      <td>Map and Reduce</td>
      <td>The number of streams to merge at once while sorting files. This determines the number of open file handles. Larger clusters with 1,000 or more nodes can bump this up to 100.</td>
    </tr>
    <tr>
      <td>mapreduce.reduce.shuffle.parallelcopies</td>
      <td>5</td>
      <td>Reduce</td>
      <td>The default number of parallel transfers run on the reduce side during the copy (shuffle) phase. Larger clusters with 1,000 or more nodes can bump this up to 20.</td>
    </tr>
    <tr>
      <td>mapreduce.reduce.shuffle.input.buffer.percent</td>
      <td>0.7</td>
      <td>Reduce</td>
      <td>The percentage of memory to be allocated from the maximum heap size to store map outputs during the shuffle.</td>
    </tr>
    <tr>
      <td>mapreduce.reduce.shuffle.merge.percent</td>
      <td>0.66</td>
      <td>Reduce</td>
      <td>The usage threshold at which an in-memory merge will be initiated, expressed as a percentage of the total memory allocated to storing in-memory map outputs, as defined by mapreduce.reduce.shuffle.input.buffer.percent.</td>
    </tr>
    <tr>
      <td>mapreduce.reduce.merge.memtomem.enabled</td>
      <td>false</td>
      <td>Reduce</td>
      <td>If all the map outputs for each reducer can be stored in memory, then set this property to true.</td>
    </tr>
  </tbody>
</table>

<p>Shuffle的原则是使用filter和project减少数据量，使用combiner以及压缩map的output，尽可能的减少mapper和reducer质检传递的数据，减低IO带来的开销。这样之后再利用上述提到的参数来调整Shuffle的过程。</p>

<h2 id="recuder-optimizations">Recuder Optimizations</h2>

<h3 id="the-number-of-reducers">The Number of Reducers</h3>

<p>大多数情况下map端的并行度是由框架根据input files和input format来自动决定的，但在Reduce端，reducer的数量是由用户自行决定的。太少的reducers意味着没能充分利用集群的资源，太多的reducer则会让调度器疲于奔命，如果没有太多的资源供所有reducer运行则会拖累reducer的执行效率。在一些使用场景中，不能避免的需要使用少量的reducer来运行作业，例如数据写入DB系统中。另外一些场景中需要确认数据是否会发生倾斜，以及如何partition的，数据量是否会让reducer发生OOM的情况。</p>

<h2 id="general-tunning-tips">General tunning tips</h2>

<ul>
  <li>压缩</li>
  <li>使用类似于Avro或Parquet的数据格式存储数据，带来的好处是空间利用率，序列化和反序列化更加有效。
    <ul>
      <li>在Hadoop中，text并不是一个有效的数据格式，空间利用率低，解析成本高，特别是用到正则的时候。</li>
      <li>尽可能考虑使用二进制的文件存储格式。</li>
    </ul>
  </li>
</ul>

<h2 id="tunning-tools">Tunning tools</h2>

<h3 id="stack-dumps">stack dumps</h3>

<p>ssh到task运行的机器上，执行下面的命令：</p>

<pre><code>ps aux | grep container_1393242034820_0001_01_000002
kill -s SIGQUIT 554284
kill -s SIGQUIT 554284
kill -s SIGQUIT 554284
</code></pre>

<p><code>SIGQUIT</code>信号的发送应该要间隔几秒，当JVM收到这个信号的时候会执行stack dump，这样可以了解到程序在这段时间内的运行情况。最后可以在task 的output file中查看dump出来的栈信息。</p>

<h3 id="profiling-map-and-reduce-task">Profiling Map and Reduce Task</h3>

<p>可以使用HPROF结合一些Mapreduce job method来进行Profiling。HPROF是JVM内置的java profiling工具，Hadoop内置了对HPROF的支持。可以在driver中加入如下的代码：</p>

<pre><code>job.setProfileEnabled(true);
job.setProfileParams(
    "-agentlib:hprof=depth=8,cpu=samples,heap=sites,force=n," +
        "thread=y,verbose=n,file=%s");
job.setProfileTaskRange(true, "0,1,5-10");
job.setProfileTaskRange(false, "");
</code></pre>

<p>在<code>setProfileParams</code>方法中设置的参数会在每个container中建立一个名为profile.out的文件，这个文件可以很容易被解析。可以通过ssh到目标机器查看或者通过JobHistory UI界面查看。</p>

<p>profile.out包括一些stack traces，还包括内存和CPU时间的信息。以下是一个profile.out文件：</p>

<p><img src="http://i5.tietuku.com/ba1dcbebf426b1a8.png" width="600px" /></p>

<p>可以看出来第一个问题是在<code>String.split</code>这个方法的使用上，它采用正则表达式来分割字符串，这个是相当耗时的一个举措，可以用Apache Commons Lang library的<code>StringUtils.split</code>来替换。另外一个是发生在Text的构造上，可以只构造一个Text实例，采用<code>set</code>方法进行设置，这样会更加有效率。</p>

<p>需要注意，使用HPROF会给程序的执行带来额外的负担，需要持续的收集profiling的信息，所以在正常的运行过程中不应该加上。</p>

<h2 id="conclusion">Conclusion</h2>

<p>一些在工作中实际用到的调优方法：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-30/1330399.jpg" width="900px" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop Secondary Sorting]]></title>
    <link href="http://billowkiller.github.io/blog/2015/11/22/hadoop-secondary-sorting/"/>
    <updated>2015-11-22T17:27:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/11/22/hadoop-secondary-sorting</id>
    <content type="html"><![CDATA[<p>Hadoop MapReduce的神奇之处发生在mapper和reducer之间，将所有相同key的map输出记录聚集在一块，使得用户可以方便的处理聚合在一起的数据。Hadoop内部使用了partition、sort和merge（shuffle的一部分），在每个reducer中流式地得到排序后的key和value集合。在MapReduce Sorting中有个特别的部分是secondary sort，也就是对value进行排序。</p>

<!--more-->

<p>Secondary sort在两种情况下特别有用：</p>

<ul>
  <li>需要某一部分的数据比其他数据更快的到达reducer。</li>
  <li>希望job的输出按照两个key进行排序。</li>
</ul>

<p>实现Secondary sort需要对MapReduce中的数据流和处理有一定的了解，下图展示了对reducer中出现的数据有影响的三个部分。</p>

<p><img src="http://i5.tietuku.com/7ad3ad872415c4b6.png" width="600px" /></p>

<p><code>partitioner</code>决定哪个reducer接收该mapper数据记录；<code>sorting RawComparator</code>用于在各自的分片中排序输出的结果，map和reduce阶段都有它，其中map阶段的sorting是对reduce阶段sorting的一个优化，让reducer的sorting更高效；最后，<code>grouping RawComparator</code>用于决定reducer处理排序后记录的边界，发生在reducer从本地磁盘读取数据的时候，也就是说，你可以用这个方法决定数据记录是如何聚集起来调用一个reduce方法的。MapReduce默认把这个三个方法作用于map方法输出的key上。</p>

<p>要实现Secondary sorting，我们需要重写partitioner、sort comparator和grouping comparator。</p>

<p>下面，通过对人名的排序来说明如何使用Secondary sorting。使用primary sort排序last name，secondary sort排序first name。</p>

<p>我们需要构建一个由map方法输出的Composite key，这个key由两部分组成：</p>

<ul>
  <li>Natural Key</li>
  <li>Secondary Key</li>
</ul>

<p><img src="http://i5.tietuku.com/25eedf0319e92775.png" width="430px" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="n">WritableComparable</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="kd">private</span> <span class="n">String</span> <span class="n">firstName</span><span class="o">;</span>
</span><span class="line">  <span class="kd">private</span> <span class="n">String</span> <span class="n">lastName</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFields</span><span class="o">(</span><span class="n">DataInput</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">firstName</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">lastName</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">DataOutput</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">    <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="n">firstName</span><span class="o">);</span>
</span><span class="line">    <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="n">lastName</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下图说明hadoop框架配置中用于设置partitioning、sorting和grouping类的名字和方法。</p>

<p><img src="http://i5.tietuku.com/520e7242cd6ecc43.png" width="530px" /></p>

<h3 id="partitioner">Partitioner</h3>

<p>默认的partitioner使用对key进行hash后取reducer个数的模。但是默认的partitioner使用整个key，会导致相同的natural key发往不同的reducer。所以需要实现自己的partitioner。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonNamePartitioner</span> <span class="kd">extends</span>
</span><span class="line">    <span class="n">Partitioner</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getPartition</span><span class="o">(</span><span class="n">Person</span> <span class="n">key</span><span class="o">,</span> <span class="n">Text</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numPartitions</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">*</span> <span class="mi">127</span><span class="o">)</span> <span class="o">%</span>
</span><span class="line">        <span class="n">numPartitions</span><span class="o">;</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="sorting">Sorting</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonComparator</span> <span class="kd">extends</span> <span class="n">WritableComparator</span> <span class="o">{</span>
</span><span class="line">  <span class="kd">protected</span> <span class="nf">PersonComparator</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="kd">super</span><span class="o">(</span><span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">WritableComparable</span> <span class="n">w1</span><span class="o">,</span> <span class="n">WritableComparable</span> <span class="n">w2</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">w1</span><span class="o">;</span>
</span><span class="line">    <span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">w2</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span> <span class="n">cmp</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">());</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="grouping">grouping</h3>

<p>grouping阶段所有的数据记录已经是secondary sort了，grouping comparator需要将相同的last name聚合在一起。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonNameComparator</span> <span class="kd">extends</span> <span class="n">WritableComparator</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="kd">protected</span> <span class="nf">PersonNameComparator</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="kd">super</span><span class="o">(</span><span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">WritableComparable</span> <span class="n">o1</span><span class="o">,</span> <span class="n">WritableComparable</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o1</span><span class="o">;</span>
</span><span class="line">    <span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o2</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="mapreduce">MapReduce</h3>

<p>最后在driver中，需要设置上文提到的三个类：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">job</span><span class="o">.</span><span class="na">setPartitionerClass</span><span class="o">(</span><span class="n">PersonNamePartitioner</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line"><span class="n">job</span><span class="o">.</span><span class="na">setSortComparatorClass</span><span class="o">(</span><span class="n">PersonComparator</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line"><span class="n">job</span><span class="o">.</span><span class="na">setGroupingComparatorClass</span><span class="o">(</span><span class="n">PersonNameComparator</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line">
</span><span class="line"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Map</span> <span class="kd">extends</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Person</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">  <span class="kd">private</span> <span class="n">Person</span> <span class="n">outputKey</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(</span><span class="n">Text</span> <span class="n">lastName</span><span class="o">,</span> <span class="n">Text</span> <span class="n">firstName</span><span class="o">,</span> <span class="n">Context</span> <span class="n">context</span><span class="o">)</span>
</span><span class="line">      <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">    <span class="n">outputKey</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">lastName</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">firstName</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class="line">    <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">outputKey</span><span class="o">,</span> <span class="n">firstName</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Reduce</span> <span class="kd">extends</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="n">Text</span> <span class="n">lastName</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Text</span><span class="o">();</span>
</span><span class="line">  <span class="nd">@Override</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Person</span> <span class="n">key</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span>
</span><span class="line">                     <span class="n">Context</span> <span class="n">context</span><span class="o">)</span>
</span><span class="line">      <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">    <span class="n">lastName</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class="line">    <span class="k">for</span> <span class="o">(</span><span class="n">Text</span> <span class="n">firstName</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">lastName</span><span class="o">,</span> <span class="n">firstName</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Secondary sort涉及到的自定义的partitioner、sorter和grouper，还是比较复杂的。可以考虑<a href="http://htuple.org">htuple</a>对简单类型进行secondary sort。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark Streaming]]></title>
    <link href="http://billowkiller.github.io/blog/2015/10/27/spark-streaming/"/>
    <updated>2015-10-27T21:04:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/10/27/spark-streaming</id>
    <content type="html"><![CDATA[<p>流式计算通常是为了满足日益增长的数据的实时获取和低延时计算的需求。通常来说，一个优秀的流式计算引擎需要满足一下的一些需求：</p>

<ol>
  <li>不重不丢的保证（在节点或计算失败的时候，内存中的计算状态能被正确的恢复）</li>
  <li>低延迟</li>
  <li>高吞吐量</li>
  <li>强大的计算模型</li>
  <li>容错机制的低开销</li>
  <li>流控</li>
</ol>

<p><img src="http://spark.apache.org/images/spark-logo.png" alt="image" />
<!--more--></p>

<p>介绍完了spark后就可以来说说spark streaming，毕竟spark streaming是完全构建在spark之上，熟悉了spark的RDD原理之后就比较容易理解spark streaming。说白了，spark streaming中的流式计算是伪实时的，之所以是伪实时的是因为它将实时的处理变成时间跨度较小的批量处理。没错，就是将一段时间间隔中的数据变成RDD，然后利用spark原有的架构处理这段时间内的数据，接着在时间维度上对这些处理后的RDD进行迭代计算。也就是将流式计算分解为一系列微小的、原子的批量作业，每个微批量作业如果失败则可以重新计算。这种分解的思想可以应用在批量计算框架、也可以应用在流式计算框架上，例如Storm Trident。</p>

<p>这样的处理带来了几个明显的好处：</p>

<ul>
  <li>高吞吐量</li>
  <li>不从不丢的保证</li>
  <li>快速falut recovery</li>
  <li>更方便处理慢节点</li>
  <li>实时和批量统一的编程接口</li>
</ul>

<p>下面介绍下spark streaming中的具体实现来理解这几点。</p>

<h3 id="section">计算模型</h3>

<p><img src="http://blog.selfup.cn/wp-content/uploads/2014/08/streaming-flow.png" alt="image" /></p>

<p>首先，Spark Streaming把实时输入数据流以时间片（如1秒）为单位切分成块。Spark Streaming会把每块数据作为一个RDD，并使用RDD操作处理每一小块数据。每个块都会生成一个Spark Job处理，最终结果也返回多块。</p>

<p>举个栗子来说明下这个过程：</p>

<pre><code>pageViews = readStream("http://..."， “ls”)
ones = pageViews.map(event =&gt; (event.url, 1))
counts = ones.runningReduce((a, b) =&gt; a+b)
</code></pre>

<p>上述代码的作用是根据URL的数量计算访问次数。处理的过程为首先通过HTTP获取到一个pageview事件的RDD，经过<em>transformation</em>操作变成(URL, 1), 最后的操作计算相同的URL数目。整个streaming过程可以用下图来表示：
<img src="http://img-storage.qiniudn.com/15-10-18/95269436.jpg" alt="" /></p>

<p>整个的处理过程可以看出，输入流被分成每个都是1秒的batch，经过处理后生成resultRDD，这个resultRDD在每个时间间隔中都会产生一个，并经过reduce迭代计算。在上图中最终的reduce的输入参数就包括上一个时间间隔的resultRDD和这个时间间隔中map操作的结果。上图也可以看出这些RDD的lineage graph，在节点失败的时候，可以根据这个lineage graph以partition的粒度为单位重新执行任务计算丢失的分片，可以看出这些计算的任务都是可以并行执行的。同时，对于慢节点来说，因为计算是无状态的，且每个job的结果是可以确定的，spark streaming可以执行类似于hadoop中的预测模型——在其他节点上计算同样的任务。另外，spark streaming也会有些checkpoint来防止无限制的恢复计算。</p>

<p>对比于其他流式处理的方式，spark streaming在处理失败任务和慢节点上无疑更有效率。它可以从时间和partition两个维度上并行地计算数据来加快恢复速度。而对于像Strom的流式处理来说，往往是通过<strong>上游数据backup</strong>或者<strong>同时复制执行相同的作业</strong>来保证数据处理的可靠性。这两种处理方式对于资源的消耗无疑都是巨大的，且恢复的时间也比较长。</p>

<ul>
  <li>其中对于前者来说，每个节点都需要保存上一个checkpoing后所发送数据的拷贝，在节点失败时由standby机器重新计算上游节点发送过来的数据，因为这些计算都是有状态的，所以恢复的时间比较长，Storm就只保证“at least once”语义来提高处理速度。Trident之所以能够保证不重不丢是使用了数据库来复制计算状态。</li>
  <li>对于后者无疑更加消耗资源，并且需要保证两个数据处理操作接受到的上游数据的顺序是一样的。</li>
</ul>

<p>同spark一样，只有当某个Output Operations原语被调用时，stream才会开始真正的计算过程。现阶段支持的Output方式有以下几种：</p>

<ul>
  <li>print()</li>
  <li>foreachRDD(func)</li>
  <li>saveAsObjectFiles(prefix, [suffix])</li>
  <li>saveAsTextFiles(prefix, [suffix])</li>
  <li>saveAsHadoopFiles(prefix, [suffix])</li>
</ul>

<h3 id="section-1">流式处理中的几点难点</h3>

<p>在流式处理中通常都会有几个难点需要考虑。</p>

<ul>
  <li>时间窗口问题</li>
  <li>数据一致性问题</li>
  <li>内存状态管理问题</li>
</ul>

<p>我们来看下spark streaming是如何解决的。</p>

<ol>
  <li>
    <p><strong>时间窗口问题。</strong>spark streaming是根据数据到达系统的时间将记录放到对应的RDD中，这种时间窗口划分是基于墙上时间的，好处可以保证系统及时产生一个新的batch运行job，并且可以让程序运行在数据生成的地方，不必再进行分发。</p>

    <p>这种基于墙上时间的统计有一个非常严重的问题是不能回放数据流。当数据流是实时产生的时候，“墙上时间”的一分钟也就只会有一分钟的event被产生出来。但是如果统计的数据流是基于历史event的，那么一分钟可以产生消费的event数量只受限于数据处理速度。另外event在分布式采集的时候也遇到有快有慢的问题，一分钟内产生的event未必可以在一分钟内精确到达统计端，这样就会因为采集的延迟波动影响统计数据的准确性。所以产生了另外一种时间窗口划分的方法。</p>

    <p>另一种时间窗口划分的方法是基于外部时间的，例如日志时间。spark streaming提供两种方法来处理这种情况：</p>

    <ul>
      <li>延迟处理，等待一定时间来处理每个batch。</li>
      <li>用户的应用程序中保证乱序事件的正确处理。</li>
    </ul>

    <p>以上也说明在批处理的流式计算模型是受限的，很多情况下只能依靠用户的应用程序来做处理，例如实时的统计5s内的pv；其次这种方式也没有很好的流控技术手段，如果有突发的大量数据产生，会导致结果产生的时间更长，甚至是将系统的JVM撑爆。最后实时性也是受限的，只能达到次秒级的处理延迟，毕竟是要等待一个时间batch的处理完成。</p>
  </li>
  <li>
    <p><strong>数据一致性问题。</strong>什么是数据一致性，举个栗子，要统计网站中来自各个国家的page view，把不同国家的pv统计放在不同的节点上处理。但是现在统计英国的节点处理速度要慢于法国的，这将导致两个节点上数据的时间状态不一致。在流式处理中，数据的一致性的保证同时意味着资源的消耗。流式处理的数据一致性有三种解决思路，在上文中也有提到，这里概括下：</p>

    <ul>
      <li>上游备份策略：重启的时候重放kafka的历史数据，恢复内存状态</li>
      <li>中间状态持久化：把统计的状态放到外部的持久的数据库里，不放内存里</li>
      <li>同时跑两份：同时有两个完全一样的统计任务，重启一个，另外一个还能正常运行。</li>
    </ul>

    <p>而在spark streaming中，数据一致性天然得到保证的。因为记录根据时间来分片，所以中间的resultRDD反应的是当前时间和之前时间所计算出来的结果，无论计算和结果被分配到哪个节点上都不会有节点间数据不一致的情况。也就是数据的不重不丢可以得到保证。</p>
  </li>
  <li>
    <p><strong>内存状态管理问题。</strong>
做流式统计的有两种做法：</p>

    <ul>
      <li>依赖于外部存储管理状态：比如没收到一个event，就往redis里发incr增1</li>
      <li>纯内存统计：在内存里设置一个counter，每收到一个event就+1</li>
    </ul>

    <p>第一种会把整个压力全部压到数据库上，造成处理速度下降；第二种的状态相对来说容易管理一些，计算直接是基于这个内存状态做的。如果重启丢失了，重放一段历史数据就可以重建出来。内存的问题是它总是不够用的，解决的方法是input分割和把存储移到外边去。在内存计算中把窗口统计的中间状态落地的好处是显而易见的：重启之后不用通过重算来恢复内存状态。但是这种对外部数据库使用不小心就会导致两个问题：</p>

    <ul>
      <li>处理速度慢。不用一些批量的操作，数据库操作很快就会变成瓶颈</li>
      <li>数据库的状态不一致。内存的状态重启了就丢失了，外部的状态重启之后不丢失。重放数据流就可能导致数据的重复统计</li>
    </ul>

    <p>在spark streaming中支持传统批量计算中的无状态<em>transformation</em>操作，例如<code>map</code>、<code>reduce</code>、<code>groupBy</code>和<code>join</code>。这就避免了普通流式计算中麻烦的状态保存问题。但spark streaming中也支持多个时间间隔中有状态的<em>transformation</em>操作，包括：</p>

    <ol>
      <li>Windowing: 生成滑动窗口RDD。<code>words.window("5s")</code>将产生一个RDD包含[0,5),[1,6),[2,7)的时间间隔。</li>
      <li>增量聚合：在滑动窗口的基础上进行RDD的聚合操作，也就是<code>reduceByWindow</code>。在下图的<em>a</em>中对应的代码为<code>pairs.reduceByWindow("5s", (a, b) =&gt; a+b)</code>，也就是计算5s内的计数之后。图<em>b</em>的代码为<code>pairs.reduceByWindow("5s", (a, b) =&gt; a+b, (a, b) =&gt; a-b)</code>。其实很简单，第一个lambda表达式为进入滑动窗口的处理函数，第二个表达式为离开滑动窗口的处理函数。这样也就不用重复求和了。
 <img src="http://img-storage.qiniudn.com/15-10-18/97873121.jpg" alt="" /></li>
      <li>状态跟踪：
 如下图所示，就是保存上一个时间间隔的RDD与本次的记录进行groupBy加map计算的到状态的变化情况。
 <img src="http://img-storage.qiniudn.com/15-10-18/91458919.jpg" alt="" /></li>
    </ol>

    <p>在对这些带状态的操作的处理过程中也就用到了上述的所属的利用外存在保存中间的状态。spark streaming中这只发生在intervel之间，所以整个内存的状态管理会比传统的流式处理简单许多，而且高效，不需要对每一步都进行状态同步，状态恢复的成本也比较低，上文中提到的可以在多个节点上并行计算恢复。</p>
  </li>
</ol>

<h3 id="system-architecture">System Architecture</h3>
<p><img src="http://img-storage.qiniudn.com/15-10-18/82954556.jpg" alt="" /></p>

<p>Spark streaming和Spark的系统结构有些许改动，如上图所示主要包括3个部分：</p>

<ul>
  <li><em>master</em> that tracks the D-Stream lineage graph and schedules tasks to compute new RDD partitions.</li>
  <li><em>Worker</em> nodes that receive data, store the partitions of input and computed RDDs, and execute tasks.</li>
  <li>A <em>client</em> library used to send data into the system.</li>
</ul>

<p>从上图中可以看出，Spark Streaming和传统的流式系统最大的区别就是Spark Streaming将计算分成小的，无状态的确定性的任务，这些任务会在集群的任意节点上运行。并且相对于传统流式系统的拓扑结构来说，无需消耗大量时间将将任务进行迁移，Spark Streaming可以很好的对机器上的节点进行负载均衡，处理失败任务并且对慢节点进行预测。</p>

<p>对比于Spark的系统，Spark Streaming做了一下的改进：</p>

<ul>
  <li>网络传输。使用异步I/O获取远端数据。</li>
  <li>TimeStep pipelining。Spark的调度器可以在当前任务还未完成的时候可以提交下一个时间分片的任务。</li>
  <li>任务调度：优化任务调度器，例如调整控制消息的大小，可以在每隔几百毫秒时间内启动几百个并行任务。</li>
  <li>存储层：支持异步的RDD checkpoint，RDD是不可变的，所以异步存储不会阻塞现有的计算。</li>
  <li>Lineage切割：控制RDD linage graph的大小，在checkpoint之前的lineage便可以删除。</li>
</ul>

<p>当master fail的时候可以进行HA，所有的worker重新连接到新的master上，将原来的checkpoint和原始数据重新计算。因为所有的操作都是确定性的，所以RDD是可以重复计算，也就是说在HA的时候丢失一些正在运行的计算任务不会对最终结果造成什么影响。所有的元数据都是存储在HDFS上的，包括：</p>

<ol>
  <li>RDD的lineage graph，代表用户代码的Scala函数对象。</li>
  <li>上一个checkpoint的时间</li>
  <li>RDD的ID。因为HDFS的checkpoint文件会在每个时间片重新命名。</li>
</ol>

<h3 id="faq">FAQ</h3>
<ol>
  <li>
    <p>Dstream与RDD之间的关系</p>

    <p>首先来看下Spark streaming的代码<code>val ssc = new StreamingContext(sc, Seconds(2))</code>。在这句的作用是定义Dstream生成的时间间隔，<code>2s</code>就是这个时间间隔，也叫<code>batch interval</code>。具体说来<strong>一个streaming batch对应一个RDD</strong>，也就是这个batch interval里产生的数据。</p>

    <p>在这个RDD中，有n个partition，n = batch interval / block interval。 <code>block interval</code>是spark steaming内部定义的一个变量<code>spark.streaming.blockInterval</code>，通常是200ms。上述例子就产生10个partitions。</p>

    <p>Blocks由一个receiver产生，receiver就是流式数据的接收端，每个receiver被分配到一个host上，所以上述的1-个partitions就由一个node产生，同时被复制到第二个节点上做容错。注意，这里产生了data locality的问题。好的做法是，分配多个receivers接收数据，最后使用union合并数据做processing。当然还可以对Dstream做<code>repartition</code>操作提高并行度。</p>
  </li>
  <li>
    <p>时间窗口和job的关系</p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2015/10/27/spark-introduction/"/>
    <updated>2015-10-27T21:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/10/27/spark-introduction</id>
    <content type="html"><![CDATA[<p>简单介绍下Spark。Spark是分布式的内存计算模型，对于两类计算形式能够极大地提升处理的效率：迭代计算，和交互式的数据挖掘工具。迭代计算例如PageRank、K-means聚类、逻辑回归等要求计算结果的重新利用，交互式的数据挖掘例如针对一份的数据集进行多次特定查询也要求原始数据的重复利用。对比于MR作业，它不需要外部存储的介入，从而提升处理速度。接下来将会从Spark的数据模型、编程模型和架构来介绍Spark。</p>

<p><img src="https://spark.apache.org/images/spark-logo.png" alt="image" /></p>

<!--more-->

<h3 id="rdd-data-model">RDD Data Model</h3>
<p>那么如何利用多个节点的内存进行分布式的计算呢，这就是Spark的核心RDD（Resilient Distributed Dataset）。RDD是一个个记录的集合，只读和分片的。它只能通过外部存储或者其他RDD生成。RDD的这些变化操作名称为<em>transformation</em>，在Spark编程中还有另外一个操作需要知道，<em>action</em>，意思是返回一个值或者将数据导出到外部存储，像<code>count</code>、<code>collect</code>、<code>save</code>。一个spark程序往往是从外部存储中定义一个或多个RDD开始的，接着经过各种<em>transformation</em>，最后<em>action</em>。同时<em>action</em>也是计算的开始，在spark中计算是延迟的，各种<em>transformation</em>形成了computation pipeline在<em>action</em>中进行计算。</p>

<p>下表是对RDD中的<em>transformation</em>和<em>action</em>操作：
<img src="http://ww2.sinaimg.cn/large/74311666jw1ex310kinr3j210c0fujwg.jpg" alt="" /></p>

<p>RDD还有两个操作：<em>persistence</em>和<em>partitioning</em>。其实顾名思义，<em>persistence</em>即RDD的持久化操作，这是为了避免重复计算。<em>partitioning</em>是重新分区，为了得到更好的执行并发度。</p>

<p>合理的分区可以有效减少shuffle的数据量，根据特定的应用场景执行不同的<em>partitioning</em>。例如在PageRank中根据域名来对URL进行Hash，因为很多链接都是内部的。下图表示<em>partitioning</em>的效果。</p>

<p><img src="http://img-storage.qiniudn.com/15-10-16/6543188.jpg" alt="" /></p>

<p>持久化操作是也是为了更高的计算效率。例如在下图中，Spark有两个action，所以产生两个job。两个job各自计算RDD1和RDD2，对于数据量大的RDD无疑会影响性能，所以可以将RDD进行<em>persistence</em>操作，可以存入内存、硬盘或者二者结合。后续缓存的资源可以手动清除或者通过LRU算法自动清除。
<img src="http://ww2.sinaimg.cn/large/74311666jw1ex30g3zpazj20u60f2tb9.jpg" alt="" /></p>

<p>在上文中我们提到RDD是有<code>transformation</code>和<code>lazy compute</code>的特性的。这两个特性使得RDD不需要一直被实例化，只需要保存这个RDD是如何产生的，在延迟计算的时候便可以通过这些dependence信息进行RDD transformation操作。以上就是RDD lineage，一个RDD的血统关系图。RDD的只读特性也是为了更好地描述这个lineage graph。在上图中两个Output的产生也可以直观地看到RDD的lineage信息。那么这个linage究竟有什么好处呢，RDD可以根据dependency信息直接追踪到在外存中的数据，在发生错误的时候直接通过外存的原始数据计算丢失或错误的RDD分片信息。</p>

<h3 id="rdd-programming-model">RDD Programming Model</h3>

<p>RDD的编程模型需要通过适当的接口来表示RDD是如何经过一系列的transformations来达到现在的状态。在Spark中，RDD的编程模型暴露了5方面的信息：</p>

<ul>
  <li>dateset中的分片信息</li>
  <li>父RDD的依赖关系</li>
  <li>基于其父RDD的计算RDD方法</li>
  <li>分片的shceme元数据</li>
  <li>数据存放的位置
<img src="http://ww3.sinaimg.cn/large/74311666jw1ex32afwa8gj20qq0ds41v.jpg" alt="" /></li>
</ul>

<p>在第3个方法中，也就是根据父RDD分片计算本RDD的分片有两种情况：每个父RDD分片最多被一个子RDD分片依赖；父RDD分片被多个子RDD分片依赖。这两种情况分别对应<em>narrow dependency</em>和<em>wide dependency</em>。为什么区分这两种依赖关系呢，这和RDD的延迟计算特性有关系。</p>

<ul>
  <li>在<em>narrow dependency</em>中，一个节点上的RDD分片可以通过pipeline的方式从原始数据开始计算，多个分片可以并行的进行。而对于<em>wide dependency</em>需要所有父RDD的分片可用，而且涉及到data shuffle。</li>
  <li><em>narrow dependency</em>在节点失效后的恢复的效率更高，因为可以并行地在不同的节点上计算丢失的分片。而在<em>wide dependency</em>中，一个父RDD分片可能被多个子RDD分片使用，所以可能导致这些子RDD的祖先分片都有丢失，所以需要重新完整的计算。</li>
</ul>

<p>整个spark作业的执行调度也是和这两种dependency有关。当一个用户执行一个<em>action</em>操作的时候，spark的调度器检测RDD的lineage graph，建立一个DAG图来执行，DAG图中的每个节点就是一个<em>stage</em>。在每个<em>stage</em>中包含了多个pipeline的<em>transformation</em>操作，这些RDD的关系全都是
<em>narrow dependency</em>。每个<em>stage</em>的边界都是由<em>wide dependency</em>的shuffle操作，或者已经计算好的分片。调度器这时候就可以建立执行任务计算每个stage中缺失的<em>partitions</em>，直到得到最终的RDD。</p>

<p>那么如何合理划分 stage，并确定 task 的类型和个数？
<img src="http://img-storage.qiniudn.com/15-10-16/48846624.jpg" alt="" /></p>

<p>可以看到在上图中，每个stage中的数据都是形成了pipeline计算的，这里的pipeline思想是：<strong>数据用的时候再算，而且数据是流到要计算的位置的</strong>。有两层意思，一是延迟计算，二是计算本地化。比如在第一个 task 中，从 FlatMappedValuesRDD 中的 partition 向前推算，只计算要用的（依赖的） RDDs 及 partitions。在第二个 task 中，从 CoGroupedRDD 到 FlatMappedValuesRDD 计算过程中，不需要存储中间结果（MappedValuesRDD 中 partition 的全部数据）。</p>

<p>在有<em>wide dependency</em>的时候需要Shuffle后无法进行pipeline。那么我们可以<strong>从后往前推算，遇到 <em>wide dependency</em>就断开，遇到<em>narrow dependency</em>就将其加入该stage。每个stage里面task 的数目由该stage最后一个RDD中的partition个数决定</strong>。因此上图中最后一个stage的id是0，stage 1  stage 2都是stage 0的parents。</p>

<p>整个的computing chain也是根据数据依赖关系自后向前建立，遇到<em>wide dependency</em>后形成 stage。computing chain从后到前建立，而实际计算出的数据从前到后流动，那么RDD内部是如何实现计算的呢。在每个stage中，每个RDD中的compute()调用parentRDD.iter()来将parent RDDs中的 records一个个fetch过来。</p>

<blockquote>
  <p>代码实现：每个 RDD 包含的 getDependency() 负责确立 RDD 的数据依赖，compute() 方法负责接收 parent RDDs 或者 data block 流入的 records，进行计算，然后输出 record。经常可以在 RDD 中看到这样的代码firstParent[T].iterator(split, context).map(f)。firstParent 表示该 RDD 依赖的第一个 parent RDD，iterator() 表示 parentRDD 中的 records 是一个一个流入该 RDD 的，map(f) 表示每流入一个 recod 就对其进行 f(record) 操作，输出 record。为了统一接口，这段 compute() 仍然返回一个 iterator，来迭代 map(f) 输出的 records。</p>
</blockquote>

<p>在实现中，每个task是基于数据的本地性进行分配的，任务是在该分片的节点上执行的。而对于<em>wide dependecy</em>，会在拥有父分片的节点上计算中间结果，这是为了减少fault recovery的时间。</p>

<h3 id="spark-architecture">Spark Architecture</h3>
<p>在上一节中我们确定了Spark stage和task的生成和执行方式，那么这些stage和task在整个spark application中又处于什么样的位置呢，上文中我们提到的每个job又是什么意思呢，为什么一个application中又会有好多个job，它们之间的关系又是什么样的呢？</p>

<p><img src="http://spark-internals.books.yourtion.com/markdown/PNGfigures/deploy.png" alt="image" /></p>

<p>从部署图中可以看到</p>

<ul>
  <li>整个集群分为 Master 节点和 Worker 节点，相当于 Hadoop 的 Master 和 Slave 节点。</li>
  <li>Master 节点上常驻 Master 守护进程，负责管理全部的 Worker 节点。</li>
  <li>Worker 节点上常驻 Worker 守护进程，负责与 Master 节点通信并管理 executors。</li>
  <li>Driver 官方解释是 “The process running the main() function of the application and creating the SparkContext”。Application 就是用户自己写的 Spark 程序（driver program），比如 WordCount.scala。</li>
  <li>每个 Worker 上存在一个或者多个 ExecutorBackend 进程。每个进程包含一个 Executor 对象，该对象持有一个线程池，每个线程可以执行一个 task。</li>
  <li>每个 application 包含一个 driver 和多个 executors，每个 executor 里面运行的 tasks 都属于同一个 application。</li>
</ul>

<p>在最开始的时候我们介绍了RDD的<code>action</code>操作，还提到每个<code>action</code>就是一个job，事实上上表中的<code>action</code>操作其实是论文中的，实际上还有更多的<code>action</code>。如下表：</p>

<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">finalRDD(records) =&gt; result</th>
<th style="text-align:left">compute(results)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">reduce(func)</td>
<td style="text-align:left">(record1, record2) =&gt; result, (result, record i) =&gt; result</td>
<td style="text-align:left">(result1, result 2) =&gt; result, (result, result i) =&gt; result</td>
</tr>
<tr>
<td style="text-align:left">collect()</td>
<td style="text-align:left">Array[records] =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">count()</td>
<td style="text-align:left">count(records) =&gt; result</td>
<td style="text-align:left">sum(result)</td>
</tr>
<tr>
<td style="text-align:left">foreach(f)</td>
<td style="text-align:left">f(records) =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">take(n)</td>
<td style="text-align:left">record (i&lt;=n) =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">first()</td>
<td style="text-align:left">record 1 =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">takeSample()</td>
<td style="text-align:left">selected records =&gt; result</td>
<td style="text-align:left">Array[result]</td>
</tr>
<tr>
<td style="text-align:left">takeOrdered(n, [ordering])</td>
<td style="text-align:left">TopN(records) =&gt; result</td>
<td style="text-align:left">TopN(results)</td>
</tr>
<tr>
<td style="text-align:left">saveAsHadoopFile(path)</td>
<td style="text-align:left">records =&gt; write(records)</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">countByKey()</td>
<td style="text-align:left">(K, V) =&gt; Map(K, count(K))</td>
<td style="text-align:left">(Map, Map) =&gt; Map(K, count(K))</td>
</tr>
</tbody>
</table>

<p>用户的 driver 程序中一旦出现 action()，就会生成一个 job，比如 foreach() 会调用sc.runJob(this, (iter: Iterator[T]) =&gt; iter.foreach(f))，向 DAGScheduler 提交 job。如果 driver 程序后面还有 action()，那么其他 action() 也会生成 job 提交。所以，driver 有多少个 action()，就会生成多少个 job。这就是 Spark 称 driver 程序为 application（可能包含多个 job）而不是 job 的原因。</p>

<p>每一个 job 包含 n 个 stage，最后一个 stage 产生 result。。在提交 job 过程中，DAGScheduler 会首先划分 stage，然后先提交无 parent stage 的 stages，并在提交过程中确定该 stage 的 task 个数及类型，并提交具体的 task。无 parent stage 的 stage 提交完后，依赖该 stage 的 stage 才能够提交。从 stage 和 task 的执行角度来讲，一个 stage 的 parent stages 执行完后，该 stage 才能执行。</p>

<p>Spark就先介绍到这里，没有涉及到spark的具体内部实现，包括job的调度，shuffle的过程、文件的管理、cache和broadcast机制等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compression Format Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2015/09/18/compression-format-introduction/"/>
    <updated>2015-09-18T13:34:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/09/18/compression-format-introduction</id>
    <content type="html"><![CDATA[<h1 id="section">压缩格式</h1>
<p>最近在做一个日志的压缩策略，在此就记录下几种不同的压缩算法。本文不涉及每种算法的具体实现，只是用于介绍概念。</p>

<!--more-->

<h2 id="gzip">Gzip</h2>
<p>说到gzip，其实我是不想写的，满满的都是痛苦的回忆啊。在研究生时期曾经写过一个程序，在网关出对用户访问的网页进行hack，在网页的最后加上一个网页跳转的代码。由于网页传输的压缩编码就是gzip，具体做法是获取gzip的头文件后，构造压缩后的数据添加到原始的网页数据上。这里面很有意思的是，gzip是bit-oriented的，所以需要定位去除EOF marker后的数据最后的bit位置，再插入构造好的压缩数据。这里面涉及到的东西比较多，包括对gzip头文件的分析，找到每个单词对应的huffman编码；对压缩数据的反解找到对应的bit位；还有HTTP传输编码替换，所有的编码都改为CHUNKED编码方式。言归正传，那么什么是Gzip压缩编码？</p>

<p>Gzip是基于DEFLATE压缩算法的，它是由LZ77和Huffman编码的组成。LZ77其实很好理解，就是将重复的字符串用数字表示，标记为(length, distance)，相当于建立一个索引，后续出现的数据都可以通过这个索引找到原始的数据。举个简单的例子A A A A A A B A B A A A A A 经过LZ77编码后转化为A A A A A B &lt;2,2&gt; &lt;5,8&gt;, 可以看到A B和A A A A A是重复的，用长度和距离的组合来表示。Huffman编码是一种可变字长编码，依据字符出现概率来构造字符的二进制表示，用于保证了按字符出现概率分配码长，使平均码长最短。</p>

<p>通常我们说的gzip是指gzip文件格式，它的构成如下：</p>

<ul>
  <li>10字节的头，包括magic number，版本号和时间戳</li>
  <li>可选的附加字段，例如源文件名</li>
  <li>正文，也就是经过DEFLATED压缩后的数据</li>
  <li>8字节的EOF marker，包括CRC-32校验和和原始未压缩数据的长度。</li>
</ul>

<p>详细的文件格式如下：</p>

<p><img src="http://img-storage.qiniudn.com/15-9-18/30592957.jpg" alt="" /></p>

<h2 id="lzo">lzo</h2>

<p>lzo令人郁闷的一点是压缩算法是定义好的，但是传输和存储的格式并没有定义好。这就导致不同的厂商在lzo文件压缩格式上有不同的解决方案，在查找lzo资料的时候我就曾见过三种不同的传输或存储格式。那么为什么会有这种情况发生呢，原因就在于lzo lib包中只是定义了压缩的算法，且算法有好几十种。lib包关心的是如何将一串文本转成压缩好的字符串数据，而不关心客户端和服务端是否沟通协调好具体的算法，在传输或存储时候是否会有数据损坏的情况，所以在对lzo压缩进行产品化的时候我们需要考虑这些情况。</p>

<p>在hadoop中，lzo所采用的和<em>lzop</em>相同的压缩格式，lzop是神马呢，官网简介如下：
&gt;lzop is a file compressor which is very similar to gzip. lzop uses the LZO data compression library for compression services, and its main advantages over gzip are much higher compression and decompression speed (at the cost of some compression ratio).</p>

<p>lzop定的的头文件包含的信息如下：</p>

<pre><code>typedef struct {
    unsigned char magic[9]
    uint16_t version;
    uint16_t lib_version;
    uint16_t version_needed_to_extract;
    unsigned char method;
    unsigned char level;                // ignore
    uint32_t flags;                     
    uint32_t filter;                    // filter is not supported
    uint32_t mode;                      // ignore
    uint32_t mtime_low;                 // ignore
    uint32_t mtime_high;                // ignore
    unsigned char filename_len;
    uint32_t checksum;
} header_t;
</code></pre>

<p>在lzop的头文件格式中中还有定义一些extra fields，filename，这些在hadoop的解压算法中就直接给忽略了，所以这里也就没有添加上去，<code>header_t</code>中都是一些必要的占位字段，有些无意义，有些有意义。其中在<code>flags</code>中定义了一些是压缩格式实现的细节，例如压缩前数据的校验和算法，压缩后数据的校验和算法，是否有filter，是否是多文件合并等等。<code>method</code>字段定义了具体的压缩算法，使用的比较多的是M_LZO1X<em>1、M_LZO1X</em>1<em>15、M_LZO1X</em>999. 在官方的lib包中又对各种压缩算法的一个比较，通常情况下使用M_LZO1X_1就足够了。</p>

<p>lzo的压缩是面向块的，所以正文部分也就是由一块一块的压缩块构成，每块的压缩格式如下：</p>

<pre><code>/*
 * uncompressed block size
 * compressed block size
 * uncompressed block checksum
 * compressed block checksum
 * compressed block
 */
</code></pre>

<p>最后写一个EOF marker，也就是4bytes的0.</p>

<h2 id="snappy">snappy</h2>

<p>Google开发的一个 C++ 的用来压缩和解压缩的开发包，旨在提供高速压缩速度和合理的压缩率，Snappy 比 zlib 更快，但文件相对要大 20% 到 100%。Snappy特地为64位x86处理器做了优化，在单个Intel Core i7处理器内核上能够达到至少每秒250MB的压缩速率和每秒500MB的解压速率。Snappy的压缩是属于LZ77 体系，不同于gzip，它是byte-oriented，也就是说数据块之间是有严格的字节区分的；而gzip由于最后加入了Huffman编码，所以它是bit-oriented。byte-oriented的好处是处理起来比较简单，不需要记录字节中的位占用情况和加入数据的位迁移。</p>

<p>Snappy的压缩方式有一个frame的概念，这个帧并不是Snappy压缩所必须的，这个帧其实也就是Snappy的压缩文本加上一些必要的其他信息，例如checksum。Snappy中帧与帧之间是相互独立的，也就是说在压缩过程中你可以不关心其他帧的情况，只需要压缩好自己的数据然后发送或存储，解压的过程中会根据帧的粒度进行解压。这就意味着在分布式的环境中，你可以很容易的合并各个节点上的压缩数据，无需和其他节点进行同步，这个在其他算法中是无法办到的。</p>

<p>Snappy文件只由一个个连续的chunk构成，每个chunk的构成包括：1字节的chunk标识符，3字节的chunk长度，接着就是数据。chunk长度可以为0，这就表示该chunk的数据不存在。Snappy文件的第一个chunk是stream chunk，固定的6字节长度，其中数据部分为”sNaPpY”。这个chunk可以理解为Snappy的头文件，但是这个头文件可以出现多次，这也就是每个Snappy frame可以独立的原因之一；另外一个原因是Snappy并没有EOF marker。其他chunk的类型还包括：</p>

<ul>
  <li>Compressed data</li>
  <li>Uncompressed data</li>
  <li>padding</li>
  <li>Reserved unskippable chunks</li>
  <li>Reserved skippable chunks</li>
</ul>

<h2 id="section-1">对比</h2>
<p>以下是在论文中找到的一些资料。</p>

<p><img src="http://img-storage.qiniudn.com/15-9-17/82781797.jpg" alt="" /></p>

<p><img src="http://ww1.sinaimg.cn/large/74311666jw1ew5aeta9loj20w10hfdi2.jpg" alt="" /></p>

<h2 id="section-2">其他</h2>
<p><a href="https://github.com/billowkiller/Codec">以上三种压缩格式的c++方法</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MCMC Methods]]></title>
    <link href="http://billowkiller.github.io/blog/2015/09/01/mcmc/"/>
    <updated>2015-09-01T16:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/09/01/mcmc</id>
    <content type="html"><![CDATA[<p>解释下题目中的MCMC，全名是Markov Chain Monte Carlo，这里面有两个词，Markov Chain、Monte Carlo。第一个词是马尔可夫链，可以参考<a href="http://billowkiller.com/blog/2016/05/09/random-process/">http://billowkiller.com/blog/2016/05/09/random-process/</a>。第二个是蒙特卡罗，是一种模拟方法，可以从一个分布中模拟出点来估计我们感兴趣的参数，例如用来估计密度函数的定积分，称为 Monte Carlo Integration。</p>

<!--more-->

<h2 id="monte-carlo-integration">Monte Carlo Integration</h2>

<p>譬如现在有个分布 $p(\theta)$，我们想知道一下积分：</p>

<script type="math/tex; mode=display"> I = \int_{\Theta} g(\theta)p(\theta) d\theta </script>

<p>通过从 $p(\theta)$ 中模拟出 $M$ 个值，我们可以估计 $I$，公式如下：</p>

<script type="math/tex; mode=display"> \hat{I}_M = \frac{1}{M} \sum_{i=1}^M g(\theta^{(i)}) </script>

<p>于是统计 $Beta(3,3)$ 的期望可以通过一下代码得到：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">M <span class="o">&lt;-</span> <span class="m">10000</span>
</span><span class="line">beta.sims <span class="o">&lt;-</span> rbeta<span class="p">(</span>M<span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class="line">sum<span class="p">(</span>beta.sims<span class="p">)</span><span class="o">/</span>M
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有一个经典的例子是计算 $\pi$:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">M <span class="o">&lt;-</span> <span class="m">1000000</span>
</span><span class="line">x <span class="o">&lt;-</span> runif<span class="p">(</span>N<span class="p">,</span> min<span class="o">=</span> <span class="m">-1</span><span class="p">,</span> max<span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">y <span class="o">&lt;-</span> runif<span class="p">(</span>N<span class="p">,</span> min<span class="o">=</span> <span class="m">-1</span><span class="p">,</span> max<span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">is.inside <span class="o">&lt;-</span> <span class="p">(</span>x<span class="o">^</span><span class="m">2</span> <span class="o">+</span> y<span class="o">^</span><span class="m">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="m">1</span>
</span><span class="line">pi.estimate <span class="o">&lt;-</span> <span class="m">4</span> <span class="o">*</span> sum<span class="p">(</span>is.inside<span class="p">)</span> <span class="o">/</span> M
</span><span class="line">pi.estimate
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过大数定律我们其实是可以知道，当 $M \to \infty$，$\hat{I}_M \to I$。</p>

<p>大数定律要求的是独立同分布的随机变量，上述的例子都是从同一分布中得到独立的变量，但是如果我们不能产生独立的变量又该怎么办呢？</p>

<p>例如，我们想要从后验分布 $p(\theta \vert y)$ 中抽样，但是我们不能产生独立的变量，因为我们通常不知道 normalizing constant。我们却可以产生稍微有点依赖的变量，这时可以应用 Markov chain 得到我们感兴趣的值。</p>

<p>一旦马尔可夫链收敛到了平稳分布，这时候对马尔可夫链的抽样就类似于对 $p(\theta \vert y)$ 的抽样。但是还是没有解决抽样不是独立。</p>

<p>这时候我们祭出大神 <code>Ergodic Theorem</code>，可以让马尔可夫链模拟大数定律，定义如下：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/86848502.jpg" width="600px" /></p>

<p>下面分别解释下 aperiodic, irreducible, positive recurrent。</p>

<p><strong>aperiodic</strong></p>

<p>马尔可夫链的周期性可以用下图表示</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/33403945.jpg" width="400px" /></p>

<p>只要整个链不是重复一个完整的圆圈，则为 aperiodic。</p>

<p><strong>irreducibility</strong></p>

<p>马尔可夫链的不可约表示为可以从任意一个状态到另外一个状态。</p>

<p>以下的链表示的是可约的：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/75995726.jpg" width="400px" /></p>

<p><strong>positive recurrent</strong></p>

<p>positive recurrent表示经过有限次数步骤，可以从任意给定的状态最终返回这个状态。</p>

<p>如果马尔可夫链满足以上这三个条件，则可以忽略抽样之间的依赖关系，进行 Monte Carlo Integration。</p>

<p>知道了上述的知识，我们可以得到 MCMC 的定义：</p>

<blockquote>
  <p>MCMC is a class of methods in which we can <strong>simulate draws</strong> that are <strong>slightly dependent</strong> and are approximately from a (posterior) distribution.</p>
</blockquote>

<p>在贝叶斯统计中，我们通常会使用两种 MCMC 算法：the Gibbs Sampler 和 Metropolis-Hastings algorithm。</p>

<h2 id="gibbs-sampling">Gibbs Sampling</h2>

<p>假设我们想从联合概率分布 $p(\theta_1,…\theta_k)$ 中得到抽样，那么我们需要知道的是<strong>每个参数的条件分布</strong> $p(\theta_j \vert \theta_{-j},y)$。</p>

<p>从条件概率是如何得到联合概率的呢？具体是根据 <code>The Hammersley-Clifford Theorem</code>。有个例子如下：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/41685068.jpg" width="600px" /></p>

<p>于是右边就可以得到 $f(y \vert x) f(x) = f(x,y)$。</p>

<p>接下来我们要确认的是如何得到每个参数的条件概率分布，full conditional probability.</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/33580254.jpg" width="600px" /></p>

<p>得到了 full conditional probability 就可以进行 Gibbs Sampling.</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/5179470.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/18003635.jpg" width="600px" /></p>

<p>通过对后验概率的近似抽样我们其实是在模拟马尔可夫链。所以也就可以通过这些抽样得到估计值。</p>

<u>Example:</u>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/34647596.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/6225347.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/68667610.jpg" width="600px" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">gibbs <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>n.sims<span class="p">,</span> beta.start<span class="p">,</span> alpha<span class="p">,</span> gamma<span class="p">,</span> delta<span class="p">,</span>
</span><span class="line">        y<span class="p">,</span> t<span class="p">,</span> burnin<span class="o">=</span><span class="m">0</span><span class="p">,</span> thin<span class="o">=</span><span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        beta.draws <span class="o">&lt;-</span> c<span class="p">()</span>
</span><span class="line">        lambda.draws <span class="o">&lt;-</span> matrix<span class="p">(</span><span class="kc">NA</span><span class="p">,</span> nrow <span class="o">=</span> n.sims<span class="p">,</span> ncol <span class="o">=</span> length<span class="p">(</span>y<span class="p">))</span>
</span><span class="line">        beta.cur <span class="o">&lt;-</span> beta.start
</span><span class="line">        lambda.update <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>alpha<span class="p">,</span> beta<span class="p">,</span> y<span class="p">,</span> t<span class="p">)</span> <span class="p">{</span>
</span><span class="line">           rgamma<span class="p">(</span>length<span class="p">(</span>y<span class="p">),</span> y <span class="o">+</span> alpha<span class="p">,</span> t <span class="o">+</span> beta<span class="p">)</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        beta.update <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>alpha<span class="p">,</span> gamma<span class="p">,</span> delta<span class="p">,</span> lambda<span class="p">,</span> y<span class="p">)</span> <span class="p">{</span>
</span><span class="line">           rgamma<span class="p">(</span><span class="m">1</span><span class="p">,</span> length<span class="p">(</span>y<span class="p">)</span> <span class="o">*</span> alpha <span class="o">+</span> gamma<span class="p">,</span> delta <span class="o">+</span> sum<span class="p">(</span>lambda<span class="p">))</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>n.sims<span class="p">)</span> <span class="p">{</span>
</span><span class="line">            lambda.cur <span class="o">&lt;-</span> lambda.update<span class="p">(</span>alpha <span class="o">=</span> alpha<span class="p">,</span> beta <span class="o">=</span> beta.cur<span class="p">,</span>
</span><span class="line">                y <span class="o">=</span> y<span class="p">,</span> t <span class="o">=</span> t<span class="p">)</span>
</span><span class="line">            beta.cur <span class="o">&lt;-</span> beta.update<span class="p">(</span>alpha <span class="o">=</span> alpha<span class="p">,</span> gamma <span class="o">=</span> gamma<span class="p">,</span>
</span><span class="line">                delta <span class="o">=</span> delta<span class="p">,</span> lambda <span class="o">=</span> lambda.cur<span class="p">,</span> y <span class="o">=</span> y<span class="p">)</span>
</span><span class="line">            <span class="kr">if</span> <span class="p">(</span>i <span class="o">&gt;</span> burnin <span class="o">&amp;</span> <span class="p">(</span>i <span class="o">-</span> burnin<span class="p">)</span><span class="o">%%</span>thin <span class="o">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                lambda.draws<span class="p">[(</span>i <span class="o">-</span> burnin<span class="p">)</span><span class="o">/</span>thin<span class="p">,</span> <span class="p">]</span> <span class="o">&lt;-</span> lambda.cur
</span><span class="line">                beta.draws<span class="p">[(</span>i <span class="o">-</span> burnin<span class="p">)</span><span class="o">/</span>thin<span class="p">]</span> <span class="o">&lt;-</span> beta.cur
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="kr">return</span><span class="p">(</span>list<span class="p">(</span>lambda.draws <span class="o">=</span> lambda.draws<span class="p">,</span> beta.draws <span class="o">=</span> beta.draws<span class="p">))</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面实验得到上述例子的参数估计</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">y <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">14</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">19</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">22</span><span class="p">)</span>
</span><span class="line">t <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">94</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">63</span><span class="p">,</span> <span class="m">126</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">31</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</span><span class="line">posterior <span class="o">&lt;-</span> gibbs<span class="p">(</span>n.sims <span class="o">=</span> <span class="m">10000</span><span class="p">,</span> beta.start <span class="o">=</span> <span class="m">1</span><span class="p">,</span> alpha <span class="o">=</span> <span class="m">1.8</span><span class="p">,</span> gamma <span class="o">=</span> <span class="m">0.01</span><span class="p">,</span> delta <span class="o">=</span> <span class="m">1</span><span class="p">,</span> y <span class="o">=</span> y<span class="p">,</span> t <span class="o">=</span> t<span class="p">)</span>
</span><span class="line"><span class="c1"># 大数定律</span>
</span><span class="line">colMeans<span class="p">(</span>posterior<span class="o">$</span>lambda.draws<span class="p">)</span>
</span><span class="line">mean<span class="p">(</span>posterior<span class="o">$</span>beta.draws<span class="p">)</span>
</span><span class="line">apply<span class="p">(</span>posterior<span class="o">$</span>lambda.draws<span class="p">,</span> <span class="m">2</span><span class="p">,</span> sd<span class="p">)</span>
</span><span class="line">sd<span class="p">(</span>posterior<span class="o">$</span>beta.draws<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="metropolis-hastings-algorithm">Metropolis-Hastings Algorithm</h2>

<p>Metropolis-Hastings 算法适用于这种情况：</p>

<ul>
  <li>后验概率并不像任何我们知晓的分布（没有共轭分布）</li>
  <li>参数的条件概率并不像任何我们知晓的分布（没法用Gibbs sampling）</li>
  <li>后验概率拥有三个以上的参数（grid approximations 不可解）</li>
</ul>

<p>具体的算法有以下步骤：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/92275724.jpg" width="600px" /> </p>

<p>细分下每个步骤：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/86212406.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/28170626.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/32187111.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/28671748.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/28650748.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/73904716.jpg" width="600px" /></p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/8969349.jpg" width="600px" /></p>

<u>Example:</u>

<p>使用随机游走Metropolis算法从Gamma(1.7, 4.4)分布抽样，jumping distribution是一个标准差为2的正太分布。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">mh.gamma <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>n.sims<span class="p">,</span> start<span class="p">,</span> burnin<span class="p">,</span> cand.sd<span class="p">,</span> shape<span class="p">,</span> rate<span class="p">)</span> <span class="p">{</span>
</span><span class="line">    theta.cur <span class="o">&lt;-</span> start
</span><span class="line">    draws <span class="o">&lt;-</span> c<span class="p">()</span>
</span><span class="line">    theta.update <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>theta.cur<span class="p">,</span> shape<span class="p">,</span> rate<span class="p">)</span> <span class="p">{</span>
</span><span class="line">        theta.can <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">1</span><span class="p">,</span> mean <span class="o">=</span> theta.cur<span class="p">,</span> sd <span class="o">=</span> cand.sd<span class="p">)</span>
</span><span class="line">        accept.prob <span class="o">&lt;-</span> dgamma<span class="p">(</span>theta.can<span class="p">,</span> shape <span class="o">=</span> shape<span class="p">,</span> rate <span class="o">=</span> rate<span class="p">)</span> <span class="o">/</span>
</span><span class="line">            dgamma<span class="p">(</span>theta.cur<span class="p">,</span> shape <span class="o">=</span> shape<span class="p">,</span> rate <span class="o">=</span> rate<span class="p">)</span>
</span><span class="line">        <span class="kr">if</span> <span class="p">(</span>runif<span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">&lt;=</span> accept.prob<span class="p">)</span> theta.can <span class="kr">else</span> theta.cur
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span>n.sims<span class="p">)</span> <span class="p">{</span>
</span><span class="line">        draws<span class="p">[</span>i<span class="p">]</span> <span class="o">&lt;-</span> theta.cur <span class="o">&lt;-</span> theta.update<span class="p">(</span>theta.cur<span class="p">,</span> shape <span class="o">=</span> shape<span class="p">,</span> rate <span class="o">=</span> rate<span class="p">)</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kr">return</span><span class="p">(</span>draws<span class="p">[(</span>burnin <span class="o">+</span> <span class="m">1</span><span class="p">)</span><span class="o">:</span>n.sims<span class="p">])</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">mh.draws <span class="o">&lt;-</span> mh.gamma<span class="p">(</span><span class="m">10000</span><span class="p">,</span> start <span class="o">=</span> <span class="m">1</span><span class="p">,</span> burnin <span class="o">=</span> <span class="m">1000</span><span class="p">,</span> cand.sd <span class="o">=</span> <span class="m">2</span><span class="p">,</span> shape <span class="o">=</span> <span class="m">1.7</span><span class="p">,</span> rate <span class="o">=</span> <span class="m">4.4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Patterns for MapReduce Algorithms]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/mr-design-pattern/"/>
    <updated>2015-07-26T17:23:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/mr-design-pattern</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mapreduce framework]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/mapreduce-framework/"/>
    <updated>2015-07-26T17:23:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/mapreduce-framework</id>
    <content type="html"><![CDATA[<h2 id="mapreduce">MapReduce框架</h2>

<p>mapReduce 的输入是hdfs上存储的一系列文件集。在hadoop中，这些文件被一种定义了如何分割一个文件成分片的input format来分割，一个分片是一个文件基于字节的可以被一个map任务加载的一个块。</p>

<ul>
  <li>每个map任务被分为以下阶段：<code>record reader</code>，<code>mapper</code>，<code>combiner</code>，<code>partitioner</code>。Map任务的输出叫中间数据，包括keys和values，发送到reduce端。</li>
  <li>Reduce任务分为以下阶段：<code>shuffle</code>，<code>sort</code>，<code>reduce</code>，<code>output format</code>。运行map任务的节点会尽量选择数据所在的节点。这种情况下，不会出现网络传输，在本地节点就可以完成计算。</li>
</ul>

<p>过程如图所示，接下来的章节会一一介绍。</p>

<p><img src="https://farm3.static.flickr.com/2275/3529146683_c8247ff6db_o.png" alt="" /></p>

<!--more-->

<h3 id="input-format">Input Format</h3>

<p>Record reader会把根据input fromat生成输入分片翻译成records。Record reader的目的是把数据解析成记录，而不是解析数据本身。它把数据以键值对的形式传递给mapper。通常情况下键是偏移量，值是这条记录的整个字节块。从Input file到map的中间过程如下图所示</p>

<p><img src="http://i12.tietuku.com/691b0fd1648b0497.png" width="450px" /></p>

<p>InputFormat其实做了三件事：</p>

<ul>
  <li>校验job的input configuration（比如，查看数据是否存在）。</li>
  <li>split输入的数据文件为逻辑上分片InputSplit，每个InputSplit给接下来的map task处理。</li>
  <li>创建RecordReader从InputSplit中解析出一个个键值对，这个键值对就是Record。</li>
</ul>

<p>如果要自定义InputFormat则最重要的是两个方法：</p>

<ul>
  <li><code>public List&lt;InputSplit&gt; getSplits(JobContext context)</code></li>
  <li><code>public RecordReader createRecordReader(InputSplit split, TaskAttemptContext context)</code></li>
</ul>

<p>通常在处理文本文件的时候，为了保证记录的完整性，RecorderReader会读取超过InputSplit边界的数据。</p>

<p><img src="http://i5.tietuku.com/392e9f9f99737b4d.jpg" alt="" /></p>

<p>在上图中共有三个InputSplit，在hadoop中默认的InputSplit大小为HDFS中每个Block的大小，所以共产生三个map task，它们读取数据的情况如下：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Start</th>
      <th>Actual Start</th>
      <th>End</th>
      <th>Line(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Mapper1</td>
      <td>B1:0</td>
      <td>B1:0</td>
      <td>B2:150</td>
      <td>L1, L2, L3</td>
    </tr>
    <tr>
      <td>Mapper2</td>
      <td>B2:128</td>
      <td>B2:150</td>
      <td>B3:300</td>
      <td>L4, L5, L6</td>
    </tr>
    <tr>
      <td>Mapper3</td>
      <td>B3:256</td>
      <td>B3:300</td>
      <td>B3:300</td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>

<p>现有的InputFormat包括：</p>

<ul>
  <li>TextInputFormat，Hadoop中默认的InputFormat，每行都是一个record，以偏移量为key</li>
  <li>KeyValueTextInputFormat， 可以指定key value分割符的TextInputFormat</li>
  <li>NLineInputFormat, mapper接受固定行数的记录</li>
  <li>SequenceFileInputFormat，二进制的KV
    <ul>
      <li>SequenceFileAsTextInputFormat，文本形式的KV</li>
      <li>SequenceFileAsBinaryInputFormat</li>
      <li>FixedLengthInputFormat</li>
    </ul>
  </li>
  <li>MultipleInputs</li>
  <li>DBInputFormat</li>
</ul>

<h3 id="map">Map</h3>

<p>Map阶段，会对每个从RecordReader读取的Record键值对执行用户代码，这些键值对又叫中间键值对。键和值的选择不是任意的，并且对MapReduce job的成功非常重要。键会用来分组，值是reducer端用来分析的数据。。</p>

<h3 id="combiner">Combiner</h3>
<p>Combiner 是一个map阶段分组数据，可选的，局部reducer。它根据用户提供的方法在一个mapper范围内根据中间键去聚合值。例如：数的总和是各个部分数量的和，你可以先计算中间的数目，最后再把所有中间数目加起来。很多情况下，这样能减少数据的网络传输量。发送（hello world，1）三次很显然要比发送（hello world，3）需要更多的网络传输字节量。</p>

<p><img src="http://i12.tietuku.com/009804b71667c5b9.png" width="500px" /></p>

<p>上图所示就是combiner发生的时机，它发生在map side写入磁盘的时候，可能会发生两次，一次是在Spill的时候，一次是在Merge的时候。在这两个阶段之前，是有一个sort的过程，这是为了最大化地提高combiner效率。其实从结构和作用来看，combiner函数和reducer函数的作用是相同的，很多情况下，Combiner也是直接用Reducer。</p>

<h3 id="partitioner">Partitioner</h3>

<p>Partitioner很简单，它决定哪个reducer接收该mapper数据记录，默认的是一个hash函数，对key进行hash之后取reducer个数的模。Partitioner会获取从mapper（或combiner）来的键值对，并分割成分片，每个reducer一个分片。默认用哈希值，典型使用md5sum。然后partitioner根据reduce的个数执行取余运算：key.hashCode() % (number of reducers)。这样能随即均匀的根据key分发数据到reduce，但仍然要保证不同mapper的相同key要到同一个reduce。Partitioner也可以自定义，使用更高级的样式，例如排序。然而，更改partitioner很少用。Partitioner的每个map的数据会写到本地磁盘，并等待对应的reducer检测，拿走数据。</p>

<h3 id="shuffle-and-sort">Shuffle and sort</h3>
<p>虽然说这个阶段主要是在Reduce端，但是Map端的一些行为也会影响到Reduce端。</p>

<p><img src="http://i5.tietuku.com/952140624345e77f.png" width="500px" /></p>

<p>上图是Map端的Shuffle过程，从整个过程来看，最重的部分在于Spill和Merge这两个I/O相关的操作，所有的数据需要从磁盘中读取后又重新写入到磁盘中，所以理想情况下是能够将所有mapper的output都装入到内存中。</p>

<p>Reduce任务开始于shuffle和sort阶段，Reduce将会开启多个fetcher从每个节点上的shuffle service中获取数据流。这一阶段获取partitioner的输出文件，并下载到reduce运行的本地机器。在下载的过程中，map的output首先会写入到内存中并进行排序，在数据达到一定量之后spill到磁盘，会有一个后台程序不断merge这些spilled file。最终，所有的output会合并成一个大的文件。这一阶段不能自定义，由框架自动处理。需要做的只是key的选择和可以自定义个用于分组的比较器。整个过程如下图所示。</p>

<p><img src="http://i5.tietuku.com/d11419d045f44d9a.png" width="500px" /></p>

<h3 id="reduce">Reduce</h3>
<p>Reduce 任务会把分组的数据作为输入并对每个key组执行reduce方法代码。方法会传递key和可以相关的所有值得迭代集合。很多的处理会在这个方法里执行，也就会有很多的模式。一旦reduce方法完成，会发送0或多个键值对到output format。跟map一样，不同的reduce依据不同的逻辑情形而不同。</p>

<h3 id="output-format">Output format</h3>
<p>Output Format会把reduce阶段的输出键值对根据record writer写到文件里。默认用tab分割键值对，用换行分割不同行。这里也可以自定义为更丰富的输出格式，最后，数据被写到hdfs。整个过程类似于InputFormat。</p>

<p><img src="http://i12.tietuku.com/cbdb549a3e19f898.png" width="500px" /></p>

<p>LazyOutputFormat 用来保证output (part-r-nnnnn) files有数据，不会存在空文件。</p>

<h3 id="output-commiter">Output Commiter</h3>

<p>Hadoop使用<code>OutputCommitter</code>来保证作业和任务的事务性。在旧的API中需要显示的使用<code>setOutputCommitter</code>或者设置<code>mapred.output.committer.class</code>。
而在新的API中，<code>OutputCommitter</code>是由<code>OutputFormat</code>通过<code>getOutputCommitter()</code>方法决定的。默认的是<code>FileOutputCommitter</code>，它适用于所有的基于文件的MapReduce。</p>

<p><code>OutputCommitter</code>API如下：</p>

<pre><code>public abstract class OutputCommitter {
	public abstract void setupJob(JobContext jobContext) throws IOException; 
	public void commitJob(JobContext jobContext) throws IOException { } 
	public void abortJob(JobContext jobContext, JobStatus.State state) throws IOException { }
	public abstract void setupTask(TaskAttemptContext taskContext) throws IOException;
	public abstract boolean needsTaskCommit(TaskAttemptContext taskContext) throws IOException;
	public abstract void commitTask(TaskAttemptContext taskContext) throws IOException;
	public abstract void abortTask(TaskAttemptContext taskContext) throws IOException;
}
</code></pre>

<p><code>setupJob</code>方法在job运行前就被调用，用来服务于作业的初始化，类似创建作业和task的临时目录。</p>

<p>job成功后会调用<code>commitJob()</code>方法，用于删除临时目录和创建<em>_SUCCESS</em>文件。如果job失败，则调用<code>abortJob()</code>方法
表示作业失败或者被kill，默认情况下会删除临时目录。</p>

<p>在task级别的操作类似。Hadoop框架会保证在一个task中的多个task attempt中，只有一个会commit，其他abort。有两种情况：</p>

<ul>
  <li>第一个attempt失败的时候会abort，第二个attempt如果成功则会commit。</li>
  <li>对于预测任务，只要有一个首先成功的话会commit，另外一个则abort。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PID File Analysis]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/pid-file-analysis/"/>
    <updated>2015-07-26T16:57:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/pid-file-analysis</id>
    <content type="html"><![CDATA[<h1 id="pid-">pid 文件浅析</h1>

<p>在Linux系统的目录/var/run下面一般我们都会看到很多的*.pid文件。而且往往新安装的程序在运行后也会在/var/run目录下面产生自己的pid文件。那么这些pid文件有什么作用呢？它的内容又是什么呢？</p>

<!--more-->

<h3 id="pid">pid文件的内容</h3>

<p>pid文件为文本文件，内容只有一行, 记录了该进程的ID。
用cat命令可以看到。</p>

<h3 id="pid-1">pid文件的作用</h3>

<p>防止进程启动多个副本。只有获得pid文件固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。</p>

<h3 id="section">编程技巧</h3>

<p>调用fcntl设置pid文件的锁定F_SETLK状态，其中锁定的标志位F_WRLCK。
如果成功锁定，则写入进程当前PID，进程继续往下执行。
如果锁定不成功，说明已经有同样的进程在运行了，当前进程结束退出。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>pid usage</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
</span><span class="line"><span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="c1">//锁定不成功, 退出......</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">sprintf</span> <span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">pid</span><span class="p">);</span>
</span><span class="line"><span class="n">pidsize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">write</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pidsize</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pidsize</span><span class="p">){</span>
</span><span class="line">    <span class="c1">//写入不成功, 退出......</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">一些注意事项：</h3>

<ol>
  <li>如果进程退出，则该进程加的锁自动失效。</li>
  <li>如果进程关闭了该文件描述符fd， 则加的锁失效。(整个进程运行期间不能关闭此文件描述符)</li>
  <li>锁的状态不会被子进程继承。如果进程关闭则锁失效而不管子进程是否在运行。
 (Locks are associated with processes. A process can only have one kind of lock set for each byte of a given file. When any file descriptor for that file is closed by the process, all of the locks that process holds on that file are released, even if the locks were made using other descripors that remain open. Likewise, locks are released when a process exits, and are not inherited by child processes created using fork.)</li>
</ol>

<h3 id="section-2">其他</h3>

<p><strong>C的fcntl函数：</strong></p>

<pre><code>int fcntl(int fd, int cmd, struct flock *lock);
</code></pre>

<p>参数cmd代表欲垄断的号召</p>

<ul>
  <li>F_DUPFD 复制参数fd的文件描写符，厉行获胜则归来新复制的文件描写符，</li>
  <li>F_GETFD 获得close-on-exec符号，若些符号的FD_CLOEXEC位为0，代表在调用exec()相干函数时文件将不会关闭</li>
  <li>F_SETFD 设置close-on-exec符号，该符号以参数arg的 FD_CLOEXEC位定夺</li>
  <li>F_GETFL 获得open()设置的符号</li>
  <li>F_SETFL 改换open()设置的符号</li>
  <li>F_GETLK 获得文件锁定的事态，依据lock的描写，定夺是否上文件锁</li>
  <li>F_SETLK 设置文件锁定的事态，此刻flcok，构造的l_tpye值定然是F_RDLCK、F_WRLCK或F_UNLCK，
万一无法发生锁定，则归来-1</li>
  <li>F_SETLKW 是F_SETLK的阻塞版本，在无法获得锁时会进去睡眠事态，万一能够获得锁可能捉拿到信号则归来</li>
</ul>

<p>参数lock指针为flock构造指针定义如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>flock structure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">struct</span> <span class="n">flock</span> <span class="p">{</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line">	<span class="kt">short</span> <span class="n">l_type</span><span class="p">;</span>
</span><span class="line">	<span class="kt">short</span> <span class="n">l_whence</span><span class="p">;</span>
</span><span class="line">	<span class="kt">off_t</span> <span class="n">l_start</span><span class="p">;</span> <span class="err">锁定区域的开关位置</span>
</span><span class="line">	<span class="kt">off_t</span> <span class="n">l_len</span><span class="p">;</span> <span class="err">锁定区域的大小</span>
</span><span class="line">	<span class="n">pid_t</span> <span class="n">l_pid</span><span class="p">;</span> <span class="err">锁定动作的历程</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>1_type有三种事态：</p>

<ul>
  <li>F_RDLCK读取锁（分享锁）</li>
  <li>F_WRLCK写入锁（排斥锁）</li>
  <li>F_UNLCK解锁</li>
</ul>

<p>l_whence也有三种措施</p>

<ul>
  <li>SEEK_SET以文件开始为锁定的起始位置</li>
  <li>SEEK_CUR以现在文件读写位置为锁定的起始位置</li>
  <li>SEEK_END以文件尾为锁定的起始位置</li>
</ul>

<p><strong>Python用法:</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>test_fcntl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">signal</span><span class="o">,</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
</span><span class="line">    <span class="n">fcntl</span><span class="o">.</span><span class="n">flock</span><span class="p">(</span><span class="n">pid_file</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_UN</span><span class="p">)</span>
</span><span class="line">    <span class="n">pid_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class="line">    <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">pid_path</span><span class="p">)</span>
</span><span class="line">    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class="line">    <span class="n">pid_path</span> <span class="o">=</span> <span class="s">&#39;test.pid&#39;</span>
</span><span class="line">    <span class="n">pid_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">pid_path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
</span><span class="line">    <span class="n">fcntl</span><span class="o">.</span><span class="n">flock</span><span class="p">(</span><span class="n">pid_file</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_EX</span> <span class="o">|</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_NB</span><span class="p">)</span>
</span><span class="line">    <span class="n">pid_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
</span><span class="line">    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">&quot;Hello World&quot;</span>
</span><span class="line">        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Log4j]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/26/java-log4j/"/>
    <updated>2015-07-26T15:28:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/26/java-log4j</id>
    <content type="html"><![CDATA[<h2 id="java-log4j-">Java Log4j 使用记录</h2>

<p>Log4j即为Java的日志记录框架，除了Java语言外，它还支持其他的语言接口：C、C++、.Net和PL/SQL。说道日志框架，其他使用较多的日志框架还包括Logback、SLF4J Simple Logging、Java Util Logging，这些日志框架都是大同小异，目的都是用来记录程序运行的状态。它们的区别主要是在用法和性能上，由于日志通常涉及到IO读写磁盘（或者是阻塞或者是异步），这需要耗费时间，假设应用系统的日志比较庞大，对性能要求比较高，那么就需要好好斟酌下使用的框架。这里有个图可以直观感受下几个框架的区别：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/log%20comparision_zpstrg3kc1m.png" alt="image" /></p>

<p>上图中的数字是每秒的日志写入行数，<a href="https://docs.google.com/spreadsheet/ccc?key=0Alceaf46X4GPdHBoLTdYQ29nRDh6V1dRY00zT1FwWWc&amp;usp=sharing">点击更详细的信息</a>。</p>

<!--more-->

<h2 id="hello-word-example">Hello Word Example</h2>

<p>示例是使用maven来组织的。maven用的越多，就越觉得它的方便，不用关心jar包的管理，开发、测试和发布都只需要一行命令，还能还IDE完美的融合。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>pom.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="xml"><span class="line"><span class="nt">&lt;dependency&gt;</span>
</span><span class="line">    <span class="nt">&lt;groupId&gt;</span>log4j<span class="nt">&lt;/groupId&gt;</span>
</span><span class="line">    <span class="nt">&lt;artifactId&gt;</span>log4j<span class="nt">&lt;/artifactId&gt;</span>
</span><span class="line">    <span class="nt">&lt;version&gt;</span>1.2.17<span class="nt">&lt;/version&gt;</span>
</span><span class="line"><span class="nt">&lt;/dependency&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>创建log4j.properties文件，放在resources文件夹下，这个文件夹的路径是src/main/resources。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>log4j.properties</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="properties"><span class="line"><span class="c"># Root logger option</span>
</span><span class="line"><span class="na">log4j.rootLogger</span><span class="o">=</span><span class="s">DEBUG, stdout, file</span>
</span><span class="line">
</span><span class="line"><span class="c"># Redirect log messages to console</span>
</span><span class="line"><span class="na">log4j.appender.stdout</span><span class="o">=</span><span class="s">org.apache.log4j.ConsoleAppender</span>
</span><span class="line"><span class="na">log4j.appender.stdout.Target</span><span class="o">=</span><span class="s">System.out</span>
</span><span class="line"><span class="na">log4j.appender.stdout.layout</span><span class="o">=</span><span class="s">org.apache.log4j.PatternLayout</span>
</span><span class="line"><span class="na">log4j.appender.stdout.layout.ConversionPattern</span><span class="o">=</span><span class="s">%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</span>
</span><span class="line">
</span><span class="line"><span class="c"># Redirect log messages to a log file, support file rolling.</span>
</span><span class="line"><span class="na">log4j.appender.file</span><span class="o">=</span><span class="s">org.apache.log4j.RollingFileAppender</span>
</span><span class="line"><span class="na">log4j.appender.file.File</span><span class="o">=</span><span class="s">C:\\log4j-application.log</span>
</span><span class="line"><span class="na">log4j.appender.file.MaxFileSize</span><span class="o">=</span><span class="s">5MB</span>
</span><span class="line"><span class="na">log4j.appender.file.MaxBackupIndex</span><span class="o">=</span><span class="s">10</span>
</span><span class="line"><span class="na">log4j.appender.file.layout</span><span class="o">=</span><span class="s">org.apache.log4j.PatternLayout</span>
</span><span class="line"><span class="na">log4j.appender.file.layout.ConversionPattern</span><span class="o">=</span><span class="s">%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>说明下ConversionPattern中的符号和参数：</p>

<ol>
  <li><code>%d{yyyy-MM-dd HH:mm:ss}</code> 日期和时间</li>
  <li><code>%-5p</code> 日志优先级, 输出DEBUG、ERROR等. <code>-5</code>是可选的, 格式化输出宽度，为了更好的输出效果.</li>
  <li><code>%c{1}</code> 是日志名称，通过getLogger()设置, 可以参考<a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html">log4j PatternLayout guide</a>.</li>
  <li><code>%L</code> 打印日志的句子在源文件中的行数.</li>
  <li><code>%m%n</code> 打印的日志信息和换行符.</li>
</ol>

<p>上述设置的输出效果是：</p>

<pre><code>2014-07-02 20:52:39 DEBUG className:200 - This is debug message
2014-07-02 20:52:39 DEBUG className:201 - This is debug message2
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>HelloExample.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">import</span> <span class="nn">org.apache.log4j.Logger</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloExample</span><span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">final</span> <span class="kd">static</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">HelloExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">HelloExample</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HelloExample</span><span class="o">();</span>
</span><span class="line">        <span class="n">obj</span><span class="o">.</span><span class="na">runMe</span><span class="o">(</span><span class="s">&quot;billowkiller&quot;</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">runMe</span><span class="o">(</span><span class="n">String</span> <span class="n">parameter</span><span class="o">){</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span><span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;This is debug : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span><span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;This is info : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&quot;This is warn : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;This is error : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">fatal</span><span class="o">(</span><span class="s">&quot;This is fatal : &quot;</span> <span class="o">+</span> <span class="n">parameter</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="k">try</span><span class="o">{</span>
</span><span class="line">            <span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">ArithmeticException</span> <span class="n">ex</span><span class="o">){</span>
</span><span class="line">            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;Sorry, something wrong!&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以调整配置文件中的<code>log4j.rootLogger</code>设置日志输出的级别和<code>appender</code>，级别从低到高有DEBUG、INFO、WARN、ERROR、FATAL，一般使用INFO和ERROR。</p>

<p>顺便说一句，类似<code>logger.isDebugEnabled()</code>这种句子在源码中实在是不太美观。如果debug中间的信息不影响程序的性能还是不要使用这种句子，因为log4j自己会检查需不需要输出debug信息。</p>

<h3 id="tips">Tips</h3>

<ul>
  <li>java -calsspath *.jar 加载多个jar包，而多个jar包中可能包含多个log4j.properties的时候，系统自动加载第一个，忽略后面的。也就是说将你想要使用的log4j.properties所包含的jar文件放在classpath的第一个。</li>
  <li>mvn的package和test可以分别对应两个不同的log4j.properties中，如下：src/main/resources/log4j.properties, src/test/resources/log4j.properties。</li>
  <li><strong>需要注意程序的输出级别，用户可以定义不同的配置文件来输出不同级别的信息</strong>。这一点尤其重要：
    <ul>
      <li>工具是为程序提供服务的，在开发和调试阶段，日志可以帮助我们更好更快地定位bug；在运行维护阶段，日志系统又可以帮我们记录大部分的异常信息，从而帮助我们更好的完善系统。</li>
      <li>定义好级别和输出的日志信息，配合使用<code>grep</code>等命令行工具，可以更好的帮助我们定位错误。</li>
      <li>在设计系统之前需要先确定好日志子系统，在什么情况下程序会发生错误，输出什么样的错误信息，在debug和正常运行的时候日志如何调整，error信息是否需要另外打印。</li>
    </ul>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Practice in Recommend System]]></title>
    <link href="http://billowkiller.github.io/blog/2015/07/16/rs-note/"/>
    <updated>2015-07-16T14:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/07/16/rs-note</id>
    <content type="html"><![CDATA[<p>本文作为推荐系统实践笔记。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/11336234.jpg" width="350px" /></p>

<p>推荐系统是为了解决信息过载问题，一般说来这个问题还可以用搜索引擎解决，但是搜索引擎需要需要用户主动提供准确的关键词来寻找信息；推荐系统不需要用户提供明确的需求,而是通过分析用户的历史行为给用户的兴趣建模,从而主动给用户推荐能够满足他们兴趣和需求的信息。</p>

<p>总的来说，<strong>搜索引擎满足了用户有明确目的时的主动查找需求,而推荐系统能够在用户没有明确目的的时候帮助他们发现感兴趣的新内容</strong>。</p>

<!--more-->

<p>推荐系统可以更好地发掘物品的长尾，推荐系统通过发掘用户的行为，找到用户的个性化需求，从而将长尾商品准确地推荐给需要它的用户，帮助用户发现那些他们感兴趣但很难发现的商品。个性化推荐系统应用包括：</p>

<ul>
  <li>电子商务</li>
  <li>电影和视频网站</li>
  <li>个性化音乐网站电台</li>
  <li>社交网络</li>
  <li>个性化阅读</li>
  <li>基于位置的服务</li>
  <li>个性化邮件</li>
  <li>个性化广告</li>
</ul>

<p>一般来说,一个新的推荐算法最终上线，需要完成3个实验：</p>

<ul>
  <li>首先，需要通过离线实验证明它在很多离线指标上优于现有的算法。</li>
  <li>然后，需要通过用户调查确定它的用户满意度不低于现有算法。</li>
  <li>最后，通过在线的AB测试确定它在我们关系的指标上由于现有的算法。</li>
</ul>

<p>指标包括以下：</p>

<ol>
  <li>
    <p>用户满意度，反馈按钮，点击率，用户停留时间，转化率</p>
  </li>
  <li>
    <p>预测准确度，可以通过离线实验计算</p>

    <ul>
      <li>
        <p>评分预测的预测准确度一般通过均方根误差(RMSE)和平均绝对误差(MAE)计算。</p>

        <script type="math/tex; mode=display"> RMSE = \frac{\sqrt{\sum_{u,i \in T}(r_{ui}-\hat{r}_{ui})^2}}{\vert T \vert}，MAE = \frac{\sum_{u,i \in T} \vert r_{ui}-\hat{r}_{ui} \vert}{\vert T \vert} </script>

        <ul>
          <li>用户u和物品i，$r_{ui}$ 是用户u对物品i的实际评分，$\hat{r}_{ui}$ 是推荐算法给出的预测评分</li>
          <li>RMSE加大了对预测不准的用户物品评分的惩罚，因而对系统的评测更加苛刻；如果评分系统是基于整数建立的，那么对预测结果取整会降低MAE的误差。</li>
        </ul>
      </li>
      <li>
        <p>TopN推荐的预测准确率一般通过准确率(precision)/召回率(recall)度量</p>

        <script type="math/tex; mode=display"> Recall = \frac{\sum_{u \in U} \vert R(u) \cap T(u) \vert }{\sum_{u \in U} \vert  T(u) \vert}，Precision = \frac{\sum_{u \in U} \vert R(u) \cap T(u) \vert }{\sum_{u \in U} \vert  R(u) \vert} </script>

        <ul>
          <li>$R(u)$ 是根据用户在训练集上的行为给用户作出的推荐列表，而 $T(u)$ 是用户在测试集上的行为列表。</li>
          <li>
            <u>召回率描述有多少比例的用户—物品评分记录包含在最终的推荐列表中,而准确率描述最终的推荐列表中有多少比例是发生过的用户—物品评分记录</u>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>覆盖率</p>

    <ul>
      <li>描述一个推荐系统对物品长尾的发掘能力。表示推荐系统能够推荐出来的物品占总物品集合的比例。</li>
      <li>系统的用户集合为 $U$，推荐系统给每个用户推荐一个长度为N的物品列表 $R(u)$。</li>
      <li>物品在推荐列表中出现次数的分布描述推荐系统挖掘长尾的能力，可以用信息熵和基尼系数定义覆盖率。分配不均匀，基尼系数大，表示覆盖率低。</li>
    </ul>
  </li>
  <li>
    <p>多样性</p>

    <ul>
      <li>为了满足用户广泛的兴趣，推荐列表需要能够覆盖用户不同的兴趣领域，即推荐结果需要具有多样性，描述推荐列表物品两两之间的不相似性。</li>
    </ul>
  </li>
  <li>
    <p>新颖性</p>
  </li>
  <li>
    <p>惊喜度</p>
  </li>
  <li>
    <p>信任度</p>

    <ul>
      <li>需要增加推荐系统的透明度</li>
      <li>虑用户的社交网络信息,利用用户的好友信息给用户做推荐,并且用好友进行推荐解释</li>
    </ul>
  </li>
  <li>
    <p>实时性</p>

    <ul>
      <li>实时地更新推荐列表来满足用户新的行为变化</li>
      <li>能够将新加入系统的物品推荐给用户</li>
    </ul>
  </li>
  <li>
    <p>健壮性</p>
  </li>
</ol>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-14/24652935.jpg" width="500px" /></p>

<h2 id="section">一 利用用户行为数据</h2>

<p>存储的日志种类：</p>

<ul>
  <li>raw log：网站在运行过程中都产生大量原始日志</li>
  <li>session log：原始日志按照用户行为汇总成会话日志，其中每个会话表示一次用户行为和对应的服务</li>
  <li>impression log：展示日志，session log的一种，在搜索引擎和搜索广告系统中,服务会为每次查询生成一个展示日志，记录了查询和返回结。</li>
  <li>click log：点击了某个结果,这个点击信息会被服务器截获并存储在点击日志</li>
</ul>

<p>一个并行程序会周期性地归并展示日志和点击日志,得到的会话日志中每个消息是一个用户提交的查询、得到的结果以及点击。会话日志通常存储在分布式数据仓库中,如支持离线分析的Hadoop Hive和支持在线分析的Google Dremel。</p>

<p>用户行为在个性化推荐系统中一般分两种</p>

<ul>
  <li>显性反馈行为(explicit feedback)</li>
  <li>隐性反馈 行为(implicit feedback)</li>
</ul>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-14/78274688.jpg" width="500px" /></p>

<p>仅仅基于用户行为数据设计的推荐算法一般称为<strong>协同过滤算法</strong>，包括但不限于：</p>

<ul>
  <li>基于邻域的方法(neighborhood-based)
    <ul>
      <li>基于用户的协同过滤算法</li>
      <li>基于物品的协同过滤算法</li>
    </ul>
  </li>
  <li>隐语义模型 (latent factor model)</li>
  <li>基于图的随机游走算法(random walk on graph)</li>
</ul>

<h3 id="section-1">1.1 基于用户的协同过滤算法</h3>

<p>基于用户的协同过滤算法主要包括两个步骤。</p>

<ol>
  <li>找到和目标用户兴趣相似的用户集合。</li>
  <li>找到这个集合中的用户喜欢的,且目标用户没有听说过的物品推荐给目标用户.</li>
</ol>

<p>步骤1的关键就是计算两个用户的兴趣相似度。这里，协同过滤算法主要利用行为的相似度计算兴趣的相似度。给定用户u和用户v，$N(u)$ 表示用户u曾经有过正反馈的物品集合，$N(v)$ 为用户v曾经有过正反馈的物品集合。</p>

<p>可以通过如下的Jaccard公式简单地计算u和v的兴趣相似度:</p>

<script type="math/tex; mode=display"> w_{uv} = \frac{\vert N(u) \cap N(v) \vert}{\vert N(u) \cup N(v) \vert} </script>

<p>或者通过余弦相似度计算:</p>

<script type="math/tex; mode=display"> w_{uv} = \frac{\vert N(u) \cap N(v) \vert}{\sqrt{\vert N(u) \vert  \vert N(v) \vert}} </script>

<p>事实上,很多用户相互之间并没有对同样的物品产生过行为,即很多时候 $\vert N(u) \cap N(v) \vert = 0$。我们可以首先计算出$\vert N(u) \cap N(v) \vert \neq 0$ 的用户对 $(u,v)$，然后再对这种情况除以分母。</p>

<p>为此,可以首先建立物品到用户的倒排表,对于每个物品都保存对该物品产生过行为的用户列表。令稀疏矩阵 $C[u][v] = \vert N(u) \cap N(v) \vert$。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-15/4819139.jpg" width="300px" /></p>

<p>得到用户之间的兴趣相似度后,UserCF算法会给用户推荐和他兴趣最相似的K个用户喜欢的物品。如下的公式度量了UserCF算法中用户u对物品i的感兴趣程度:</p>

<script type="math/tex; mode=display"> p(u,i) = \sum_{v \in S(u,K) \cap N(i)} w_{uv} r_{vi} </script>

<p>其中, $S(u, K)$ 包含和用户u兴趣最接近的K个用户, $N(i)$ 是对物品i有过行为的用户集合, $w_{uv}$ 是用户u和用户v的兴趣相似度, $r_{vi}$ 代表用户v对物品i的兴趣。</p>

<p>可以使用改进的余弦相似度公式来提高UserCF的推荐性能：</p>

<script type="math/tex; mode=display"> w_{uv} = \frac{\sum_{i \in  N(u) \cap N(v)}\frac{1}{log(1+N(i))}}{\sqrt{\vert N(u) \vert  \vert N(v) \vert}} </script>

<p>该公式惩罚了用户u和用户v共同兴趣列表中热门物品对他们相似度的影响。</p>

<h3 id="section-2">1.2 基于物品的协同过滤算法</h3>

<p>基于物品的协同过滤算法(简称ItemCF)给用户推荐那些和他们之前喜欢的物品相似的物品。ItemCF算法并不利用物品的内容属性计算物品之间的相似度,它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为,物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。</p>

<p>基于物品的协同过滤算法主要分为两步。</p>

<ol>
  <li>计算物品之间的相似度。</li>
  <li>根据物品的相似度和用户的历史行为给用户生成推荐列表。</li>
</ol>

<p>可以用下面的公式定义物品的相似度, $\vert N(i) \vert$ 是喜欢物品i的用户数:</p>

<script type="math/tex; mode=display"> w_{ij} = \frac{\vert N(i) \cap N(j) \vert}{\sqrt{\vert N(i) \vert \vert N(j) \vert}} </script>

<p>上述公式惩罚了物品j的权重,因此减轻了热门物品会和很多物品相似的可能性。和UserCF算法类似,用ItemCF算法计算物品相似度时也可以首先建立用户—物品倒排表,然后对于每个用户,将他物品列表中的物品两两在共现矩阵C中加1。</p>

<p>如果j非常热门,那么上面公式的分子 就会越来越接近 $N(i)$。尽管上面的公式分母已经考虑到了j的流行度,但在实际应用中,热门的j仍然会获得比较大的相似度。可以采用下面的公式加大惩罚：</p>

<script type="math/tex; mode=display"> w_{ij} = \frac{\vert N(i) \cap N(j) \vert}{\vert N(i) \vert^{1-\alpha} \vert N(j) \vert ^{\alpha}} </script>

<p>其中 $\alpha \in [0.5 ,1]$。通过提高$\alpha$, 就可以惩罚热门的j。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-15/51979298.jpg" width="400px" /></p>

<p>在得到物品之间的相似度后,ItemCF通过如下公式计算用户u对一个物品j的兴趣:</p>

<script type="math/tex; mode=display"> p(u,j) = \sum_{i \in S(j,K) \cap N(u)} w_{ji} r_{ui} </script>

<p>这里 $N(u)$ 是用户喜欢的物品的集合, $S(j,K)$ 是和物品j最相似的K个物品的集合, $w_{ji}$ 是物品j和i的相似度, $r_{ui}$是用户u对物品i的兴趣。该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。</p>

<p>类似UserCF中的惩罚公式，ItemCF中认为不活跃的用户的贡献程度要比活跃用户更大，所以应该加上Inverse User Frequence修正物品相似度的计算公式：</p>

<script type="math/tex; mode=display"> w_{ij} = \frac{\sum_{u \in  N(i) \cap N(j)}\frac{1}{log(1+N(u))}}{\sqrt{\vert N(i) \vert  \vert N(j) \vert}} </script>

<p>另外如果将ItemCF的相似度矩阵按最大值归一化,可以提高推荐的准确率。如果已经得到了物品相似度矩阵 $w$, 那么可以用如下公式得到归一化之后的相似度 矩阵 $w’$：</p>

<script type="math/tex; mode=display"> w'_{ij} = \frac{w_{ij}}{max_j w_{ij}} </script>

<p>归一化的好处不仅仅在于增加推荐的准确度,它还可以提高推荐的覆盖率和多样性。一般来说,热门的类其类内物品相似度一般比较大。如果不进行归一化,就会推荐 比较热门的类里面的物品,而这些物品也是比较热门的。因此,推荐的覆盖率就比较低。相反, 如果进行相似度的归一化,则可以提高推荐系统的覆盖率。</p>

<h3 id="usercfitemcf">1.3 UserCF和ItemCF的综合比较</h3>

<p>UserCF给用户推荐那些和他有共同兴趣爱好的用户喜欢的物品,而ItemCF给用户推荐那些和他之前喜欢的物品类似的物品。从这个算法的原理可以看到,UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点,而ItemCF的推荐结果着重于维系用户的历史兴趣。</p>

<p>UserCF适合用于新闻推荐</p>

<ul>
  <li>可以给用户推荐有相似爱好的其他用户看的新闻，这样在抓住热点和时效性的同时，保证了一定程度的个性化。</li>
  <li>技术角度考量，物品的更新速度远远快于新用户的加入速度。</li>
</ul>

<p>ItemCF适合于图书、电子商务和电影网站等的推荐：</p>

<ul>
  <li>在这些网站中，用户的兴趣是比较固定和持久的</li>
  <li>用户不需要流行物品，而是通过自己熟悉领域的知识自己判断物品的质量</li>
  <li>从技术上考虑，用户数目往往非常庞大，物品的数目则是比较少的</li>
</ul>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-15/2625074.jpg" width="700px" /></p>

<h3 id="section-3">1.4 隐语义模型</h3>

<p>除了使用UserCF、ItemCF外，还可以对书和物品的兴趣进行分类做推荐。要解决自动地找到那些类,然后进行个性化推荐，可以使用隐含语义分析技术(latent variable analysis)，采取基于用户行为统计的自动聚类。</p>

<p>隐含语义分析技术从诞生到今天产生了很多著名的模型和方法,其中和该技术相关且耳熟能详的名词有pLSA、LDA、隐含类别模型(latent class model)、隐含主题模型(latent topic model)、 矩阵分解(matrix factorization)。</p>

<h3 id="section-4">1.5 基于图的模型</h3>

<p>如果 将个性化推荐算法放到二分图模型上,那么给用户u推荐物品的任务就可以转化为度量用户顶点 $v_u$ 和与 $v_u$ 没有边直接相连的物品节点在图上的相关性,相关性越高的物品在推荐列表中的权重就越高。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-15/23922601.jpg" width="400px" /></p>

<p>相关性高的一对顶点一般具有如下特征:</p>

<ul>
  <li>两个顶点之间有很多路径相连</li>
  <li>连接两个顶点之间的路径长度都比较短;</li>
  <li>连接两个顶点之间的路径不会经过出度比较大的顶点。</li>
</ul>

<p>基于这三个要素，可以使用一种基于随机游走的PersonRank算法：</p>

<p>假设要给用户u进行个性化推荐，可以从用户u对应的节点 $v_u$ 开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照概率 $\alpha$ 决定是继续游走，还是停止这次游走并从 $v_u$ 节点开始重新游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。这样，经过很多次随机游走后，每个物品节点被访问到的概率会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-15/56306116.jpg" width="500px" /></p>

<h2 id="section-5">二 推荐系统冷启动问题</h2>

<p>冷启动问题(cold start)主要分3类。</p>

<ul>
  <li><strong>用户冷启动</strong>  用户冷启动主要解决如何给新用户做个性化推荐的问题。当新用户到来时，我们没有他的行为数据，所以也无法根据他的历史行为预测其兴趣，从而无法借此给他做个性化推荐 </li>
  <li><strong>物品冷启动</strong>  物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。 </li>
  <li><strong>系统冷启动</strong>  系统冷启动主要解决如何在一个新开发的网站上设计个性化推荐系统,从而在网站刚发布时就让用户体验到个性化推荐服务这一问题。</li>
</ul>

<p>对于这3种不同的冷启动问题,有不同的解决方案。一般来说,可以参考如下解决方案</p>

<ul>
  <li><strong>提供非个性化的推荐</strong>   非个性化推荐的最简单例子就是热门排行榜,我们可以给用户推荐热门排行榜,然后等到用户数据收集到一定的时候,再切换为个性化推荐。</li>
  <li>利用用户注册时提供的年龄、性别等数据做粗粒度的个性化推荐。</li>
  <li>利用用户的社交网络获取好友信息，然后给用户推荐好友喜欢的物品。</li>
  <li>要求用户登录时对一些物品进行反馈，收集用户对这些物*品的兴趣信息，然后给用户推荐那些和这些物品相似的物品。</li>
  <li>对于新加入的物品,可以利用内容信息，将它们推荐给喜欢过和它们相似的物品的用户。</li>
  <li>在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表。</li>
</ul>

<p>可以用一个决策树解决启动用户兴趣的物品问题：</p>

<p>首先,给定一群用户用这群用户对物品评分的方差度量这群用户兴趣的一 致程度。如果方差很大,说明这一群用户的兴趣不太一致,反之则说明这群用户的兴趣比较一致。</p>

<script type="math/tex; mode=display">D(i) = \sigma_{u \in N^+(i)} + \sigma_{u \in N^-(i)} + \sigma_{u \in N^*(i)}</script>

<p>其中，$N^+(i)$ 是喜欢物品i的用户集合，$N^-(i)$ 是不喜欢物品i的用户集合，$N^*(i)$ 是没有对物品
i评分的用户集合。</p>

<p>接着会从所有用户中找到具有最高区分度的物品i，然后将用户分成3 类。接着在每类用户中再找到最具区分度的物品，如此迭代到叶子节点。</p>

<h3 id="section-6">2.1 利用物品的内容信息</h3>

<p>UserCF算法对物品冷启动问题并不非常敏感。因为，UserCF在给用户进行推荐时，首先找到和用户兴趣相似的一群用户，然后给用户推荐这一群用户喜欢的物品。那么需要解决的是第一个用户从哪儿发现新的物品。可以考虑利用物品的 内容信息,将新物品先投放给曾经喜欢过和它内容相似的其他物品的用户。</p>

<p>对于ItemCF算法来说,物品冷启动就是一个严重的问题。新物品的加入需要更新物品相似度表，但这个操作非常耗时。为此,我们只能利用物品的内容信息计算物品相关表，并且频繁地更新相关表(比如半小时计算一次)。</p>

<p>物品的内容可以通过向量空间模型表示，该模型会将物品表示成一个关键词向量。每个关键词都有权重，可以用TF-IDF表示。得到向量后，就可以用余弦相似度等计算物品的相似度。这里同样可以建立关键词—物品的倒排表加速文档集合相似度的计算过程。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-15/58154911.jpg" width="400px" /></p>

<p>另外，如果两篇文章的关键词虽然不同，但关键词所属的话题是相同的时，可以使用话题模型，代表算法是LDA。</p>

<blockquote>
  <p>任何模型都有一个假设，LDA作为一种生成模型，对一篇文档产生的过程进行了建模。话题模型的基本思想是，一个人在写一篇文档的时候，会首先想这篇文章要讨论哪些话题，然后思考这些话题应该用什么词描述，从而最终用词写成一篇文章。因此，文章和词之间是通过话题联系的。</p>
</blockquote>

<h2 id="section-7">三 利用用户标签数据</h2>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/51079519.jpg" width="500px" /></p>

<p>上图中的第三种方式是通过一些特征(feature)联系用户和物品，给用户推荐那些具有用户喜欢的特征的物品。特征有不同的表现方式</p>

<ul>
  <li>物品的属性集合</li>
  <li>隐语义向量(latent factor vector)</li>
  <li>物品的标签，包括作者或者专家给物品打标签;另一种是UGC标签</li>
</ul>

<p>UGC的标签系统是一种表示用户兴趣和物品语义的重要方式。当一个用户对一个物品打上一个标签，这个标签一方面描述了用户的兴趣，另一方面则表示了物品的 语义，从而将用户和物品联系了起来。</p>

<p>一个简单的算法如下：</p>

<ul>
  <li>统计每个用户最常用的标签。</li>
  <li>对于每个标签，统计被打过这个标签次数最多的物品。</li>
  <li>对于一个用户，首先找到他常用的标签，然后找到具有这些标签的最热门物品推荐给这个用户。</li>
</ul>

<p>用户u对物品i的兴趣公式为：$p(u,i)=\sum_b n_{u,b} n_{b,i}$</p>

<p>$B(u)$ 是用户u打过的标签集合, $B(i)$ 是物品i被打过的标签集合, $n_{u,b}$ 是用户u打过标签b的次数, $n_{b,i}$是物品i被打过标签b的次数。</p>

<p>可以进行如下改进：</p>

<ul>
  <li>TF-IDF： 上式给热门标签和物品过大的权重,从而不能反应用户个性化的兴趣。改进公式如下，$n_b^{(u)}$ 记录了标签b被多少个不同的用户使用过，$n_i^{(u)}$记录了物品i被多少个不同的用户打过标签：</li>
</ul>

<script type="math/tex; mode=display"> p(u,i)=\underset{b}{sum} \frac{n_{u,b}}{log(1+n_b^{(u)})} \frac{n_{b,i}}{log(1+n_i^{(u)})}</script>

<ul>
  <li>
    <p>数据稀疏性：通过标签扩展解决，方法包括话题模型，基于邻域的方法（从数据中统计出标签的相似度）</p>
  </li>
  <li>
    <p>标签清理：只保留正向推荐的标签词；另外可以将标签作为推荐解释。</p>
  </li>
</ul>

<h2 id="section-8">四 利用上下文信息</h2>

<p>用户所处的上下文(context)包括用户访问推荐系统的时间、地点、心情等。时间信息对于用户兴趣的影响表现在以下几个方面：</p>

<ul>
  <li>用户兴趣是变化的</li>
  <li>物品是有生命周期和时效性
    <ul>
      <li>物品平均在线天数</li>
      <li>相隔T天系统物品流行度向量的平均相似度</li>
    </ul>
  </li>
  <li>季节效应</li>
</ul>

<p>实现推荐系统的实时性除了对用户行为的存取有实时性要求，还要求推荐算法本身具有实时性，推荐算法实时性意味着：</p>

<ul>
  <li>要求在每个用户访问推荐系统时，都根据用户这个时间点前的行为实时计推荐列表。</li>
  <li>需要平衡考虑用户的近期行为和长期行为。</li>
</ul>

<p>推荐系统每天推荐结果的变化程度被定义为推荐系统的时间多样性。首先，需要保证推荐系统能够在用户有了新的行为后及时调整推荐结果，使推荐结果满足用户最近的兴趣；其次，需要保证推荐系统在用户没有新的行为时也能够经常变化一下结果，具有一定的时间多样性。</p>

<p>如果用户没有行为，可以：</p>

<ul>
  <li>在生成推荐结果时加入一定的随机性。</li>
  <li>记录用户每天看到的推荐结果，对之前的推荐结果进行降权。</li>
  <li>每天给用户使用不同的推荐算法。</li>
</ul>

<h3 id="section-9">4.1 时间上下文推荐算法</h3>

<ol>
  <li>
    <p>最近最热门</p>

    <p>给定时间T, 物品i最近的流行度 $n_i(T)$ 可以定义为</p>

    <script type="math/tex; mode=display">% &lt;![CDATA[
n_i(T)=\underset{(u,i,t) \in Train, t<T}{\Sigma} \frac{1}{1+\alpha (T-t)} %]]&gt;</script>
  </li>
  <li>
    <p>时间上下文相关的ItemCF算法</p>

    <ul>
      <li>用户在相隔很短的时间内喜欢的物品具有更高相似度</li>
      <li>用户近期行为相比用户很久之前的行为,更能体现用户现在的兴趣。</li>
    </ul>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/45373851.jpg" width="600px" /></p>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/9416103.jpg" width="350px" /></p>

    <p>其中, $t_0$ 是当前时间。</p>
  </li>
  <li>
    <p>时间上下文相关的UserCF算法</p>
    <ul>
      <li>类似于ItemCF算法，在权重和预测部分增加时间衰减因子</li>
      <li>对于用户u和用户v共同喜欢的物品i增加了一个时间衰减因子。</li>
      <li>考虑和用户u兴趣相似用户的最近兴趣</li>
    </ul>
  </li>
</ol>

<h2 id="section-10">五 利用社交网络数据</h2>

<p>社会化推荐之所以受到很多网站的重视，是缘于如下优点：</p>

<ul>
  <li>好友推荐可以增加推荐的信任度</li>
  <li>社交网络可以解决冷启动问题</li>
</ul>

<ol>
  <li>
    <p>基于邻域的社会化推荐算法</p>

    <p>也就是给用户推荐好友喜欢的物品集合。$p_{ui} = \underset{v \in out(u)}{\Sigma} w_{uv} r_{vi}$</p>

    <p>其中 $out(u)$ 是用户u的好友集合，如果用户v喜欢物品i，则 $r_{vi}=1$，否则 $r_{vi}=0$。$w_{uv}$ 由两部分相似度构成，一部分是用户u和用户v的熟悉程度，另一部分是用户u和用户v的兴趣相似度。</p>

    <script type="math/tex; mode=display"> familiarity(u,v) = \frac{\vert out(u) \cap out(v) \vert}{\vert out(u) \cup out(v) \vert}</script>

    <script type="math/tex; mode=display"> similiarity(u,v) = \frac{\vert N(u) \cap N(v) \vert}{\vert N(u) \cup N(v) \vert}</script>

    <p>其中 $N(u)$ 是用户u喜欢的物品集合。</p>
  </li>
  <li>
    <p>基于图的社会化推荐算法</p>

    <p>在社交网站中存在两种关系，一种是用户对物品的兴趣关系，一种是用户之间的社交网络关系。需要将这两种关系建立到图模型中。</p>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/68899610.jpg" width="300px" /></p>

    <p>该图上有用户顶点（圆圈）和物品顶点（方块）两种顶点。在定义完图中的顶点和边后,需要定义边的权重。其中用户和用户之间边的权重可以定义为用户之间相似度的 $\alpha$ 倍（包括熟悉程度和兴趣相似度）,而用户和物品之间的权重可以定义为用户对物品喜欢程度的 $\beta$ 倍。$\alpha,\beta$ 根据应用的需求确定。</p>
  </li>
</ol>

<p>大型网站中用户数目、历史行为记录非常庞大，所以不太可能将用户的所有行为都缓存在内存中，只能在数据库前做一个热数据的缓存。如果我们需要比较实时的数据，这个缓存中的数据就要比较频繁地更新，因而避免不了数据库的查询。数据库查询一般是很慢的，所以在实际做推荐时获取用户历史行为数据比较困难。</p>

<p>可以从几个方面改进基于邻域的社会化推荐算法,让它能够具有比较快的响应时间:</p>

<ul>
  <li>只拿出和用户相似度最高的N个好友；只返回用户最近1个月的行为。</li>
  <li>重新设计数据库
    <ul>
      <li>首先，为每个用户维护一个消息队列，用于存储他的推荐列表;</li>
      <li>当一个用户喜欢一个物品时，就将(物品ID、用户ID和时间)这条记录写入关注该用户的推荐列表消息队列中;</li>
      <li>当用户访问推荐系统时，读出他的推荐列表消息队列，对于这个消息队列中的每个物品，重新计算该物品的权重。</li>
    </ul>
  </li>
</ul>

<u>对比于协同过滤推荐，社会化推荐的优势不在于增加预测准确度，而是在于通过用户的好友增加用户对推荐结果的信任度，从而让用户单击那些很冷门的推荐 结果。</u>

<p>信息流推荐可以参考Facebook的EdgeRank算法。</p>

<p>另外好友推荐算法在社交网络上被称为链接预测(link prediction)，可以基于以下方法做推荐：</p>

<ul>
  <li>基于内容的匹配</li>
  <li>基于共同兴趣的好友推荐</li>
  <li>基于社交网络图的好友推荐</li>
</ul>

<h2 id="section-11">六 推荐系统实例</h2>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/94386004.jpg" width="400px" /></p>

<p>从实时存取的角度上看，购买、收藏、评论、评分、分享等行为都是需要实时存取的，因为只要用户有了这些行为，界面上就需要体现出来，比如用户购买了商品后，用户的个人购买列表中就应立即显示用户购买的商品。而有些行为，比如浏览网页的行为和搜索行为并不需要实时存取。</p>

<p>数据能否实时存取在推荐系统中非常重要，因为推荐系统的实时性主要依赖于能否实时拿到用户的新行为。只有快速拿到大量用户的新行为，推荐系统才能够实时地适应用户当前的需求，给用户进行实时推荐。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/79737632.jpg" width="600px" /></p>

<p>推荐系统由多个推荐引擎组成，每个推荐引擎负责一类特征和一种任务，而推荐系统的任务只是将推荐引擎的结果按照一定权重或者优先级合并、排序然后返回。多个推荐引擎还可以：</p>

<ul>
  <li>可以方便地增加/删除引擎,控制不同引擎对推荐结果的影响。</li>
  <li>可以实现推荐引擎级别的用户反馈。</li>
</ul>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/32415777.jpg" width="500px" /></p>

<p>如上图所示推荐引擎架构主要包括3部分：</p>

<ul>
  <li>该部分负责从数据库或者缓存中拿到用户行为数据，通过分析不同行为，生成当前用户的特征向量。不过如果是使用非行为特征，就不需要使用行为提取和分析模块了。该模块的输出是用户特征向量。</li>
  <li>该部分负责将用户的特征向量通过特征-物品相关矩阵转化为初始推荐物品列表。</li>
  <li>该部分负责对初始的推荐列表进行过滤、排名等处理，从而生成最终的推荐结果。</li>
</ul>

<p>具体对不同部分解释下。</p>

<ol>
  <li>
    <p><strong>用户特征向量</strong>包括两种：</p>

    <ul>
      <li>用户的注册信息中可以提取出来的,主要包括用户 的人口统计学特征。</li>
      <li>
        <p>从用户的行为中计算出来的，需要考虑：</p>

        <ul>
          <li>用户行为的种类（按行为的成本划分）</li>
          <li>用户行为产生的时间，近期行为比较重要</li>
          <li>用户行为的次数</li>
          <li>物品的热门程度</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>特征—物品相关推荐</p>

    <p>在得到用户的特征向量后,我们可以根据离线的相关表得到初始的物品推荐列表。在线使用的特征物品相关表一般都不止一张，推荐引擎可以在配置文件中配置很多相关表以及它们的权重。</p>

    <p>特征—物品相关推荐模块还可以接受一个候选物品集合。候选物品集合的目的是保证推荐结果只包含候选物品集合中的物品。</p>
  </li>
  <li>
    <p>过滤模块</p>

    <ul>
      <li>用户已经产生过行为物品</li>
      <li>候选物品以外的物品</li>
      <li>某些质量很差的物品</li>
    </ul>
  </li>
  <li>
    <p>排名模块</p>

    <ul>
      <li>新颖性排名，对推荐结果中热门的物品进行降权。</li>
      <li>多样性，推荐结果分类；控制不同推荐结果的推荐理由出现的次数。</li>
      <li>时间多样性</li>
      <li>用户反馈，通过分析用户之前和推荐结果的交互日志，预测用户会对什么样的推荐结果比较感兴趣。
        <ul>
          <li>CTR预测</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="section-12">七 评分预测问题</h2>

<p>前面主要介绍TopN推荐，因为它非常接近于满足实际系统的需求。评分预测问题却是推荐系统研究的核心。</p>

<ol>
  <li>
    <p>基于邻域的方法</p>

    <p>基于用户的邻域算法和基于物品的邻域算法都可以应用到评分预测中。基于用户的邻域算法：</p>

    <script type="math/tex; mode=display">\hat{r}_{ui} = \overline{r}_u + \frac{\sum_{v \in S(u,K) \cap N(i)} w_{uv}(r_{vi} -\overline{r}_v)}{\sum_{v \in S(u,K) \cap N(i)} \vert w_{uv} \vert}</script>

    <p>这里, $S(u, K)$ 是和用户u兴趣最相似的K个用户的集合, $N(i)$ 是对物品i评过分的用户集合, $r_{vi}$ 是用户v对物品i的评分, $\overline{r}_v$ 是用户v对他评过分的所有物品评分的平均值。$w_{uv}$ 是相似度，有以下几种：</p>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/86649362.jpg" width="420px" /></p>

    <p>基于物品的领域算法类似。</p>
  </li>
  <li>
    <p>隐语义模型与矩阵分解模型</p>

    <p>传统的SVD分解有一下几个缺点：</p>

    <ul>
      <li>该方法首先需要用一个简单的方法补全稀疏评分矩阵。</li>
      <li>该方法依赖的SVD分解方法的计算复杂度很高</li>
    </ul>

    <p>基于此，Simon Funk提出的基于新的矩阵分解方法Latent Factor Model (LFM)。</p>

    <p>将评分矩阵R分解为两个低维矩阵相乘 $\hat{R} = P^TQ$，其中 $P_{f \times m}$ 和 $Q_{f \times n}$ 是两个降维后的矩阵。那么，对于用户u对物品i的评分的预测值 $\hat{R}(u,i)=\hat{r}_{ui}$，可以表示为 $\hat{r}_{ui} = \sum_f p_{uf} q_{if}$。</p>

    <p>Simon Funk的思想很简单:可以直接通过训练集中的观察值利用最小化RMSE学习P、Q矩阵。</p>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/90816576.jpg" width="620px" /></p>

    <p>要最小化上面的损失函数，可以利用随机梯度下降法。</p>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/9179243.jpg" width="620px" /></p>
  </li>
  <li>
    <p>加入偏置项后的LFM</p>

    <p>LFM预测公式通过隐类将用户和物品联系在了一起。但是，实际情况下，一个评分系统有些固有属性和用户物品无关，而用户也有些属性和物品无关，物品也有些属性和用户无关。所以提出加入偏置项后的LFM：</p>

    <script type="math/tex; mode=display">\hat{r}_{ui} = \mu + b_u + b_i + p_u^T \cdot q_i</script>

    <p>$\mu$ 是训练集中所有记录的评分的全局平均数。$b_u$ 是用户偏置(user bias)项，表示了用户的评分习惯中和物品没有关系的因素。$b_i$ 是物品偏置(item bias)项，表示了物品接受的评分中和用户没有什么关系的因素。</p>

    <p>$b_u,b_i$ 通过机器学习训练出来的。同样可以求导，然后用梯度下降法求解这两个参数。</p>
  </li>
  <li>
    <p>考虑邻域影响的LFM</p>

    <p>前面的LFM模型中并没有显式地考虑用户的历史行为对用户评分预测的影响。新的算法成为SVD++。可以将ItemCF的预测算法改成如下方式:</p>

    <p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-3-16/88102444.jpg" width="620px" /></p>
  </li>
</ol>

<p>另外还可以增加时间因素进行考虑。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Virtual Machine]]></title>
    <link href="http://billowkiller.github.io/blog/2015/06/30/jvm/"/>
    <updated>2015-06-30T17:23:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/06/30/jvm</id>
    <content type="html"><![CDATA[<p>最近在做hadoop和spark的诊断调优工具，用的是java。有段时间没有用了，所以这里记录下JVM相关的知识。</p>

<p>James Gosling曾说过”大部分人大谈特谈JAVA语言，这对于我来说也许听起来很奇怪，但是我无法不去在意。JVM才是Java生态系统的核心“。最近比较流行Spark使用的Scala，Storm使用的Clojure，还有像Groovy，JPython等都是基于JVM的语言。摘自<a href="https://www.zhihu.com/question/20003582/answer/13649045">知乎上的一段话</a>，说明JVM特点：</p>

<ul>
  <li>非常经济地实现跨平台。你的语言编译器后端只需要输出 JVM 字节码就可以。跨平台需要极大的工作量，举个例子，只是独立开发生成本地代码，就需要花费大量精力去针对不同平台和处理器进行优化（比如 Firefox 就会考虑重用 WebKit 的这部分后端）。 </li>
  <li>JVM 卓越的 JIT （Just-In-Time 即时编译）性能。 JIT 可以在运行中记录程序运行的特征，并在其基础上做大量的优化（Java 企业级应用的优秀性能很大程度上是由此而来）。 JIT 自从 HotSpot JVM 随 Java 1.2 发布以来，JVM JIT 的性能不断提高，是无可争议的成功产品。把 JVM 作为目标平台意味着大量的性能优化工作可以「外包」给 JVM 来做，大大缩减了 Guest 语言的开发预算。</li>
  <li>已经有多个成熟的实例，有大量的经验可以借鉴</li>
  <li>JVM 作为一个成熟的高层运行环境，为 Guest 语言提供了很多运行时所需要的服务，比如内存管理（有业界领先的垃圾回收等），很大程度上避免了额外的独立开发。</li>
  <li>JVM 有多个独立实现，也有若干厂商会持续推进，资料完备，社区巨大。</li>
  <li>Java 社区有大量成熟的库，一般来说，运行在 JVM 上的其它语言都会设计一个专用的「桥」来帮助直接使用 Java 的库，对潜在客户来说是个很好的卖点。</li>
  <li>Java 有还算不错的开发工具和环境。目标为 JVM 的很多语言会考虑用 Java 语言实现（至少在 bootstrap 阶段）。</li>
</ul>

<p>C++与JAVA运行时的区别可以参考下图：</p>

<p><img src="http://img2.ph.126.net/V9_jvXWPddh6LVsL1E9b3g==/1276489019400160092.jpg" width="500px" /></p>

<p>那么接下来就谈谈JVM。</p>

<h2 id="memory-model">Memory Model</h2>

<p>首先是看看JVM内存模型，分哪几个区，每个区的作用是什么？</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-30/37908210.jpg" width="600px" /></p>

<p>上图是JVM的内存模型：</p>

<ul>
  <li>
    <p>方法区：</p>

    <ul>
      <li>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</li>
      <li>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</li>
      <li>该区域是被线程共享的。</li>
      <li>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</li>
    </ul>
  </li>
  <li>
    <p>虚拟机栈:</p>

    <ul>
      <li>虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</li>
      <li>虚拟机栈是线程私有的，它的生命周期与线程相同。</li>
      <li>局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</li>
      <li>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</li>
      <li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</li>
    </ul>
  </li>
  <li>
    <p>本地方法栈</p>

    <ul>
      <li>本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。</li>
    </ul>
  </li>
  <li>
    <p>堆</p>

    <ul>
      <li>java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</li>
    </ul>
  </li>
  <li>
    <p>程序计数器</p>

    <ul>
      <li>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</li>
    </ul>
  </li>
</ul>

<h2 id="gabage-collection">Gabage Collection</h2>

<p>Java是由虚拟机自动释放内存的。在JVM中，有一个垃圾回收线程Finalize，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>

<p><strong>GC对象的判定方法主要有两种:</strong></p>

<ol>
  <li>引用计数法: 无法解决循环引用问题。</li>
  <li>可达性算法(引用链法): 从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</li>
</ol>

<p>当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记。</p>

<p>如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法或者已被虚拟机调用过，那么就认为是没必要的。</p>

<p><strong>java中垃圾收集的方法有一下几种：</strong></p>

<ol>
  <li>标记-清除</li>
  <li>复制算法： 内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。</li>
  <li>标记-整理：该算法主要是为了解决标记-清除产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</li>
</ol>

<p>现在的虚拟机垃圾收集大多采用分代回收，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-30/61991650.jpg" width="600px" /></p>

<p><strong>分配策略和GC过程如下：</strong></p>

<ul>
  <li>对象优先在堆的Eden区分配。</li>
  <li>大对象直接进入老年代.</li>
  <li>长期存活的对象将直接进入老年代.</li>
</ul>

<p>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC。Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快；Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p>

<p>几种垃圾收集器可以参考<a href="http://www.zicheng.net/article/55.htm">http://www.zicheng.net/article/55.htm</a></p>

<h2 id="section">类加载过程</h2>

<p>类加载是虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>

<p>类加载有个<strong>双亲委派模型机制</strong>，是指当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>

<p>主要有一下四种类加载器:</p>

<ol>
  <li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
  <li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
  <li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过<code>ClassLoader.getSystemClassLoader()</code>来获取它。</li>
  <li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。类似一些静态类UT类就是采用这种方式。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Random Process]]></title>
    <link href="http://billowkiller.github.io/blog/2015/05/09/random-process/"/>
    <updated>2015-05-09T16:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/05/09/random-process</id>
    <content type="html"><![CDATA[<p>本文用来记录一些随机过程。随机过程是处理包含时间以及数据序列的概率模型。可用于一下数据序列的建模：</p>

<ul>
  <li>每天的股票价格数据序列</li>
  <li>交通网络中的每个点的交通负荷数据序列</li>
  <li>雷达对飞机的定位数据序列</li>
</ul>

<p>序列中的每个数据都视为一个随机变量，所以随机序列就是一串有限或无限的随机变量序列，但是更加强调：</p>

<ul>
  <li>过程中产生的数据序列之间的<strong>相关</strong>关系。比如股票的未来价格与历史价格关系。</li>
  <li>对整个过程中<strong>长期均值</strong>感兴趣。比如有多大比例的时间机器出于闲置。</li>
  <li>需要刻画某些<strong>边界事件</strong>的似然或频率。在给定时间内，线路同时出于忙碌的概率，计算机网络中缓冲器数据溢出的频率。</li>
</ul>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-4-16/62147816.jpg" width="500px" /></p>

<p>下面讨论几个随机过程。</p>

<!--more-->

<h2 id="section">伯努利过程和泊松过程</h2>

<p>这两个过程重点研究的是<strong>相邻到达时间是互相独立的随机变量</strong>的模型。区别在于：</p>

<ul>
  <li>伯努利（Bernoulli）过程考虑到达时间是<code>离散</code>的情形，相邻时间服从<code>几何分布</code>。</li>
  <li>泊松（Poisson）过程考虑到达时间是<code>连续</code>的情形，相邻时间服从<code>指数分布</code>。</li>
</ul>

<h3 id="section-1">伯努利过程</h3>

<p>通常将伯努利过程视为独立投币序列，正面朝上的概率是 $p,\ 0&lt;p&lt;1$。这里把硬币朝上视为“到达”，连续投币产生伯努利过程。下面给出伯努利过程相关的随机变量和性质：</p>

<ul>
  <li>服从参数为 $n$ 和 $p$ 的二项分布。这是 $n$ 次相继独立的实验成功的总次数 $S$ 的分布，有</li>
</ul>

<script type="math/tex; mode=display"> P_S(k) =  \binom{k}{n} p^k (1-p)^{n-k},\ k = 0,1,..n </script>

<script type="math/tex; mode=display">E(S) = np,\ var(S)=np(1-p)</script>

<ul>
  <li>服从参数为 $p$ 的集合分布。这是相互独立重复的伯努利试验首次成功时刻T的分布，有</li>
</ul>

<script type="math/tex; mode=display"> P_T(t) = p(1-p)^{t-1},\ t=1,2,...</script>

<script type="math/tex; mode=display"> E(T) = \frac{1}{p},\ var(T) = \frac{1-p}{p^2}</script>

<p>伯努利过程有<strong>独立性</strong>和<strong>无记忆性</strong>。假设我们观测过程 $n$ 步，但是还没有成功。那么余下的 $T-n$ 有什么结论呢？</p>

<script type="math/tex; mode=display"> P(T-n=t \vert T>n) = (1-p)^{t-1}p = P(T=t),\ t=1,2,...</script>

<p>可以看到未来试验次数仍然是相同的集合分布。</p>

<p>当 $n$ 充分大，而 $p$ 很小，均值 $np$ 始终。数学上，我们可以让 $n$ 增大，但是同时缩小 $p$，这样可以保值 $np$ 是一个固定值 $\lambda$，从极值意义上看，二项分布的分布列可以简化为泊松分布。</p>

<h3 id="section-2">泊松分布</h3>

<p>跟伯努利过程相比，泊松过程是连续时间轴上的到达时间。</p>

<p>伯努利过程无法刻画相同时间段内，发生两次或者多次到达事件，虽然可以通过将时间段选的非常小，但是无法选择一个准确的小时间段。这时候考虑时间段长度趋近于零的情况，即连续时间模型。</p>

<p>泊松过程相关的随机变量和性质：</p>

<ul>
  <li>服从参数为 $\lambda \tau$ 的<strong>泊松分布</strong>。这是泊松过程的强度为 $\lambda$，在时间长度为 $\tau$ 的区间内到达的总次数 $N_\tau$ 的分布，有</li>
</ul>

<script type="math/tex; mode=display"> P_{N_\tau}(k) = P(k,\tau) = e^{-\lambda \tau} \frac{(\lambda \tau)^k}{k!},\ k=0,1,...</script>

<script type="math/tex; mode=display"> E(N_\tau) = \lambda \tau,\ var(N_\tau) = \lambda \tau</script>

<ul>
  <li>服从参数为 $\lambda$ 的<strong>指数分布</strong>，这是首次达到的时间 $T$ 的分布，有</li>
</ul>

<script type="math/tex; mode=display">f_T(t) = \lambda e^{-\lambda t},\ t \ge 0,\ E(T)=\frac{1}{\lambda},\ var(T)=\frac{1}{\lambda^2}</script>

<p>上式可以将一个固定长度为 $\tau$ 的时间区间分成一个个小区间，将小区间看成伯努利过程来近似。</p>

<h3 id="section-3">马尔可夫链</h3>

<p>马尔可夫链的定义是一种随机过程，它描述了一种状态序列，其每个状态值取决于前面的状态。用以下公式表示马尔可夫性质：</p>

<script type="math/tex; mode=display">p(\theta^{(t+1)} \vert \theta^{(1)},\theta^{(2)},..\theta^{(t)}) = p(\theta^{(t+1)} \vert \theta^{(t)}) </script>

<p>状态之间的转换通过 transition kernel，这是一个 $k \times k$ 矩阵，$k$ 表示状态数。一个 $3 \times 3$ 的转换矩阵 $P$ 如下：</p>

<p><img src="http://7xqfqs.com1.z0.glb.clouddn.com/16-6-1/92862152.jpg" alt="" /></p>

<p>马尔可夫链有一个平稳分布，stationary distribution $\pi$，定义为：$\pi = \pi P$。无论起始状态是什么样，马尔可夫链通常会收敛到 $\pi$ 上。</p>

<p>通常会根据所选的起始状态，有这不同的收敛时间。在利用马尔可夫链进行抽样时，在收敛之前的一段时间，比如前 $n-1$ 次迭代，各个状态的边际分布还不能认为是稳定分布，所以在进行估计的时候，应该把前面的这$n-1$ 个迭代值去掉。这个过程称为 <code>burn-in</code>。这样会使我们的抽样更加接近平稳分布，减少对起始位置的依赖。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recommender System in a Nutshell]]></title>
    <link href="http://billowkiller.github.io/blog/2015/04/10/recsys-introduction/"/>
    <updated>2015-04-10T14:00:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2015/04/10/recsys-introduction</id>
    <content type="html"><![CDATA[<p>推荐系统（Recommender System An Introduction）读书笔记。</p>

<!--more-->

<h2 id="section">基于内容的推荐系统</h2>

<p>基于内容的推荐：基于两类信息，<code>物品特征的描述</code>和描述用户兴趣的<code>用户记录</code>（比如喜爱的物品特点）。</p>

<p>一般工作原理是评估用户还没有看到的物品与当前用户过去喜欢的物品的相似度。那么如何表示物品的内容以及相似度？</p>

<p>描述物品目录最简单的方法就是维护每个物品特征的详细列表，<strong>属性集、特征集或物品记录</strong>。另外可以使用<code>关键词列表</code>表示文档内容，好处是能够从文档内容本身自动生成列表。</p>

<p>为了防止<code>通用词</code>和<code>长文档</code>带来的推荐结果偏置，一般会使用TF-IDF计算关键词的权重。给出下列公式：</p>

<script type="math/tex; mode=display"> TF(i, j) = \frac{freq(i,j)}{maxOthers(i,j)},\ IDF(i) = log\frac{N}{n(i)} </script>

<script type="math/tex; mode=display"> TF-IDF(i, j) = TF(i,j) \cdot IDF(i) </script>

<p>$TF(i,j)$ 表示文档 $j$ 中关键词 $i$ 的<code>归一化词频值</code>，$freq(i,j)$ 表示 $i$ 在 $j$ 中出现的绝对频率； $maxOthers(i,j)$ 表示 $j$ 中其他关键词的最大词频。 $N$ 为所有可推荐文档数量，$n(i)$ 为关键词 $i$ 出现过文档的数量。</p>

<p>归一化是针对长文档，IDF 是针对通用词</p>

<p>从文本中抽取关键词并赋予权值的做法局限性为</p>

<ul>
  <li>向量通常大而稀疏，通过以下几种技术改进：
    <ul>
      <li>停用词和词干还原</li>
      <li>特征选择，仅用信息量最大的一些词来减少文档描述规模，期望删除噪声。</li>
      <li>选用短语</li>
    </ul>
  </li>
  <li>没有考虑到文档上下文</li>
</ul>

<p>User-CF为“推荐相似用户喜欢的物品”，基于内容的推荐可以描述成“推荐与用户过去喜欢的物品相似的物品”。通常的基于内容相似度检索技术为：</p>

<ul>
  <li>KNN
    <ul>
      <li>用余弦相似度评估两个文档的向量是否相似；</li>
      <li>可以考虑用户的短期兴趣和长期兴趣，适合于个性化的新闻推荐；</li>
      <li>易于实现，能够快速适应新近变化，只需要相对少的评分数据；</li>
      <li>预测精确度较低。</li>
    </ul>
  </li>
  <li>相关项反馈——Rocchio方法</li>
</ul>

<p>另外可以将基于内容的推荐看成分类问题。</p>

<p>典型的是朴素贝叶斯方法，基本上有两种对文档及其特征建模的方法：<strong>多项式模型和伯努利模型</strong>，二者都忽略词的<code>位序</code>问题。多元伯努利模型中，文档被处理成一个二进制向量，描述某个词是否包含在文档中；多项式模型中，考虑词出现在文档中的次数，分类结果会比莫努力模型好些。</p>

<p>在多项式模型中，词 $v_i$ 出现在 $c$ 类文档的条件概率为：</p>

<table>
  <tbody>
    <tr>
      <td>$$ P(v_i</td>
      <td>C=c) = \frac{CountTerms(v_i, docs(c))+1}{AllTerms(docs(c))+\vert V \vert}$$</td>
    </tr>
  </tbody>
</table>

<p>上式采用<code>拉普拉斯平滑</code>以防止条件概率为 0，$\vert V \vert$ 为所有文档中不同词的数量。</p>

<p>朴素贝叶斯分类器能够达到很高的精确度，并且其组成部分能够在获得新数据时很容易更新，且学习时间复杂度随样本数量线性增加。</p>

<p>上文提到过<code>特征选择</code>问题，原始的大而稀疏向量会导致性能和内存需求问题，并且容易导致过拟合。典型的可以采用 $\chi^2$ 检验或 Fisher 判别指标。</p>

<p>$\chi^2$ 检验是检测两个时间是否不相干的标准统计方法。在特征选择中，根据训练数据分析某种分类结果是否与某个具体词的出现有联系。基于$\chi^2$ 检验来选择特征，首先按词的$\chi^2$ 值大小降序排列；其次需要确定用于分类器的理想特征数目。</p>

<p>基于内容的推荐系统有许多局限：</p>

<ul>
  <li><strong>浅层内容分析</strong>。</li>
  <li>推荐结果缺乏新颖性，倾向于给出相同的推荐。</li>
  <li>冷启动问题，需要来自用户的初始评分集合。</li>
</ul>

<h2 id="section-1">协同过滤</h2>

<p>协同过滤推荐方法的主要思想：利用已有用户群过去的行为或意见预测当前用户最可能喜欢那些东西或对那些东西感兴趣。纯粹的协同方法输入只有用户-物品评分矩阵，输出可以为：</p>

<ol>
  <li>当前用户对物品的评分</li>
  <li>TopN推荐物品列表</li>
</ol>

<h3 id="section-2">基于用户的最近邻推荐</h3>

<p>这是一种早期方法，对当前用户没有见过的物品 $p$，利用近邻对物品的评价计算预测值。潜在的假设为：</p>

<ol>
  <li>如果用户过去有相似的偏好，未来也会有相似的偏好</li>
  <li>用户偏好不会随着时间而改变</li>
</ol>

<p>确定相似用户集，通常用的方法是Pearson相关系数。给定评分矩阵R，$\bar{r}_a$ 代表用户a的平均评分，用户a和用户b的相似度 $sim(a,b)$ 表示</p>

<script type="math/tex; mode=display"> sim(a,b) = \frac{\sum_{p \in P}(r_{a,p}-\bar{r}_a)(r_{b,p}-\bar{r}_b)}{\sqrt{\sum_{p \in P}(r_{a,p}-\bar{r}_a)^2}\sqrt{\sum_{p \in P}(r_{b,p}-\bar{r}_b)^2}}</script>

<p>Pearson方法考虑到用户评分标准并不相同的事实，可以发现评分值之间存在的线性相关性。但是对于广受大众欢迎的物品相似度会更高，可以类似TF-IDF，引入反用户频率(IUF)计算。用户a对物品p的预测值如下：</p>

<script type="math/tex; mode=display">pred(a,p) = \bar{r}_a + \frac{\sum_{b \in N}sim(a,b)(r_{b,p}-\bar{r}_b)}{\sum_{b \in N}sim(a,b)}</script>

<p>预测的时候可以降低近邻规模减少计算复杂度，可以将用户相似度定义一个具体的最小阈值，或者将规模大小限制为一个固定值，只考虑K个最近邻。阈值会影响可预测物品的覆盖率，但是K值不会影响，它却会带来bias-variance tradeoff。</p>

<p>对于基于用户的推荐系统，Pearson相关系数比其他方法更胜一筹，但是对于基于物品的推荐技术，余弦相似度会比Pearson相关度量表现更好。</p>

<p>基于物品的算法主要思想是利用物品相似度，而不是用户相似度。</p>

<p>在基于物品的推荐中，通常使用改进版的余弦相似度，在原有的基础上减去评分的平均值，得到的结果类似于Pearson方法，取值在-1到+1之间，公式如下：</p>

<script type="math/tex; mode=display"> sim(a,b) = \frac{\sum_{u \in U}(r_{u,a}-\bar{r}_u)(r_{u,b}-\bar{r}_u)}{\sqrt{\sum_{u \in U}(r_{u,a}-\bar{r}_u)^2}\sqrt{\sum_{u \in U}(r_{u,b}-\bar{r}_u)^2}}</script>

<p>预测公式为加权评分综合：</p>

<script type="math/tex; mode=display">pred(u,p) = \frac{\sum_{i \in ratedItems(u)}sim(i,p) \cdot r_{u,i}}{\sum_{i \in ratedItems(u)}sim(i,p)}</script>

<p>基于物品的推荐可以离线构建一个物品相似度矩阵加速线上预测。在线上，通过确定与p最相似的物品，并计算u对这些领巾物品评分的加权综合得到u对p的预测评分。</p>

<p>原则上这种方法对基于用户的推荐也适用，但是实际情况中，两个用户评分重叠情况非常少见，这就意味着一些其他的评分值可能影响到用户间的相似度。</p>

<p>在协同过滤中，会遇到数据稀疏和冷启动问题。这种挑战就是用相对较少的有效评分得到准确的预测。直接做法就是利用用户的附加信息，比如性别、年龄等帮助分类用户信息，这就涉及到利用矩阵的外部信息，也就是混合系统。</p>

<p>另外处理这些问题的方法还包括，基于图的方法，主要思想是利用假定用户品味的传递性，并由此增强额外信息矩阵；缺省投票；利用相似用户给出相似物品的评分。</p>

<p>冷启动是稀疏问题的一个特例，问题包括：如何处理新用户；如何处理为评分或购买的新物品。这两个问题都是通过混合方法解决，可以在推荐之前要求用户给出最低限度数量的评分。</p>

<p>上述的协同推荐技术是Memory-based CF Algorithm。另外一种是Model-based。包括</p>

<ul>
  <li>矩阵因子分解</li>
  <li>关联规则挖掘</li>
  <li>基于概率分析的推荐方法（预测问题看成分类问题）</li>
</ul>

]]></content>
  </entry>
  
</feed>
