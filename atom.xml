<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2013-05-16T07:21:51-04:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[Wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zui-xiao-sheng-cheng-shu/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>算法使用的是二叉堆，时间为O(ElgV)。如果V小于E的话，使用Prim更好。</p>

<p>Kruskal算法：</p>

<p>O(ElgE): E&lt;V<sup>2&nbsp;</sup>,所以有 lgE=O(lgV)</p>


<p>集合A是一个森林，加入集合A中的安全边总是图中连接两个不同连通分支的最小权边。</p>

<p>使用不相交集合数据结构。</p>

<p>测试边时，即测试两端点是否在同一棵树上。</p>

<p>若不在则可以对集合进行合并。</p>

<!--more-->


<p>Prim算法：</p>

<p>集合A形成单棵树，添加集合A的安全边总是连接树与一个不在树中的顶点的最小权边。</p>

<p>使用最小优先队列。优先队列基于Key值，key[v]是所有将v与树中某一顶点相连的边中的最小权值。</p>

<p>一开始除了根节点，其他节点的key为无穷大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最短路径算法]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zui-duan-lu-jing-suan-fa/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zui-duan-lu-jing-suan-fa</id>
    <content type="html"><![CDATA[<p><strong>单源最短路径</strong></p>

<p>​1. Dijkstra</p>

<p> Dijkstra算法解决有向图上带权的单源最短路径问题，要求所有边的权值非负。</p>

<p>用到了顶点的最小优先队列，排序关键字为顶点的d值。即开始出了根为0，其他</p>

<p>顶点为正无穷，后来d值根据松弛算法变化。</p>

<p>总计运行时间为O((V+E)lgV)，如果所有顶点都可达的话，则为O(ElgV)。</p>

<p>​2. Bellman-ford</p>

<p>算法用来解决一般，即边的权值可以为负的单源最短路径问题。算法同时也可以检查</p>

<p>是否有从源点可达的负权回路。</p>

<p>算法的运行时间为O(VE)。</p>

<p> <!--more--></p>

<p>在Dijkstra算法以及关于有向无回路图的最短路径算法中，对每条边执行一次松弛操作。</p>

<p>在Bellman-Ford算法中，对每条边要执行多次松弛操作。</p>

<p><strong>每对顶点间的最短路径</strong></p>

<p>​1. Floyd-Wallshall</p>

<p>属于动态规划方案，允许存在权值为负的边，但不存在权值为负的回路。</p>

<p>算法考虑最短路径上的中间顶点，自底向上利用中间顶点K值递增的顺序计算权值</p>

<p>利用的递归式为</p>

<p><span style="font-family: 'comic sans ms', sans-serif;"><em>D<sub>i,j,k</sub>&nbsp;= min(D<sub>i,k,k&nbsp;&minus; 1</sub>&nbsp;+&nbsp;D<sub>k,j,k&nbsp;&minus; 1</sub>,D<sub>i,j,k&nbsp;&minus; 1</sub>)　　K &gt;= 1</em></span></p>


<p><span style="font-family: 'comic sans ms', sans-serif;"><em>　　　= W<sub>i,j</sub>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　 &nbsp;K = 0</em></span></p>


<p><span style="font-family: 'comic sans ms', sans-serif;"><em><br /></em>算法运行时间为&Phi;(n<sup>3</sup>)。</span></p>


<p>利用Floyd算法可以计算出有向图的传递闭包，即确定对所有顶点对，图中是否都存在一条</p>

<p>从 i 到 j 的路径。</p>

<p>用相应的逻辑运算或和并来替换 min 和 + 用以增加运算速度。</p>

<p>​2. 稀疏图上的Johnson算法</p>

<p>对于稀疏图改算法在渐进意义上要好于矩阵的重复平方或Floyd-Wallshall算法。</p>

<p>Johnson算法吧Dijkstra算法和Bellman-Ford算法作为其的子程序。</p>

<p>通过重新赋权值保持最短路径和产生非负的权。</p>

<p>若采用斐波那契堆来实现Dijkstra算法的最小优先队列则运算时间是</p>

<p><span>O(V<sup>2</sup>lgV + VE</span>)。更简单的二叉堆实现，则可以得到O(VElgV)的运行时间。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zip文件乱码解决]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zipwen-jian-luan-ma-jie-jue/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zipwen-jian-luan-ma-jie-jue</id>
    <content type="html"><![CDATA[<p>在windows上压缩的文件，是以系统默认编码中文来压缩文件。由于zip文件中没有声明其编码，所以linux上的unzip一般以默认编码解压，中文文件名会出现乱码。</p>

<p>虽然2005年就有人把这报告为bug,
但是info-zip的官方网站没有把自动识别编码列入计划，可能他们不认为这是个问题。Sun对java中存在N年的zip编码问题，采用了同样的处理方式。</p>

<p>1.1</p>

<p>通过unzip行命令解压，指定字符集</p>

<pre><code>unzip -O CP936 xxx.zip (用GBK, GB18030也可以)
</code></pre>

<p>有趣的是unzip的manual中并无这个选项的说明, unzip
&mdash;help对这个参数有一行简单的说明。</p>

<p>1.2</p>

<p>在环境变量中，指定unzip参数，总是以指定的字符集显示和解压文件</p>

<p>解决办法：</p>

<p>引用</p>

<pre><code>vi /etc/environment
</code></pre>

<p>再最后加入后面的代码即可</p>

<p>UNZIP=&ldquo;-O CP936&rdquo;</p>

<p>ZIPINFO=&ldquo;-O CP936&rdquo;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[硝烟中的Scrum和XP]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/xiao-yan-zhong-de-scrumhe-xp/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/xiao-yan-zhong-de-scrumhe-xp</id>
    <content type="html"><![CDATA[<p><strong>refine from</strong> <em>硝烟中的Scrum和XP&mdash;我们如何实施Scrum</em></p>

<hr />

<p>产品的backlog时Scrum的核心，也是一切的起源，从根本上说，它就是一个需求或故事特性等组成的列表，按照重要性的级别进行排序。它里面包含的是客户想要的东西，并用客户的术语加一描述。</p>

<p>backlog的另外一个名称是故事。包括以下字段：</p>

<ul>
<li>ID</li>
<li>Name：一个简短的描述</li>
<li>Importance：100以内打分，分数越高越重要</li>
<li>Initial estimate：最小单位为stroy
point，即为人天。估值无需准确，但是要保证相对的正确性。</li>
<li>How to demo：简短的测试规范，先做啥，然后做啥，最后做啥，得到什么结果。</li>
<li>Notes：相关信息，解释说明，对其他资料的引用等等，简短。</li>
</ul>


<p>额外的字段，根据需要：</p>

<ul>
<li>Track：当前故事的大致分类（后台系统，优化&hellip;）</li>
<li>Components：再多个Scrum团队协作的时候很有用，包括数据库，服务器，客户端等组件</li>
<li>Requestor：哪个客户活相关人员最先提出的需求，再后续的开发过程中向他反馈</li>
<li>Bug tracking ID</li>
</ul>


<p>产品的backlog应该停留再业务层次上，例如给Events表添加索引，潜在的目标是“提高再后台系统中搜索事件表单的相应速度”，这时需要改写，原先的目标作为一个注释存在。</p>

<!--more-->


<p>产品负责人维护backlog，理解每个故事的含义，不需要知道故事的具体实现，但是要知道为什么这个故事会在这里。其他人向负责人申请故事，负责人对它们划分先后次序。</p>

<p>sprint计划会议产生的成果：</p>

<ul>
<li>sprint目标</li>
<li>团队成员名单（以及他们的投入程度）</li>
<li>sprint backlog</li>
<li>确定好sprint演示日期</li>
<li>确定每日Scrum会议的时间和地点</li>
</ul>


<p>过程中实践TDD（测试驱动开发），包括开发和提问需求方式&hellip;</p>

<p>故事可以分成更小的故事，而小故事又可以分成任务。</p>

<p>一些重要的开发概念：</p>

<ul>
<li>结对编程</li>
<li>测试驱动开发：Juit/httpnit/JWebUnit，HSQLDB，Jetty，Cobertura，mock</li>
<li>增量设计</li>
<li>代码集体所有权</li>
<li>持续集成：Maven，QuickBuild</li>
<li>代码标准</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ubuntu亮度调节]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/ubuntuliang-du-diao-jie/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/ubuntuliang-du-diao-jie</id>
    <content type="html"><![CDATA[<ol>
<li><p>sudo gedit /etc/X11/xorg.conf 把</p></li>
</ol>


<br/>


<p>Section &ldquo;Device&rdquo;<br/>
Identifier &ldquo;Device0&rdquo; <br/>
Driver &ldquo;nvidia&rdquo; 　　　<br/>
VendorName &ldquo;NVIDIA Corporation&rdquo; EndSection <br/></p>

<p>改成</p>

<p>Section &ldquo;Device&rdquo;<br/>
Identifier &ldquo;Device0&rdquo;<br/>
Driver &ldquo;nvidia&rdquo;<br/>
VendorName &ldquo;NVIDIA Corporation&rdquo; 　<br/>
Option &ldquo;RegistryDwords&rdquo; &ldquo;<br/> EnableBrightnessControl=1&rdquo;<br/>
EndSection</p>

<p>然后保存，退出，重启之后，你 就会发现可以调节屏幕背光亮度了</p>

<ol>
<li><p>网上有很多在Ubuntu
Linux下调节笔记本屏幕亮度的方法，有的调的是亮度但不是背光亮度，有的调背光亮度的方法在我的电脑上不好使……找了半天发现这个方法，适用范围应该比较广（起码在我这里好用）。</p></li>
</ol>


<p>首先，进入终端，输入lspci命令，列出各种设备的地址</p>

<!--more-->


<p>www.linxidc.com@Ubuntu:~$ lspci</p>

<p>00:00.0 Host bridge: Intel Corporation Mobile 945GM/PM/GMS, 943/940GML
and 945GT Express Memory Controller Hub (rev 03)</p>

<p>00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS,
943/940GML Express Integrated Graphics Controller (rev 03)</p>

<p>00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/GME,
943/940GML Express Integrated Graphics Controller (rev 03)</p>

<p>00:1b.0 Audio device: Intel Corporation N10/ICH 7 Family High Definition
Audio Controller (rev 02)</p>

<p>00:1c.0 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port
1 (rev 02)</p>

<p>00:1c.1 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port
2 (rev 02)</p>

<p>&hellip;&hellip;</p>

<p>发现00:02.0是VGA设备，于是我们修改它的属性</p>

<p>sudo setpci -s 00:02.0 F4.B=FF</p>

<p>解释一下：</p>

<p>setpci是修改设备属性的命令</p>

<p>-s表示接下来输入的是设备的地址</p>

<p>00:02.0 VGA设备地址（:.）</p>

<p>F4 要修改的属性的地址，这里应该表示“亮度”</p>

<p>.B
修改的长度（B应该是字节（Byte），还有W（应该是Word，两个字节）、L（应该是Long，4个字节））</p>

<p>=FF 要修改的值（可以改）</p>

<p>我这里00是最暗，FF是最亮，不同的电脑可能不一样。</p>

<p>比如说我嫌FF太闪眼了，我就可以sudo setpci -s 00:02.0 F4.B=CC，就会暗一些</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The film-Mona Lisa Smile]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/the-film-mona-lisa-smile/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/the-film-mona-lisa-smile</id>
    <content type="html"><![CDATA[<p>看了电影《Mona Lisa
Smile》，这是一部小成本电影。整部影片从头到尾没有任何异样的高潮，没有扣人心弦的打斗或者其他对抗场面，同样也没有任何妙手回春的拍摄手法，但是这部两个小时的电影却牢牢牵住了我的心，时光在刹那间浓缩了电影中的那一年。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/5485107143.jpg" alt="The Mona Lisa Smail" height="450px"></p>

<!--more-->


<p>故事是说一个加利福利亚州的艺术教师来到马萨诸塞州的一所女子高中执教一年的故事。独立，自信和聪慧的Katherine
Ann
Watson带着50年代未有的自由女权心理来到这所古老封闭，因循守旧的卫斯理女子学院。观念的冲突和陌生的环境并未让Watson退却，故事在Amanda
Armstrong因在学生中发避孕套而被辞退后引发了高潮。保守的妇德坚贞，封建思想牢牢在学生和父母教师中占据着统治地位，Watson勇于在与学生，校长董事争论中力图宣传自由改革思想。最终Watson无力与社会学校做斗争，不愿屈服选择离开，但是最后她影响了班上的女学生，改变了她们的思想观念，影响了她们的一生，从我们现在的角度来看无疑是让她们脱离了痛苦选择了一条更为宽敞的道路。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/211392045.jpg" alt="The Mona Lisa Smail" height="450px"></p>

<p>影片的剧情一开始显得比较缓慢，但是到了最后有逐渐加快的趋势，因此似乎显得最后思想的转变过程不够具体和充分。总体上来说还是值得肯定的，影片中刻画人物的形象无疑是成功的，让人印象十分的深刻。整部影片的剧情细分来说很有意思，有点佩服导演，里头的冲突矛盾不断，有主角感情线，学生感情线，学生间冲突线，董事与女主的战争与和平，以及学生与女主学术与社会观念的冲突和理解，这些内容非常的有嚼头，但是总感觉影片中还没有深度的挖掘这些材料，有些是浅尝则止，有些是深入不够显得虎头蛇尾。从人物表演的角度来说，这可能是我见过表演的十分细腻的一部影片，细节部分处理的非常之好，表情变化十分的丰富，特别是女主角Watson，她对人物的感情和肢体表情行为表演的实在是到位，让人叹为观止，这也是上述人物刻画成功的一部分原因。</p>

<p>总结来说一部好的电影有以下几点是必不可少的：吸引人，个性鲜明，有行动力的男女主角，当然对我来说女主角是最重要的，呵呵~~；斗争和和平演绎进行的剧情，最好象巴赫的赋格一般纠结绵延；细腻的画面，格调鲜明风格一致的场景，突出主旨衬托感情的背景音乐。这些条件Mona
Lisa Smile基本都符合，所以我一看就感觉对它有爱。</p>

<p>最近爱上小成本电影~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[十个你可能没用过的Linux命令]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/shi-ge-ni-ke-neng-mei-yong-guo-de-linuxming-ling/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/shi-ge-ni-ke-neng-mei-yong-guo-de-linuxming-ling</id>
    <content type="html"><![CDATA[<p><em><strong>excerpted</strong> from <a href="http://www.ituring.com.cn/article/1782">图灵社区</a></em></p>

<hr />

<p>如果你是一个硬件系统管理员或者Linux工程师，你可能会记得大多数Linux命令行技巧。下面的这些Linux命令行技巧通常不被Linux用户所使用。</p>

<p><strong>1.使用<em>pgrep</em>快速查找一个PID</strong></p>

<p><strong><em>pgrep</em></strong>遍历目前正在运行的进程然后列出符合查找规则的进程ID（PID）。</p>

<pre><code>pgrep ssh</code></pre>


<p>这条命令会列出所有与ssh有关的进程。</p>

<p><strong>2.执行上次执行过的命令</strong></p>

<p>这个标题有些绕口，但是它是名副其实的。</p>

<pre><code>!!</code></pre>


<!--more-->


<p>这会执行你上一次在命令行中执行过的命令。</p>

<p><strong>3.执行最近一次以XX开头的命令</strong></p>

<p>如果你想要从命令行历史中执行一个s开头的命令时，你可以使用如下命令：</p>

<pre><code>!s</code></pre>


<p>它会执行最近一次在命令行中执行且以字母s开头的命令。</p>

<p><strong>4.反复执行一个命令并在屏幕上输出</strong></p>

<p><strong><em>watch</em></strong>会反复运行一个命令，并在屏幕上打印输出。它可以让你实时的观察程序的输出变化。默认情况下，程序每2秒运行一次。<strong><em>watch</em></strong>命令与<strong><em>tail</em></strong>命令很相似。</p>

<pre><code>watch -d ls -l</code></pre>


<p>这条命令会监视当前目录的所有文件，并且高亮文件所发生的改变。</p>

<p><strong>5.在VI/VIM中快速保存</strong></p>

<p>如果你很匆忙，你可以通过<strong><em>【SHIFT + zz】</em></strong> 快速从vi的插入模式中退出。</p>

<p><strong>6.快速登出终端</strong> 你可以快速使用<strong><em>【CTRL+D】</em></strong>快速登出终端。</p>

<p><strong>7.返回你上一个所在目录</strong></p>

<p>你可以使用如下命令返回你上一次所在的目录：</p>

<pre><code>cd -</code></pre>


<p><strong>8.聪明地创建父目录</strong></p>

<p>如下命令可以帮助你创建所有你需要的目录，即便是他们还不存在。为什么要浪费时间做一些愚蠢的事情比如：<strong><em>mkdir
make ; cd make ; mkdir all ; cd all ; mkdir of ; cd of
…</em></strong> 你说到点子上了，使用<strong><em>mkdir -p</em></strong>！</p>

<pre><code>mkdir -p /home/adam/make/all/of/these/directories/</code></pre>


<p><strong>9.删除一整行</strong></p>

<p>如果你已经输入一长串的命令，但是你又不在需要他们了，那么你可以使用如下命令直接删除一整行：</p>

<pre><code>CTRL+U</code></pre>


<p><strong>10.设置文件的时间戳</strong></p>

<p>下面这条命令会把文件的时间戳设置成2008-01-01
8:00。日期格式是(YYMMDDhhmm)</p>

<pre><code>touch -c -t 0801010800 filename.c</code></pre>


<p>你还能想到哪些为大多数人所指的Linux命令？</p>

<p><strong>【摘自回复】</strong></p>

<p><strong>访问上一个命令的最后一个参数</strong> 如果你之前执行了这样一条命令 cp
assignment.htm /home/phill/reports/2008/
然后你可以冲 <strong>_\$</strong> 访问刚才那条命令最后一个参数&#8221;<em>/home/phill/reports/2008/</em>&ldquo;，例如：</p>

<pre><code>cd $_</code></pre>


<p><strong>清除光标右边的内容</strong> 上文有一个小错误，<strong><em>【Ctrl +
U】</em></strong>并不是删除一整行，而是删除光标左边的内容，如果光标停留在行首，那么<strong><em>【Ctrl
+ U】</em></strong>将无任何作用，这个时候，需要删除光标右边内容：</p>

<pre><code>ctrl-k</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[少年派]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/shao-nian-pai/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/shao-nian-pai</id>
    <content type="html"><![CDATA[<h3>徐子东：他人就是老虎</h3>

<p>老虎三个阶段：</p>

<ol>
<li>力量比你大，你得自卫;反过来，你的力量比较强大，你就是老虎</li>
<li>自卫后，利用特别的情况，给他好处，给他恩惠，指挥他，利用它</li>
<li>产生幻觉，你们是同舟共济，共同面对困难</li>
</ol>


<p>点睛：</p>

<ul>
<li>瘦骨凛丁的老虎头也不回的进入森林</li>
<li>pi父亲一开始所说的：你在动物眼里看到的所有的同情，友爱，善良都是你的倒影</li>
</ul>


<p> <!--more--></p>

<h3>梁文道：神，人，动物三角平衡</h3>

<p>人与动物在船上相处，是两点，无法达到平衡状态，所以需要寻找第三点，超自然的第三点——上帝。
但是那个状态不是每个人都能感觉的到，追求的到，所以透过人和动物的相处，我们去求那未知第三点。</p>

<p>对于某种精神倾向的探讨。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python特殊语法：filter、map、reduce、lambda [转]]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/pythonte-shu-yu-fa-filter-map-reduce-lambda-zhuan/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/pythonte-shu-yu-fa-filter-map-reduce-lambda-zhuan</id>
    <content type="html"><![CDATA[<p><i><strong>from</strong> <a href="http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html">http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html</a></i></p>

<hr />

<p>Python内置了一些非常有趣但非常有用的函数，充分体现了Python的语言魅力！</p>

<p><strong>filter(function,
sequence)</strong>：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回：</p>

<p>>>> def f(x): return x % 2 != 0 and x % 3 != 0</p>

<p>>>> filter(f, range(2, 25))
[5, 7, 11, 13, 17, 19, 23]</p>

<p>>>> def f(x): return x != &lsquo;a&rsquo;</p>

<p>>>> filter(f, &ldquo;abcdef&rdquo;)</p>

<p>&lsquo;bcdef&rsquo;</p>

<p><strong>map(function,
sequence)</strong> ：对sequence中的item依次执行function(item)，见执行结果组成一个List返回：</p>

<p>>>> def cube(x): return x<em>x</em>x</p>

<p>>>> map(cube, range(1, 11))</p>

<p>[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</p>

<p>>>> def cube(x) : return x + x</p>

<p>&hellip;</p>

<p>>>> map(cube , &ldquo;abcde&rdquo;)</p>

<p>[&lsquo;aa&rsquo;, &lsquo;bb&rsquo;, &lsquo;cc&rsquo;, &lsquo;dd&rsquo;, &lsquo;ee&rsquo;]</p>

<p>另外map也支持多个sequence，这就要求function也支持相应数量的参数输入：
>>> def add(x, y): return x+y</p>

<p>>>> map(add, range(8), range(8))</p>

<p>[0, 2, 4, 6, 8, 10, 12, 14]</p>

<!--more-->


<p><strong>reduce(function, sequence,
starting_value)</strong>：对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：</p>

<p>>>> def add(x,y): return x + y</p>

<p>>>> reduce(add, range(1, 11))</p>

<p>55 （注：1+2+3+4+5+6+7+8+9+10）</p>

<p>>>> reduce(add, range(1, 11), 20)</p>

<p>75 （注：1+2+3+4+5+6+7+8+9+10+20）</p>

<p><strong>lambda</strong>：这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数，是从LISP借用来的，可以用在任何需要函数的地方：</p>

<p>>>> g = lambda x: x * 2</p>

<p>>>> g(3)</p>

<p>6</p>

<p>>>> (lambda x: x * 2)(3)</p>

<p>6</p>

<p>我们也可以<strong>把filter map reduce
和lambda结合起来</strong>用，函数就可以简单的写成一行。</p>

<p>例如</p>

<p>kmpathes = filter(lambda kmpath: kmpath,                <br/>
map(lambda kmpath: string.strip(kmpath),
string.split(l, &lsquo;:&rsquo;)))</p>

<p>看起来麻烦，其实就像用语言来描述问题一样，非常优雅。
对 l
中的所有元素以&#8217;:&lsquo;做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被&rsquo;:&lsquo;分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。</p>

<p>[转] <a href="http://hi.baidu.com/black/item/307001d18715fc322a35c747">http://hi.baidu.com/black/item/307001d18715fc322a35c747</a></p>

<hr />

<p><strong>lambda表达式</strong>返回一个函数对象</p>

<p>例子：</p>

<pre><code>func = lambda x,y:x+y
</code></pre>


<p>func相当于下面这个函数</p>

<pre><code>def func(x,y):
    return x+y
</code></pre>


<p>注意def是语句而lambda是表达式</p>

<p>下面这种情况下就只能用lambda而不能用def</p>

<pre><code>[(lambda x:x*x)(x) for x in range(1,11)]
</code></pre>


<p>map，reduce，filter中的function都可以用lambda表达式来生成！</p>

<p><strong>map(function,sequence)</strong></p>

<p>把sequence中的值当参数逐个传给function，返回一个包含函数执行结果的list。</p>

<p>如果function有两个参数，即
map(function,sequence1,sequence2)。</p>

<p>例子：</p>

<p>求1<em>1,2</em>2,3<em>3,4</em>4</p>

<pre><code>map(lambda x:x*x,range(1,5))
</code></pre>


<p>返回值是[1,4,9,16]</p>

<p><strong>reduce(function,sequence)</strong></p>

<p>function接收的参数个数只能为2</p>

<p>先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给</p>

<p>function，然后只返回一个结果。</p>

<p>例子：</p>

<p>求1到10的累加</p>

<pre><code>reduce(lambda x,y:x+y,range(1,11))
</code></pre>


<p>返回值是55。</p>

<p><strong>filter(function,sequence)</strong></p>

<p>function的返回值只能是True或False</p>

<p>把sequence中的值逐个当参数传给function，如果function(x)的返回值是True，就把x加到filter的返回值里面。一般来说filter的返回值是list，特殊情况如sequence是string或tuple，则返回值按照sequence的类型。</p>

<p>例子：</p>

<p>找出1到10之间的奇数</p>

<pre><code>filter(lambda x:x%2!=0,range(1,11))
</code></pre>


<p>返回值</p>

<p>[1,3,5,7,9]</p>

<p>如果sequence是一个string</p>

<pre><code>filter(lambda x:len(x)!=0,'hello')
</code></pre>


<p>返回&#8217;hello&#8217;</p>

<pre><code>filter(lambda x:len(x)==0,'hello')
</code></pre>


<p>返回&#8221;</p>

<p>[转] <a href="http://blog.csdn.net/myzhan/article/details/7269471">http://blog.csdn.net/myzhan/article/details/7269471</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pandoc example]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/pandoc-example/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/pandoc-example</id>
    <content type="html"><![CDATA[<p>from <a href="http://johnmacfarlane.net/pandoc/demos.html">pondoc </a></p>

<hr />

<p>To see the output created by each of the commands below, click on the
name of the output file:</p>

<ol>
<li><p>HTML fragment:</p>

<pre><code>pandoc README -o example1.html
</code></pre></li>
<li><p>Standalone HTML file:</p>

<pre><code>pandoc -s README -o example2.html
</code></pre></li>
<li><p>HTML with smart quotes, table of contents, CSS, and custom footer:</p>

<pre><code>pandoc -s -S --toc -c pandoc.css -A footer.html README -o example3.html
</code></pre></li>
<li><p>LaTeX:</p>

<pre><code>pandoc -s README -o example4.tex
</code></pre></li>
<li><p>From LaTeX to markdown:</p>

<pre><code>pandoc -s example4.tex -o example5.text
</code></pre></li>
<li><p>reStructuredText:<!--more--></p>

<pre><code>pandoc -s -w rst --toc README -o example6.text
</code></pre></li>
<li><p>Rich text format (RTF):</p>

<pre><code>pandoc -s README -o example7.rtf
</code></pre></li>
<li><p>Beamer slide show:</p>

<pre><code>pandoc -t beamer SLIDES -o example8.pdf
</code></pre></li>
<li><p>DocBook XML:</p>

<pre><code>pandoc -s -S -w docbook README -o example9.db
</code></pre>

<p>Chunked XHTML via DocBook
and <a href="http://cyberelk.net/tim/xmlto/">xmlto</a>:</p>

<pre><code>xmlto xhtml -m config.xsl example9.db -o example9/
</code></pre></li>
<li><p>Man page:</p>

<pre><code>pandoc -s -w man pandoc.1.md -o example10.1
</code></pre></li>
<li><p>ConTeXt:</p>

<pre><code>pandoc -s -w context README -o example11.tex
</code></pre>

<p>PDF via pandoc and ConTeXt’s <code>texexec</code>:</p>

<pre><code>texexec --pdf example11.tex # produces example11.pdf
</code></pre></li>
<li><p>Converting a web page to markdown:</p>

<pre><code>pandoc -s -r html http://www.gnu.org/software/make/ -o example12.text
</code></pre></li>
<li><p>From markdown to PDF:</p>

<pre><code>pandoc README -o example13.pdf
</code></pre></li>
<li><p>PDF with numbered sections and a custom LaTeX header:</p>

<pre><code>pandoc -N --template=mytemplate.tex --variable mainfont=Georgia --variable sansfont=Arial --variable monofont="Bitstream Vera Sans Mono" --variable fontsize=12pt --variable version=1.9 README --latex-engine=xelatex --toc -o example14.pdf
</code></pre></li>
<li><p>A wiki program using <a href="http://happstack.com/">Happstack</a> and
pandoc: <a href="http://gitit.net/">gitit</a></p></li>
<li><p>HTML slide shows:</p>

<pre><code>pandoc -s --mathml -i -t dzslides SLIDES -o example16a.html

pandoc -s --webtex -i -t slidy SLIDES -o example16b.html

pandoc -s --self-contained --webtex -i -t s5 SLIDES -o example16c.html

pandoc -s --mathjax -i -t slideous SLIDES -o example16d.html
</code></pre></li>
<li><p>TeX math in HTML:</p>

<pre><code>pandoc math.text -s -o mathDefault.html

pandoc math.text -s --mathml -o mathMathML.html

pandoc math.text -s --webtex -o mathWebTeX.html

pandoc math.text -s --mathjax -o mathMathJax.html

pandoc math.text -s --latexmathml -o mathLaTeXMathML.html
</code></pre></li>
<li><p>Syntax highlighting of delimited code blocks:</p>

<pre><code>pandoc code.text -s --highlight-style pygments -o example18a.html

pandoc code.text -s --highlight-style kate -o example18b.html

pandoc code.text -s --highlight-style monochrome -o example18c.html

pandoc code.text -s --highlight-style espresso -o example18d.html

pandoc code.text -s --highlight-style haddock -o example18e.html

pandoc code.text -s --highlight-style tango -o example18f.html

pandoc code.text -s --highlight-style zenburn -o example18g.html
</code></pre></li>
<li><p>GNU Texinfo, converted to info, HTML, and PDF formats:</p>

<pre><code>pandoc README -s -o example19.texi

makeinfo example19.texi -o example19.info

makeinfo example19.texi --html -o example19

texi2pdf example19.texi # produces example19.pdf
</code></pre></li>
<li><p>OpenDocument XML:</p>

<pre><code>pandoc README -s -w opendocument -o example20.xml
</code></pre></li>
<li><p>ODT (OpenDocument Text, readable by OpenOffice):</p>

<pre><code>pandoc README -o example21.odt
</code></pre></li>
<li><p>MediaWiki markup:</p>

<pre><code>pandoc -s -S -w mediawiki --toc README -o example22.wiki
</code></pre></li>
<li><p>EPUB ebook:</p>

<pre><code>pandoc -S README -o README.epub
</code></pre></li>
<li><p>Markdown citations:</p>

<pre><code>pandoc -s -S --biblio biblio.bib --csl chicago-author-date.csl CITATIONS -o example24a.html

pandoc -s -S --biblio biblio.bib --csl mhra.csl CITATIONS -o example24b.html

pandoc -s -S --biblio biblio.bib --csl ieee.csl CITATIONS -t man -o example24c.1
</code></pre></li>
<li><p>Textile writer:</p>

<pre><code>pandoc -s -S README -t textile -o example25.textile
</code></pre></li>
<li><p>Textile reader:</p>

<pre><code>pandoc -s -S example25.textile -f textile -t html -o example26.html
</code></pre></li>
<li><p>Org-mode:</p>

<pre><code>pandoc -s -S README -o example27.org
</code></pre></li>
<li><p>AsciiDoc:</p>

<pre><code>pandoc -s -S README -t asciidoc -o example28.txt
</code></pre></li>
<li><p>Word docx:</p>

<pre><code>pandoc -s -S README -o example29.docx
</code></pre></li>
<li><p>LaTeX math to docx:</p>

<pre><code>pandoc -s math.tex -o example30.docx
</code></pre></li>
<li><p>DocBook to markdown:</p>

<pre><code>pandoc -f docbook -t markdown -s howto.xml -o example31.text
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[P2P流媒体视频点播系统的个人技术报告]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/p2pliu-mei-ti-shi-pin-dian-bo-xi-tong-de-ge-ren-ji-zhu-bao-gao/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/p2pliu-mei-ti-shi-pin-dian-bo-xi-tong-de-ge-ren-ji-zhu-bao-gao</id>
    <content type="html"><![CDATA[<h3>项目说明</h3>

<p>来源为高等计算机网络的大作业设计。我们组选择的是p2p的流媒体视频点播系统。核心内容的是chord算法。</p>

<h3>系统分析</h3>

<p>局域网内的任何结点既可以发送媒体压缩信息给其他结点，也可以从其他结点接收视频信息。此外流媒体信息是在网内从多源结点获取，而非单源模式。改变传统的需要中央服务器的查询支持，虽然本系统也需要一个中央服务器进行存储数据源以及节点加入的初始化，但是一旦节点加入了p2p网络，那么中央服务器的功能便会弱化很多，客户端peer可以利用其他peer节点已有的信息进行资源查询，而不用经过中央服务器。
在理论上，chord是一个纯p2p算法，但是在试验中我们发现，在广域网中实现一个完全对等的p2p网络是不大现实的一件事情，因为根据chord算法，节点的加入需要知道一个已知的节点信息，而这个节点信息无法像在局域网中可以通过广播的方式进行查询，也就是说这个已知的节点就是存在的中央服务器，所有的节点加入都需要知道中央服务器在网络中的位置，通过中央服务器加入到chord网络中。而在局域网中，必存在一个初始信息源，对于一个如上所描述的系统来说，这个初始信息源可以当成一个中央服务器，当然这个中央服务器的功能也被弱化很多。</p>

<h4>项目设计与管理</h4>

<p>采用JAVA语言作为实现工具，并利用其UDT传输包实现数据传输、JMF视频播放工具包和openchord开源工具包，在局域网内实现基于P2P的流媒体视频点播系统。系统设计主要涉及的工作量包括：服务器端资源管理、P2P资源查询传输机制、客户端缓冲区管理和视频播放软件。预计的工作时间为1个月，总工作量为4人月。开发采用敏捷开发模型，进行迭代式开发，开发讨论为3天一次的站立会议，有效保障小组成员的信息一致性。会议中根据迭代需求列出一周或者近期的任务，小组成员互相监督管理，提高效率。能够有效的保障在规定的时间内完成项目。</p>

<!--more-->


<h3>功能需求</h3>

<ul>
<li><p>客户端软件：运行客户端软件即获取所有频道列表信息，获取需要播放的文件信息，查询本地缓冲区，若已在本地有播放过，则直接进行本地播放；没有缓存的文件则将从可用的对等节点获取。</p></li>
<li><p>缓冲区管理：P2P资源查询和分发资源服务器管理资源，使用chord协议获取得到资源存储节点，选择资源存储节点，使用多线程调度下载，提供分片信息给客户端软件。将视频分片组成队列，记录分片大小，若总的缓冲区大于500MB则根据队列顺序删除先到的分片。
服务器端：初始化资源，构建chord网络。其他peer节点加入服务器端的chord网络。</p></li>
</ul>


<h3>实现效率</h3>

<p>提高效率的方法包括：</p>

<ol>
<li>使用多线程进行下载分片资源；</li>
<li>缓冲区大小管理，避免下载重复资源；</li>
<li>使用UDT传输，加快传输效率，简化系统复杂度。</li>
<li>同一资源节点的选择算法</li>
</ol>


<p><img src="http://images.cnitblog.com/blog/434023/201301/02172642-90a8182460f045fdb3c3b44f0f9e408b.png" title="类图" alt="类图" /></p>

<h3>个人工作总结</h3>

<h4>项目管理</h4>

<p>我并不是第一次在项目中担任组长，但是这次的项目开发与以往有很大的不同。</p>

<ol>
<li>组员之间互相都不熟悉，对对方了解什么技术，善于哪一个模块的开发都不了解。</li>
<li>工作时间不固定，而且特别的缺少，每个组员都有老师分配的任务和其他的课堂作业。</li>
<li>工作环境不理想，组员的实验室之间相隔较远，沟通不够方便</li>
<li>组员普遍对新技术不太了解，只是掌握基础知识，开发上存在困难。</li>
<li><p>没有明确的需求和系统边界。</p>

<p>以上种种的一切都给开发造成困难，特别是第一条。因为对大家的开发水平和偏好都不了解，所以在分配任务的时候就相当与黑盒测试一般。
无法根据已知的情况安排任务。其他方面也给相互之间的沟通制造了困难。而沟通对于团队来说，我认为是比其他方面更加重要的。</p>

<p>  争对上述几条我对项目进行如下管理：</p></li>
<li><p>项目整体上为迭代开发，采用增量模型</p></li>
<li>建立qq群及时共享消息和资源</li>
<li>每周一次的例会，后来因为项目进展缓慢，改为3天一次</li>
<li>开会的时候借鉴敏捷站立会议的要点，给出任务需求，让组员选择</li>
<li>开发采用模块化的方法，预留API接口给使用者，明确代码责任制</li>
<li><p>采用git作为版本控制，所有代码再github上托管，组员可以pull和push最新更新</p>

<p>但项目管理过程中还是有很多方面没有考虑到：</p></li>
<li><p>发现开会的时候气氛不够浓烈，组员大多数时候没有提前做一些准备，导致开会时间过长</p></li>
<li>自己的思想表达不够清楚，没有确定组员明白自己的想法</li>
<li>在做架构的时候，没有做好调研工作，所选的方法并不一定时最佳的</li>
<li>组员能力不了解的情况下，将组员能力的底线设置较高</li>
<li>重点功能和说明没有采用图片或者文件保留</li>
<li>开发过程中，没有很好的进行时间估计，导致很多应有的需求未能实现</li>
</ol>


<h4>开发总结</h4>

<p>我所负责的内容是缓冲区管理和系统架构的设计。开发过程中遇到的问题如下：</p>

<ol>
<li>开发过于仓促，代码比较粗糙</li>
<li>在服务器端实现多个客户端接入进行多线程udp传输文件的时候遇到困难，未能很好的实现多线程</li>
<li>在带宽检测的那一块没有实现，还是因为没有合理规划时间，导致后期工作量大。</li>
<li>开发的时候没有进行很好的时间估计</li>
</ol>


<p>收获还是有一些的：</p>

<ol>
<li>对DHT的chord lookup sevice进一步了解</li>
<li>实现p2p流媒体的功能，了解其中的机制</li>
<li>巩固和复习了Java的语法和用法，较多的使用线程，提高效率</li>
<li>总体设计和分析上有了进一步的提高</li>
</ol>


<h3>参考文献</h3>

<p>[1] P2P流媒体系统节点管理与数据分发机制. 王延伟. 山东大学硕士学位论文.
2010.\
 [2] Chord: A Scalable Peer-to-peer Lookup Service for Internet
Applications. Ion Stoica. etc. MIT Laboratory for Computer Science.
2001.\
 [3] Reducing Maintenance Overhead in Chord via Heterogeneity. Yuh-Jzer
Joung. Jiaw-Chang Wang. Taipei. 2005</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下双网卡配置]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/linuxxia-shuang-wang-qia-pei-zhi/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/linuxxia-shuang-wang-qia-pei-zhi</id>
    <content type="html"><![CDATA[<p><strong>需求</strong>： 一台PC1拥有双网卡，另外一台PC2需要通过这台pc上网。</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/billowkiller/447098/r_ac345982b2b7d0a207325429cbef76094a369a8e.jpg" alt="网络拓扑图"/></p>

<p><strong>配置过程</strong>：</p>

<p>首先需要配置pc1的两个网卡信息以及pc2的网卡信息。这个比较简单，接下里需要配置pc1中的静态路由。</p>

<p>文件ipt.save表示静态路由表的修改文件。</p>

<pre><code># Generated by iptables-save v1.4.2 on Wed Nov 16 15:04:23 2011
 *filter
 :INPUT ACCEPT [203:29797]
 :FORWARD ACCEPT [0:0]
 :OUTPUT ACCEPT [83:10885]
 COMMIT
 # Completed on Wed Nov 16 15:04:23 2011
 # Generated by iptables-save v1.4.2 on Wed Nov 16 15:04:23 2011
 *nat
 :PREROUTING ACCEPT [82:12935]
 :POSTROUTING ACCEPT [25:1724]
 :OUTPUT ACCEPT [25:1724]
 -A POSTROUTING -s 10.0.0.0/8 ! -d 10.0.0.0/8 -j MASQUERADE 
 COMMIT
 # s-&gt;source !d-&gt;not distination-&gt;not in the same subset
 # Completed on Wed Nov 16 15:04:23 2011
</code></pre>

<p>进入root权限后，执行命令</p>

<pre><code>iptables-restore /home/angel/net_scripts/ipt.save
</code></pre>

<p>这样就是修改了静态路由表，但还需要将转发开关打开，需要命令如下</p>

<pre><code>echo '1' &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>

<p>这样修改之后pc2就可以通过pc1上网了。</p>

<!--more-->


<p>但是重启后发现<strong>两个问题</strong>：</p>

<ul>
<li>linux下如果有两个网卡eth0和eth1，系统启动时候会先启动eth0，后启动eth1，这样造成eth0的信息被eth1覆盖。</li>
<li>以上的两个命令并不是永久的，重启后失效。</li>
</ul>


<p>第一个问题的解决方案是修改/etc/network/interfaces
文件，修改网卡接口的信息，修改后的文件如下：</p>

<pre><code># interfaces(5) file used by ifup(8) and ifdown(8)
 auto lo
 iface lo inet loopback

 auto eth1
 iface eth1 inet dhcp

 auto eth0
 iface eth0 inet static
 address 10.0.0.1
 netmask 255.0.0.0
 broadcast 10.255.255.255
</code></pre>

<p>需要重启生效，也可以使用命令</p>

<pre><code>sudo /etc/init.d/networking restart
</code></pre>

<p>第二个问题可以写一个简单的脚本iptable.sh来实现，每次开机启动自动执行脚本：</p>

<pre><code>iptables-restore /home/angel/net_scripts/ipt.save
 echo '1' &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>

<p>将脚本放在任意的位置，如下放入home文件夹下，修改/etc/rc.local文件：</p>

<pre><code>#!/bin/sh -e
 #
 # rc.local
 #
 # This script is executed at the end of each multiuser runlevel.
 # Make sure that the script will "exit 0" on success or any other
 # value on error.
 #
 # In order to enable or disable this script just change the execution
 # bits.
 #
 # By default this script does nothing.
 sh /home/bk/iptable.sh
 exit 0
</code></pre>

<p>这样每次启动都会调用脚本，并且使用root权限。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下解决中文乱码——文件，标签]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/linuxxia-jie-jue-zhong-wen-luan-ma-wen-jian-biao-qian/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/linuxxia-jie-jue-zhong-wen-luan-ma-wen-jian-biao-qian</id>
    <content type="html"><![CDATA[<p>文件是在WIndows 下创建的,Windows
的文件名中文编码默认为GBK,而Linux中默认文件名编码为UTF8,由于编码不一致所以导致了文件名乱码的问题，解决这个问题需要对文件名进行转码。</p>

<ul>
<li><strong>文件与文件夹乱码，使用convmv来解决</strong></li>
</ul>


<p>convmv 使用方法：</p>

<p>convmv -f 源编码 -t 新编码 [选项] 文件名</p>

<p>常用参数：</p>

<ul>
<li>-r 递归处理子文件夹</li>
<li>–notest 真正进行操作，默认情况下是不对文件进行真实操作</li>
<li>–list 显示所有支持的编码</li>
<li>–unescap 可以做一下转义，比如把%20变成空格</li>
</ul>


<p>举例：</p>

<p>在当前目录下</p>

<pre><code>convmv -f GBK -t UTF-8 --notest * //所有文件转gbk为utf8
</code></pre>

<ul>
<li><strong>转换 mp3 标签编码，使用mutagen</strong></li>
</ul>


<p>安装：</p>

<pre><code>sudo apt-get install python-mutagen
</code></pre>

<p>举例：<!--more--></p>

<pre><code>mid3iconv -e gbk *.mp3 //当前目录下的mp3文件

find . -iname “*.mp3” -execdir mid3iconv -e GBK {}; //所有文件包括子文件夹
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下DHCP服务器配置]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/linuxxia-dhcpfu-wu-qi-pei-zhi/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/linuxxia-dhcpfu-wu-qi-pei-zhi</id>
    <content type="html"><![CDATA[<p>环境为Ubuntu 12.10，机器为3网卡，需要再eth2上配置一个dhcp服务。</p>

<p>因为eth2后接一个交换机，交换机上的机器需要自动分配网址，并且对于某一台或多台机器需要固定网址，例如打印机。</p>

<h3>1.   安装DHCP服务</h3>

<pre><code>sudo apt-get install dhcp3-server
</code></pre>

<p>但是安装的是
isp-dhcp-server。可能是ubuntu进行的版本替换。但是不影响后面的操作。</p>

<p>服务器上用友3块网卡，需要选择哪一块网卡用来监听DHCP服务。</p>

<p>输入下面命令修改配置文件</p>

<pre><code>vim /etc/default/isc-dhcp-server
</code></pre>

<p>在文件的注释部分可以看到dhcpd的配置文件在</p>

<pre><code>/etc/dhcp/dhcpd.conf
</code></pre>

<p>其他注释部分为格外选项，下面要修改INTERFACES</p>

<pre><code>INTERFACES=“eth2”
</code></pre>

<!--more-->


<h3>2.  配置DHCP服务</h3>

<p>修改在上一步查到的dhcpd文件</p>

<p>修改的部分如下：</p>

<pre><code>default-lease-time 600;
 max-lease-time 7200;
 option subnet-mask 255.255.255.0;
 option broadcast-address 192.168.1.255;
 option routers 192.168.1.254;
 option domain-name-servers 192.168.1.1, 192.168.1.2;
 subnet 192.168.1.0 netmask 255.255.255.0 {
 　　range 192.168.1.10 192.168.1.200;
 }
</code></pre>

<p>注意：不要忘了每句后面加上分号，当时我就粗心了，花了好久时间查出。</p>

<p>这样修改自动分配的地址范围就在</p>

<pre><code>192.168.1.10 与 192.168.1.200
</code></pre>

<p>还需要绑定MAC地址与ip地址，在添加代码</p>

<pre><code>host printer1 {
 　　hardware ethernet 00:0a:95:f5:8f:b3;
 　　fixed-address 192.168.1.23;
 }
</code></pre>

<p>重启电脑，就ok了。</p>

<p>需要找到DHCP服务器的IP地址，使用下面的命令</p>

<pre><code>sudo dhclient
</code></pre>

<p>或者</p>

<pre><code>tail -n 15 /var/lib/dhcp3/dhclient.*.leases
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码风格]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/linuxnei-he-dai-ma-feng-ge/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/linuxnei-he-dai-ma-feng-ge</id>
    <content type="html"><![CDATA[<p>Chinese translated version of Documentation/CodingStyle</p>

<p>If you have any comment or update to the content, please post to LKML
directly.</p>

<p>However, if you have problem communicating in English you can also ask
the</p>

<p>Chinese maintainer for help. Contact the Chinese maintainer, if this</p>

<p>translation is outdated or there is problem with translation.</p>

<p>Chinese maintainer: Zhang Le &lt;r0bertz@gentoo.org></p>

<hr />

<p>Documentation/CodingStyle的中文翻译</p>

<p>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话，也可</p>

<p>以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版维护者。</p>

<p>中文版维护者： 张乐 Zhang Le <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x72;&#x30;&#x62;&#101;&#114;&#x74;&#x7a;&#64;&#x67;&#x65;&#110;&#x74;&#111;&#111;&#46;&#x6f;&#x72;&#x67;">&#114;&#x30;&#x62;&#x65;&#114;&#x74;&#x7a;&#64;&#103;&#x65;&#x6e;&#x74;&#x6f;&#x6f;&#46;&#x6f;&#x72;&#103;</a></p>

<p>中文版翻译者： 张乐 Zhang Le <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x72;&#x30;&#98;&#101;&#114;&#x74;&#122;&#x40;&#x67;&#101;&#110;&#116;&#x6f;&#111;&#46;&#111;&#x72;&#x67;">&#x72;&#48;&#98;&#101;&#x72;&#116;&#122;&#x40;&#x67;&#x65;&#x6e;&#116;&#x6f;&#111;&#x2e;&#111;&#x72;&#103;</a></p>

<p>中文版校译者： 王聪 Wang Cong <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#120;&#x69;&#x79;&#111;&#x75;&#46;&#119;&#x61;&#110;&#103;&#x63;&#x6f;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#x78;&#105;&#121;&#111;&#117;&#x2e;&#119;&#97;&#x6e;&#x67;&#x63;&#111;&#110;&#x67;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a></p>

<pre><code>        wheelz &lt;kernel.zeng@gmail.com&gt;

        管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;

        Li Zefan &lt;lizf@cn.fujitsu.com&gt;

        Wang Chen &lt;wangchen@cn.fujitsu.com&gt;
</code></pre>

<p>以下为正文</p>

<hr />

<p>Linux内核代码风格</p>

<p>这是一个简短的文档，描述了linux内核的首选代码风格。代码风格是因人而异的，而且我</p>

<p>不愿意把我的观点强加给任何人，不过这里所讲述的是我必须要维护的代码所遵守的风格，</p>

<p>并且我也希望绝大多数其他代码也能遵守这个风格。请在写代码时至少考虑一下本文所述的</p>

<p>风格。</p>

<!--more-->


<p>首先，我建议你打印一份GNU代码规范，然后不要读它。烧了它，这是一个具有重大象征性</p>

<p>意义的动作。</p>

<p>不管怎样，现在我们开始：</p>

<h2> 第一章：缩进</h2>

<p>制表符是8个字符，所以缩进也是8个字符。有些异端运动试图将缩进变为4（乃至2）个字符</p>

<p>深，这几乎相当于尝试将圆周率的值定义为3。</p>

<p>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的屏幕</p>

<p>连续看了20小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</p>

<p>现在，有些人会抱怨8个字符的缩进会使代码向右边移动的太远，在80个字符的终端屏幕上</p>

<p>就很难读这样的代码。这个问题的答案是，如果你需要3级以上的缩进，不管用何种方式你</p>

<p>的代码已经有问题了，应该修正你的程序。</p>

<p>简而言之，8个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的</p>

<p>时候可以给你警告。留心这个警告。</p>

<p>在switch语句中消除多级缩进的首选的方式是让“switch”和从属于它的“case”标签对齐于同</p>

<p>一列，而不要“两次缩进”“case”标签。比如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="sc">&#39;G&#39;</span>:
</span><span class='line'><span class="k">case</span> <span class="sc">&#39;g&#39;</span>:
</span><span class='line'><span class="n">mem</span> <span class="o">&lt;&lt;=</span> <span class="mi">30</span><span class="p">;</span>
</span><span class='line'><span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="sc">&#39;M&#39;</span>:
</span><span class='line'><span class="k">case</span> <span class="sc">&#39;m&#39;</span>:
</span><span class='line'><span class="n">mem</span> <span class="o">&lt;&lt;=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'><span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="sc">&#39;K&#39;</span>:
</span><span class='line'><span class="k">case</span> <span class="sc">&#39;k&#39;</span>:
</span><span class='line'><span class="n">mem</span> <span class="o">&lt;&lt;=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* fall through */</span>
</span><span class='line'> <span class="nl">default:</span>
</span><span class='line'><span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不要把多个语句放在一行里，除非你有什么东西要隐藏：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="n">do_this</span><span class="p">;</span>
</span><span class='line'>     <span class="n">do_something_everytime</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读的表</p>

<p>达式。</p>

<p>除了注释、文档和Kconfig之外，不要使用空格来缩进，前面的例子是例外，是有意为之。</p>

<p>选用一个好的编辑器，不要在行尾留空格。</p>

<h2>第二章：把长的行和字符串打散</h2>

<p>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</p>

<p>每一行的长度的限制是80列，我们强烈建议您遵守这个惯例。</p>

<p>长于80列的语句要打散成有意义的片段。每个片段要明显短于原来的语句，而且放置的位置</p>

<p>也明显的靠右。同样的规则也适用于有很长参数列表的函数头。长字符串也要打散成较短的</p>

<p>字符串。唯一的例外是超过80列可以大幅度提高可读性并且不会隐藏信息的情况。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
</span><span class='line'>   <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Warning this is a long printk with &quot;</span>
</span><span class='line'>   <span class="s">&quot;3 parameters a: %u b: %u &quot;</span>
</span><span class='line'>   <span class="s">&quot;c: %u </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>   <span class="k">else</span>
</span><span class='line'>   <span class="n">next_statement</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>第三章：大括号和空格的放置</h2>

<p>C语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策</p>

<p>略并没有多少技术上的原因，不过首选的方式，就像Kernighan和Ritchie展示给我们的，是</p>

<p>把起始大括号放在行尾，而把结束大括号放在行首，所以：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="n">is</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="err">　　</span><span class="n">we</span> <span class="k">do</span> <span class="n">y</span>
</span><span class='line'>     <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这适用于所有的非函数语句块（if、switch、for、while、do）。比如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="n">KOBJ_ADD</span>:
</span><span class='line'><span class="k">return</span> <span class="s">&quot;add&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">KOBJ_REMOVE</span>:
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;remove&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">KOBJ_CHANGE</span>:
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;change&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="nl">default:</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>     <span class="p">{</span>
</span><span class='line'>     <span class="err">　　</span><span class="n">body</span> <span class="n">of</span> <span class="n">function</span>
</span><span class='line'>     <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>全世界的异端可能会抱怨这个不一致性是……呃……不一致的，不过所有思维健全的人都知道</p>

<p>a）K&amp;R是_正确的_，并且</p>

<p>b）K&amp;R是正确的。此外，不管怎样函数都是特殊的（在C语言中
，函数是不能嵌套的）。</p>

<p>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是do语句中的</p>

<p>“while”或者if语句中的“else”，像这样：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>     <span class="err">　　</span><span class="n">body</span> <span class="n">of</span> <span class="k">do</span><span class="o">-</span><span class="n">loop</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>和</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">..</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">....</span>
</span><span class='line'>     <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>理由：K&amp;R。</p>

<p>也请注意这种大括号的放置方式也能使空（或者差不多空的）行的数量最小化，同时不失可</p>

<p>读性。因此，由于你的屏幕上的新行是不可再生资源（想想25行的终端屏幕），你将会有更</p>

<p>多的空行来放置注释。</p>

<p>当只有一个单独的语句的时候，不用加不必要的大括号。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
</span><span class='line'>     <span class="err">　　</span><span class="n">action</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这点不适用于本身为某个条件语句的一个分支的单独语句。这时需要在两个分支里都使用大</p>

<p>括号。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">do_this</span><span class="p">();</span>
</span><span class='line'>      <span class="n">do_that</span><span class="p">();</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">otherwise</span><span class="p">();</span>
</span><span class='line'>     <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.1：空格</h3>

<p>Linux内核的空格使用方式（主要）取决于它是用于函数还是关键字。（大多数）关键字后</p>

<p>要加一个空格。值得注意的例外是sizeof、typeof、alignof和__attribute__，这些关键字</p>

<p>某些程度上看起来更像函数（它们在Linux里也常常伴随小括号而使用，尽管在C语言里这样</p>

<p>的小括号不是必需的，就像“struct fileinfo info”声明过后的“sizeof info”）。</p>

<p>所以在这些关键字之后放一个空格：</p>

<p>if, switch, case, for, do, while</p>

<p>但是不要在sizeof、typeof、alignof或者__attribute__这些关键字之后放空格。例如，</p>

<p>s = sizeof(struct file);</p>

<p>不要在小括号里的表达式两侧加空格。这是一个反例：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="n">s</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="k">struct</span> <span class="n">file</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当声明指针类型或者返回指针类型的函数时，“*”的首选使用方式是使之靠近变量名或者函</p>

<p>数名，而不是靠近类型名。例子：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">linux_banner</span><span class="p">;</span>
</span><span class='line'>     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">memparse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">retptr</span><span class="p">);</span>
</span><span class='line'>     <span class="kt">char</span> <span class="o">*</span><span class="nf">match_strdup</span><span class="p">(</span><span class="n">substring_t</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在大多数二元和三元操作符两侧使用一个空格，例如下面所有这些操作符：</p>

<p>=  +  &ndash;  &lt;  >  *  /  %  |  &amp;  ^  &lt;=  >=  ==  !=  ?  :</p>

<p>但是一元操作符后不要加空格：</p>

<p>&amp;  *  +  &ndash;  \~  !  sizeof  typeof  alignof  __attribute__  defined</p>

<p>后缀自加和自减一元操作符前不加空格：</p>

<p>++  &mdash;</p>

<p>前缀自加和自减一元操作符后不加空格：</p>

<p>++  &mdash;</p>

<p>“.”和“->”结构体成员操作符前后不加空格。</p>

<p>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后你</p>

<p>就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器就不</p>

<p>会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就这样产</p>

<p>生了。</p>

<p>当git发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白；不过</p>

<p>如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</p>

<h2>第四章：命名</h2>

<p>C是一个简朴的语言，你的命名也应该这样。和Modula-2和Pascal程序员不同，C程序员不使</p>

<p>用类似ThisVariableIsATemporaryCounter这样华丽的名字。C程序员会称那个变量为“tmp”</p>

<p>，这样写起来会更容易，而且至少不会令其难于理解。</p>

<p>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字</p>

<p>。称一个全局函数为“foo”是一个难以饶恕的错误。</p>

<p>全局变量（只有当你真正需要它们的时候再用它）需要有一个具描述性的名字，就像全局函</p>

<p>数。如果你有一个可以计算活动用户数量的函数，你应该叫它“count_active_users()”或者</p>

<p>类似的名字，你不应该叫它“cntuser()”。</p>

<p>在函数名中包含函数类型（所谓的匈牙利命名法）是脑子出了问题——编译器知道那些类型而</p>

<p>且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</p>

<p>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器</p>

<p>，它应该被称为“i”。叫它“loop_counter”并无益处，如果它没有被误解的可能的话。类似</p>

<p>的，“tmp”可以用来称呼任意类型的临时变量。</p>

<p>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症</p>

<p>。请看第六章（函数）。</p>

<h2>第五章：Typedef</h2>

<p>不要使用类似“vps_t”之类的东西。</p>

<p>对结构体和指针使用typedef是一个错误。当你在代码里看到：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="n">vps_t</span> <span class="n">a</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代表什么意思呢？</p>

<p>相反，如果是这样</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">struct</span> <span class="n">virtual_container</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>你就知道“a”是什么了。</p>

<p>很多人认为typedef“能提高可读性”。实际不是这样的。它们只在下列情况下有用：</p>

<p> (a)
完全不透明的对象（这种情况下要主动使用typedef来隐藏这个对象实际上是什么）。</p>

<p>例如：“pte_t”等不透明对象，你只能用合适的访问函数来访问它们。</p>

<p> 注意！不透明性和“访问函数”本身是不好的。我们使用pte_t等类型的原因在于真的是</p>

<p>完全没有任何共用的可访问信息。</p>

<p> (b)
清楚的整数类型，如此，这层抽象就可以帮助消除到底是“int”还是“long”的混淆。</p>

<p>u8/u16/u32是完全没有问题的typedef，不过它们更符合类别(d)而不是这里。</p>

<p>再次注意！要这样做，必须事出有因。如果某个变量是“unsigned
long“，那么没有必要</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">myflags_t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过如果有一个明确的原因，比如它在某种情况下可能会是一个“unsigned
int”而在</p>

<p>其他情况下可能为“unsigned long”，那么就不要犹豫，请务必使用typedef。</p>

<p> &copy; 当你使用sparse按字面的创建一个新类型来做类型检查的时候。</p>

<p> (d) 和标准C99类型相同的类型，在某些例外的情况下。</p>

<p> 虽然让眼睛和脑筋来适应新的标准类型比如“uint32_t”不需要花很多时间，可是有些</p>

<p>人仍然拒绝使用它们。</p>

<p> 因此，Linux特有的等同于标准类型的“u8/u16/u32/u64”类型和它们的有符号类型是被</p>

<p>允许的——尽管在你自己的新代码中，它们不是强制要求要使用的。</p>

<p> 当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</p>

<p> (e) 可以在用户空间安全使用的类型。</p>

<p> 在某些用户空间可见的结构体里，我们不能要求C99类型而且不能用上面提到的“u32”</p>

<p> 类型。因此，我们在与用户空间共享的所有结构体中使用__u32和类似的类型。</p>

<p>可能还有其他的情况，不过基本的规则是永远不要使用typedef，除非你可以明确的应用上</p>

<p>述某个规则中的一个。</p>

<p>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不</p>

<p>应该是一个typedef。</p>

<h2>第六章：函数</h2>

<p>函数应该简短而漂亮，并且只完成一件事情。函数应该可以一屏或者两屏显示完（我们都知</p>

<p>道ISO/ANSI屏幕大小是80x24），只做一件事情，而且把它做好。</p>

<p>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上</p>

<p>很简单的只有一个很长（但是简单）的case语句的函数，而且你需要在每个case里做很多很</p>

<p>小的事情，这样的函数尽管很长，但也是可以的。</p>

<p>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至</p>

<p>搞不清楚这个函数的目的，你应该严格的遵守前面提到的长度限制。使用辅助函数，并为之</p>

<p>取个具描述性的名字（如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的</p>

<p>效果往往会比你写一个复杂函数的效果要好。）</p>

<p>函数的另外一个衡量标准是本地变量的数量。此数量不应超过5－10个，否则你的函数就有</p>

<p>问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟</p>

<p>踪7个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你2</p>

<p>个星期前做过的事情。</p>

<p>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的EXPORT*宏应该紧贴</p>

<p>在它的结束大括号之下。比如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="kt">int</span> <span class="nf">system_is_up</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'>     <span class="p">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_RUNNING</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">system_is_up</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在函数原型中，包含函数名和它们的数据类型。虽然C语言里没有这样的要求，在Linux里这</p>

<p>是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</p>

<p>第七章：集中的函数退出途径</p>

<p>虽然被某些人声称已经过时，但是goto语句的等价物还是经常被编译器所使用，具体形式是</p>

<p>无条件跳转指令。</p>

<p>当一个函数从多个位置退出并且需要做一些通用的清理工作的时候，goto的好处就显现出来</p>

<p>了。</p>

<p>理由是：</p>

<ul>
<li><p>无条件语句容易理解和跟踪</p></li>
<li><p>嵌套程度减小</p></li>
<li><p>可以避免由于修改时忘记更新某个单独的退出点而导致的错误</p></li>
<li><p>减轻了编译器的工作，无需删除冗余代码;)</p></li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>     <span class="kt">int</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">condition1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">while</span> <span class="p">(</span><span class="n">loop1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="p">...</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>       <span class="p">...</span>
</span><span class='line'>      <span class="nl">out:</span>
</span><span class='line'>       <span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第八章：注释</p>

<p>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的：更好</p>

<p>的做法是让别人一看你的代码就可以明白，解释写的很差的代码是浪费时间。</p>

<p>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释</p>

<p>放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到</p>

<p>第六章看一看。你可以做一些小注释来注明或警告某些很聪明（或者槽糕）的做法，但不要</p>

<p>加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么，也可以加上它做这</p>

<p>些事情的原因。</p>

<p>当注释内核API函数时，请使用kernel-doc格式。请看</p>

<p>Documentation/kernel-doc-nano-HOWTO.txt和scripts/kernel-doc以获得详细信息。</p>

<p>Linux的注释风格是C89“/* &hellip; */”风格。不要使用C99风格“// &hellip;”注释。</p>

<p>长（多行）的首选注释风格是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>
</span><span class='line'>     <span class="cm">/*</span>
</span><span class='line'><span class="cm">      * This is the preferred style for multi-line</span>
</span><span class='line'><span class="cm">      * comments in the Linux kernel source code.</span>
</span><span class='line'><span class="cm">      * Please use it consistently.</span>
</span><span class='line'><span class="cm">      *</span>
</span><span class='line'><span class="cm">      * Description: A column of asterisks on the left side,</span>
</span><span class='line'><span class="cm">      * with beginning and ending almost-blank lines.</span>
</span><span class='line'><span class="cm">     */</span>
</span></code></pre></td></tr></table></div></figure>


<p>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行应只</p>

<p>声明一个数据（不要使用逗号来一次声明多个数据）。这样你就有空间来为每个数据写一段</p>

<p>小注释来解释它们的用途了。</p>

<p>第九章：你已经把事情弄糟了</p>

<p>这没什么，我们都是这样。可能你的使用了很长时间Unix的朋友已经告诉你“GNU
emacs”能</p>

<p>自动帮你格式化C源代码，而且你也注意到了，确实是这样，不过它所使用的默认值和我们</p>

<p>想要的相去甚远（实际上，甚至比随机打的还要差——无数个猴子在GNU
emacs里打字永远不</p>

<p>会创造出一个好程序）（译注：请参考Infinite Monkey Theorem）</p>

<p>所以你要么放弃GNU
emacs，要么改变它让它使用更合理的设定。要采用后一个方案，你可</p>

<p>以把下面这段粘贴到你的.emacs文件里。</p>

<p>(defun linux-c-mode ()</p>

<p>  &ldquo;C mode with adjusted defaults for use with the Linux kernel.&rdquo;</p>

<p>  (interactive)</p>

<p>  (c-mode)</p>

<p>  (c-set-style &ldquo;K&amp;R&rdquo;)</p>

<p>  (setq tab-width 8)</p>

<p>  (setq indent-tabs-mode t)</p>

<p>  (setq c-basic-offset 8))</p>

<p>这样就定义了M-x linux-c-mode命令。当你hack一个模块的时候，如果你把字符串</p>

<p>&ndash;*&ndash; linux-c
&ndash;*-放在头两行的某个位置，这个模式将会被自动调用。如果你希望在你修改</p>

<p>/usr/src/linux里的文件时魔术般自动打开linux-c-mode的话，你也可能需要添加</p>

<p>(setq auto-mode-alist (cons &lsquo;(&ldquo;/usr/src/linux.*/.*&#92;.[ch]\$&rdquo; .
linux-c-mode)</p>

<p>auto-mode-alist))</p>

<p>到你的.emacs文件里。</p>

<p>不过就算你尝试让emacs正确的格式化代码失败了，也并不意味着你失去了一切：还可以用“</p>

<p>indent”。</p>

<p>不过，GNU indent也有和GNU
emacs一样有问题的设定，所以你需要给它一些命令选项。不</p>

<p>过，这还不算太糟糕，因为就算是GNU
indent的作者也认同K&amp;R的权威性（GNU的人并不是坏</p>

<p>人，他们只是在这个问题上被严重的误导了），所以你只要给indent指定选项“-kr
-i8”</p>

<p>（代表“K&amp;R，8个字符缩进”），或者使用“scripts/Lindent”，这样就可以以最时髦的方式</p>

<p>缩进源代码。</p>

<p>“indent”有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册页。不过</p>

<p>记住：“indent”不能修正坏的编程习惯。</p>

<h2>第十章：Kconfig配置文件</h2>

<p>对于遍布源码树的所有Kconfig*配置文件来说，它们缩进方式与C代码相比有所不同。紧挨</p>

<p>在“config”定义下面的行缩进一个制表符，帮助信息则再多缩进2个空格。比如：</p>

<p>config AUDIT</p>

<p>bool &ldquo;Auditing support&rdquo;</p>

<p>depends on NET</p>

<p>help</p>

<p>  Enable auditing infrastructure that can be used with another</p>

<p>  kernel subsystem, such as SELinux (which requires this for</p>

<p>  logging of avc messages output).  Does not do system-call</p>

<p>  auditing without CONFIG_AUDITSYSCALL.</p>

<p>仍然被认为不够稳定的功能应该被定义为依赖于“EXPERIMENTAL”：</p>

<p>config SLUB</p>

<p>depends on EXPERIMENTAL &amp;&amp; !ARCH_USES_SLAB_PAGE_STRUCT</p>

<p>bool &ldquo;SLUB (Unqueued Allocator)&rdquo;</p>

<p>&hellip;</p>

<p>而那些危险的功能（比如某些文件系统的写支持）应该在它们的提示字符串里显著的声明这</p>

<p>一点：</p>

<p>config ADFS_FS_RW</p>

<p>bool &ldquo;ADFS write support (DANGEROUS)&rdquo;</p>

<p>depends on ADFS_FS</p>

<p>&hellip;</p>

<p>要查看配置文件的完整文档，请看Documentation/kbuild/kconfig-language.txt。</p>

<h2>第十一章：数据结构</h2>

<p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计</p>

<p>数器。内核里没有垃圾收集（并且内核之外的垃圾收集慢且效率低下），这意味着你绝对需</p>

<p>要记录你对这种数据结构的使用情况。</p>

<p>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构——而不需要担心</p>

<p>这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一</p>

<p>些其他事情而已。</p>

<p>注意上锁不能取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管</p>

<p>理技巧。通常二者都需要，不要把两个搞混了。</p>

<p>很多数据结构实际上有2级引用计数，它们通常有不同“类”的用户。子类计数器统计子类用</p>

<p>户的数量，每当子类计数器减至零时，全局计数器减一。</p>

<p>这种“多级引用计数”的例子可以在内存管理（“struct
mm_struct”：mm_users和mm_count）</p>

<p>和文件系统（“struct super_block”：s_count和s_active）中找到。</p>

<p>记住：如果另一个执行线索可以找到你的数据结构，但是这个数据结构没有引用计数器，这</p>

<p>里几乎肯定是一个bug。</p>

<h2>第十二章：宏，枚举和RTL</h2>

<p>用于定义常量的宏的名字及枚举里的标签需要大写。</p>

<pre><code>#define CONSTANT 0x12345
</code></pre>

<p>在定义几个相关的常量时，最好用枚举。</p>

<p>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</p>

<p>一般的，如果能写成内联函数就不要写成像函数的宏。</p>

<p>含有多个语句的宏应该被包含在一个do-while代码块里：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="err">#</span><span class="n">define</span> <span class="n">macrofun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'>     <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>      <span class="n">do_this</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用宏的时候应避免的事情：</p>

<p>​1) 影响控制流程的宏：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="err">#</span><span class="n">define</span> <span class="n">FOO</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>     <span class="k">do</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">blah</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>     <span class="k">return</span> <span class="o">-</span><span class="n">EBUGGERED</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>非常不好。它看起来像一个函数，不过却能导致“调用”它的函数退出；不要打乱读者大脑里</p>

<p>的语法分析器。</p>

<p>​2) 依赖于一个固定名字的本地变量的宏：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>     <span class="err">#</span><span class="n">define</span> <span class="n">FOO</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="n">bar</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来</p>

<p>不相关的改动带来错误。</p>

<p>​3) 作为左值的带参数的宏： FOO(x) =
y；如果有人把FOO变成一个内联函数的话，这种用</p>

<p>法就会出错了。</p>

<p>​4)
忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数的</p>

<p>宏也要注意此类问题。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="err">#</span><span class="n">define</span> <span class="n">CONSTANT</span> <span class="mh">0x4000</span>
</span><span class='line'>     <span class="err">#</span><span class="n">define</span> <span class="n">CONSTEXP</span> <span class="p">(</span><span class="n">CONSTANT</span> <span class="o">|</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>cpp手册对宏的讲解很详细。Gcc internals手册也详细讲解了RTL（译注：register</p>

<p>transfer language），内核里的汇编语言经常用到它。</p>

<h2>第十三章：打印内核消息</h2>

<p>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。不要</p>

<p>用不规范的单词比如“dont”，而要用“do
not”或者“don&#8217;t”。保证这些信息简单、明了、无</p>

<p>歧义。</p>

<p>内核信息不必以句号（译注：英文句号，即点）结束。</p>

<p>在小括号里打印数字(%d)没有任何价值，应该避免这样做。</p>

<p>&lt;linux/device.h>里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的</p>

<p>设备和驱动，并且被标记了正确的消息级别。这些宏有：dev_err(), dev_warn(),</p>

<p>dev_info()等等。对于那些不和某个特定设备相关连的信息，&lt;linux/kernel.h>定义了</p>

<p>pr_debug()和pr_info()。</p>

<p>写出好的调试信息可以是一个很大的挑战；当你写出来之后，这些信息在远程除错的时候</p>

<p>就会成为极大的帮助。当DEBUG符号没有被定义的时候，这些信息不应该被编译进内核里</p>

<p>（也就是说，默认地，它们不应该被包含在内）。如果你使用dev_dbg()或者pr_debug()，</p>

<p>就能自动达到这个效果。很多子系统拥有Kconfig选项来启用-DDEBUG。还有一个相关的惯例</p>

<p>是使用VERBOSE_DEBUG来添加dev_vdbg()消息到那些已经由DEBUG启用的消息之上。</p>

<p>第十四章：分配内存</p>

<p>内核提供了下面的一般用途的内存分配函数：kmalloc()，kzalloc()，kcalloc()和</p>

<p>vmalloc()。请参考API文档以获取有关它们的详细信息。</p>

<p>传递结构体大小的首选形式是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>     <span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外一种传递方式中，sizeof的操作数是结构体的名字，这样会降低可读性，并且可能会引</p>

<p>入bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的sizeof的结果不变。</p>

<p>强制转换一个void指针返回值是多余的。C语言本身保证了从void指针到其他任何指针类型</p>

<p>的转换是没有问题的。</p>

<p>第十五章：内联弊病</p>

<p>有一个常见的误解是内联函数是gcc提供的可以让代码运行更快的一个选项。虽然使用内联</p>

<p>函数有时候是恰当的（比如作为一种替代宏的方式，请看第十二章），不过很多情况下不是</p>

<p>这样。inline关键字的过度使用会使内核变大，从而使整个系统运行速度变慢。因为大内核</p>

<p>会占用更多的指令高速缓存（译注：一级缓存通常是指令缓存和数据缓存分开的）而且会导</p>

<p>致pagecache的可用内存减少。想象一下，一次pagecache未命中就会导致一次磁盘寻址，将</p>

<p>耗时5毫秒。5毫秒的时间内CPU能执行很多很多指令。</p>

<p>一个基本的原则是如果一个函数有3行以上，就不要把它变成内联函数。这个原则的一个例</p>

<p>外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能</p>

<p>优化掉你的函数的大部分代码，那仍然可以给它加上inline关键字。kmalloc()内联函数就</p>

<p>是一个很好的例子。</p>

<p>人们经常主张给static的而且只用了一次的函数加上inline，如此不会有任何损失，因为没</p>

<p>有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加inline
gcc</p>

<p>也可以自动使其内联。而且其他用户可能会要求移除inline，由此而来的争论会抵消inline</p>

<p>自身的潜在价值，得不偿失。</p>

<h2>第十六章：函数返回值及命名</h2>

<p>函数可以返回很多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样</p>

<p>的一个值可以表示为一个错误代码整数（-Exxx＝失败，0＝成功）或者一个“成功”布尔值（</p>

<p>0＝失败，非0＝成功）。</p>

<p>混合使用这两种表达方式是难于发现的bug的来源。如果C语言本身严格区分整形和布尔型变</p>

<p>量，那么编译器就能够帮我们发现这些错误……不过C语言不区分。为了避免产生这种bug，请</p>

<p>遵循下面的惯例：</p>

<p>如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代码整</p>

<p>数。如果是一个判断，那么函数应该返回一个“成功”布尔值。</p>

<p>比如，“add
work”是一个命令，所以add_work()函数在成功时返回0，在失败时返回-EBUSY。</p>

<p>类似的，因为“PCI device
present”是一个判断，所以pci_dev_present()函数在成功找到</p>

<p>一个匹配的设备时应该返回1，如果找不到时应该返回0。</p>

<p>所有导出（译注：EXPORT）的函数都必须遵守这个惯例，所有的公共函数也都应该如此。私</p>

<p>有（static）函数不需要如此，但是我们也推荐这样做。</p>

<p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的，他们</p>

<p>通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数，他们使用</p>

<p>NULL或者ERR_PTR机制来报告错误。</p>

<h2>第十七章：不要重新发明内核宏</h2>

<p>头文件include/linux/kernel.h包含了一些宏，你应该使用它们，而不要自己写一些它们的</p>

<p>变种。比如，如果你需要计算一个数组的长度，使用这个宏</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>     <span class="err">#</span><span class="n">define</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">((</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似的，如果你要计算某结构体成员的大小，使用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>     <span class="err">#</span><span class="n">define</span> <span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(((</span><span class="n">t</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有可以做严格的类型检查的min()和max()宏，如果你需要可以使用它们。你可以自己看看</p>

<p>那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里</p>

<p>自己重新定义。</p>

<h2>第十八章：编辑器模式行和其他需要罗嗦的事情</h2>

<p>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs</p>

<p>能够解释被标记成这样的行：</p>

<p>&ndash;*&ndash; mode: c &ndash;*&ndash;</p>

<p>或者这样的：</p>

<p>/*</p>

<p>Local Variables:</p>

<p>compile-command: &ldquo;gcc -DMAGIC_DEBUG_FLAG foo.c&rdquo;</p>

<p>End:</p>

<p>*/</p>

<p>Vim能够解释这样的标记：</p>

<p>/* vim:set sw=8 noet */</p>

<p>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应</p>

<p>该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模</p>

<p>式，或者使用其他可以产生正确的缩进的巧妙方法。</p>

<h2>附录 I：参考</h2>

<p>The C Programming Language, 第二版, 作者Brian W. Kernighan和Denni</p>

<ol type="a">
<li>Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮),</li>
</ol>


<p>0-13-110370-9 (硬皮). URL: <a href="http://cm.bell-labs.com/cm/cs/cbook/">http://cm.bell-labs.com/cm/cs/cbook/</a></p>

<p>The Practice of Programming 作者Brian W. Kernighan和Rob Pike.
 Addison-Wesley,</p>

<p>Inc., 1999.  ISBN 0-201-61586-X.  URL:
<a href="http://cm.bell-labs.com/cm/cs/tpop/">http://cm.bell-labs.com/cm/cs/tpop/</a></p>

<p>cpp，gcc，gcc
internals和indent的GNU手册——和K&amp;R及本文相符合的部分，全部可以在</p>

<p><a href="http://www.gnu.org/manual/%E6%89%BE%E5%88%B0">http://www.gnu.org/manual/%E6%89%BE%E5%88%B0</a></p>

<p>WG14是C语言的国际标准化工作组，URL:
<a href="http://www.open-std.org/JTC1/SC22/WG14/">http://www.open-std.org/JTC1/SC22/WG14/</a></p>

<p>Kernel CodingStyle，作者greg@kroah.com发表于OLS 2002：</p>

<p><a href="http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/">http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</a></p>

<p>&mdash;</p>

<p>最后更新于2007年7月13日。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核编译安装及卸载]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/linuxnei-he-bian-yi-an-zhuang-ji-xie-zai/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/linuxnei-he-bian-yi-an-zhuang-ji-xie-zai</id>
    <content type="html"><![CDATA[<p>编译安装：</p>

<p>下载需要的包</p>

<pre><code>apt-get install kernel-package libncurses5-dev fakeroot wget bzip2
cp linux-3.x.x /usr/src
cd /usr/src/linux-3.x.x
make menuconfig
make modules
make modules\_install
make
make install
sudo mkinitramfs -o /boot/initrd.img-3.x.x
sudo update-initramfs -c -k 3.x.x
sudo update-grub2
</code></pre>

<hr />

<p> <!--more--></p>

<p>卸载：</p>

<p> custom compiled kernel you need to remove following files/dirs:</p>

<ul>
<li>/boot/vmlinuz*KERNEL-VERSION*</li>
<li>/boot/initrd*KERNEL-VERSION*</li>
<li>/boot/System-map*KERNEL-VERSION*</li>
<li>/boot/config-*KERNEL-VERSION*</li>
<li>/lib/modules/*KERNEL-VERSION*/</li>
<li>Update grub configuration file /etc/grub.conf or /boot/grub/menu.lst
to point to correct kernel version.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux KVM代码之美]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/linux-kvmdai-ma-zhi-mei/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/linux-kvmdai-ma-zhi-mei</id>
    <content type="html"><![CDATA[<p> <strong>edited as an essey for <em>程序语言设计原理</em> </strong></p>

<hr />

<p>在程序的编写上，我认为编程的难度，也就是可写性是一个次要的角色，而代码的可读性，可维护性一直软件生命周期中的主要部分，尤其是对于大型项目而言，软件的维护绝对是项目管理人员首先要考虑的问题，成本的控制，人月量的降低。在这一点上更为突出表现的我想应该是对于开源项目来说，人员的流动性大，项目时间的不确定性，还有对开发人员的吸引力。开源项目应该关注的不止是软件功能性的强大，思维理念的超前，更应该是代码的可读性，可维护性。毕竟没有人愿意在垃圾场上重新盖一栋漂亮的大楼。所以开源项目应该从一开始就在可读性，可维护性上下工夫，并且需要有一些自己的理念，开发标准在里面，这样可以引导后来的开发人员遵循这些原则，保证代码的可读性，可维护性，避免出现破窗效应。</p>

<p>那么如此看来，代码之美又应该包括哪些方面呢，我想应该需要有程序的可读性，可维护性，另外还需要有一些设计准则。这里就以Linux内核中的KVM代码部分为例，谈谈这些原则。</p>

<h2>一、可读性、可维护性</h2>

<p>在Github上打开Linux内核代码，涉及KVM的主要有两个目录，virt和arch/x86/kvm，我们主要研究的是arch/x86/kvm。文件夹下的Makefile和Kconfig文件可以将程序的脉络显得极为的清晰。</p>

<p>现在查看的是emulate.c文件，程序大概有4000多行，这也是C语言代码中值得诟病的地方，因为程序代码超过2页屏幕大小后，会影响人们对程序的理解，难于找到需要注意的地方，并且纠结于大量的方法和结构体之间。</p>

<p>emulate.c的文件头注释表明只是一个X86架构（32位或者64位）指令的译码器和模拟器，并且表明程序的作者，来源，程序具体涉及的方面。代码是遵循Linux编码规范的。</p>

<!--more-->


<p>包括8个字符缩进，把长的行和字符串打散，大括号和空格的放置，命名规范等。在Linux内核中Documentation/CodingStyle文件中有句话表明这些规范的用处“代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性”，无需特别的编辑器，只需要一个普通的文本编辑器就可以了。这些规范十分有利于读者理解和修改代码，例如不超过80列的代码长度使得函数体中的形式参数不会显得拥挤不堪，分不清个数。如图1中这样的例子在这4000行代码中俯拾皆是，极大的提高了可读性。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/1.png" alt="图1"/></p>

<p>可能是得益于C语言设计的简单性和正交性，我在Linux代码中很少看到有3层以上的嵌套，代码的逻辑大多数可以在最多2层的嵌套中完成。并且程序的控制语句可以将代码的逻辑部分清晰的展现出来，无需过多的升入理解。另外，程序中的注释部分所占的比例也不会很大，不会出现注释数量比代码数量还要多的情况，并且注释部分十分的简短精细。这表明对程序片段的理解无需额外的添加注释，只是凭借代码的逻辑结构和命名就可以很好的理解代码，而且注释的语言不会显得赘述，只是简单扼要的解释片段功能或逻辑。例如图2中的情形，复杂的位操作尽管提高了效率，可是难以理解，这时就需要注释来帮助解释。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/2.png" alt="图2"/></p>

<p>可读性在很多的时候是与可维护性相关联的，程序写出来很大一部分原因就是为了维护，而强可读性对于程序的理解至关重要，特别是人员流动性强的时候，而语言的特性和优秀的代码规范是可读性的保证，Linux内核代码在这两方面都做得非常好，拥有Documentation/CodingStyle这样的编程规范，还有C语言这样的高级程序设计语言。从另一方面来说，可读性强也同时意味着可写性强，因为在编写程序的过程中，编程人员需要不断地阅读已经编写的程序部分。</p>

<h2>二、设计准则</h2>

<h3>1. 频度准则</h3>

<p>越常用越简单，包括命名，和函数体。例如在模拟器的缓存表写入时有两个函数体，一个reg_write，另外一个为writeback_registers。表示的意思一个为写入，另外一个是回写，这个是对应于Cache的不同存取机制的，显然第一个较为常用，所以在命名上面会比第二个简略一些。</p>

<p>而对于更为常用的函数来说，例如一些简单的位运算，kvm将这些函数当做预编译的部分，放在函数开头。如下图3，就表示一个栈的指令移动，在代码中频繁的出现则用预编译函数来表示。并且有一些函数使用了内联的方法来提高性能，这些函数往往是另外一个复杂或者多次使用的函数的一部分，所以内联的函数函数体都比较简单，拥有一个描述性的名字，并且作用通常是作为辅助函数。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/3.png" alt="图3"/></p>

<h3>2. 结构一致</h3>

<p>结构一致表示的是程序结构和计算的逻辑结构一致。Kvm代码可以体现出自顶向下、逐步求精的思想，复杂问题，往往有一个总体的引导性函数，然后会由一些子函数，辅助函数来作为过渡，逐步细化地解决问题。上文提到的一些预编译函数，内联函数就是起到这样的作用的。</p>

<p>并且在程序中使用了大量的条件语句，循环语句，返回语句，可以很容易的把握程序结构和计算的逻辑结构的一致性。另外不得不提的一点是，kvm代码中并没有摒弃goto语句的使用，一开始基于老师们和专家们的建议“不要使用goto语句”，我对这些代码有着很大的反感，但是仔细阅读后发现使用GOTO语句，会使程序流程更清楚、效率更高。</p>

<p>例如图4中，代码清晰的表示了获取操作数后处理器将要做得事情，程序的结构和计算逻辑是一致的，并不存在什么晦涩难懂的部分。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/4.png" alt="图4"/></p>

<h3>3. 局部性</h3>

<p>C语言是不鼓励使用全局变量的。在emulator.c的代码中我也并未有发现全局变量的使用。代码规范里头对全局变量的描述是“只有当你真正需要它们的时候再用它”。并且对于局部变量的使用它是有标准的：“函数的另外一个衡量标准是本地变量的数量。此数量不应超过5－10个，否则你的函数就有问题了”。</p>

<p>kvm代码中函数的局部变量都很少，并且命名十分的简洁，一般为2-3个字母，是放在一块儿申明的。声明完后空一行，开始函数的逻辑部分。</p>

<h3>4. 词法内聚</h3>

<p>词法内聚是变量在使用处就近声明。这一点要看使用处的定义，因为kvm中变量的声明是放在一块的，对于函数来说，是在使用处定义。但如果把使用处定义为使用变量的具体位置，表达式或判断赋值语句，那么kvm代码中的变量声明就不是词法内聚了。</p>

<h2>三、总结</h2>

<p>总的来说Linux内核代码所带来的标准已经影响了很多从业人员，并且正在成为C语言代码的标准规范。这个规范是从Brian Kernighan和Dennis Ritchie开始的，也就是著名的经典C，并且经历了C90、C99标准，根据不同的需求在变化着，修改着。我所看到的这个CodingStyle是在两天前 Joe Perches提交的，添加了网络块的评论规范。</p>

<p>但是这些修改变化，有一个共同的目标就是使linux内核代码能够看起来更加的舒适，理解起来更容易，并最终做到可写性和维护性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个linux命令]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/ji-ge-linuxming-ling/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/ji-ge-linuxming-ling</id>
    <content type="html"><![CDATA[<p>转换文件到pdf</p>

<pre><code>unoconv -f pdf mydocument.odt
</code></pre>

<p>zip乱码解压</p>

<pre><code>unzip -O CP936 xx.zip
</code></pre>

<p>mp3 乱码</p>

<pre><code>mid3iconv -e gbk \*.mp3 //当前目录下的mp3文件
</code></pre>

<p>视频转码</p>

<pre><code>mencoder \*.rmvb -o output.avi -oac mp3lame -lameopts cbr:br=32 -ovc x264 -x264encopts bitrate=440 -vf scale=320:-3
</code></pre>

<p>linux 声音调节  alsamixer</p>

<p>gedit 乱码：</p>

<pre><code>gsettings set org.gnome.gedit.preferences.encodings auto-detected "['UTF-8','CURRENT','GB18030','ISO-8859-15','UTF-16']"
</code></pre>

<p>SSH 远程登录：</p>

<pre><code>ssh -l root 192.168.0.150
</code></pre>

<p>vim 中文乱码：</p>

<p>let &amp;termencoding=&amp;encoding\
set fileencodings=utf-8,gbk</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hugo]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/hugo/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/hugo</id>
    <content type="html"><![CDATA[<p>好久没写影评，或者更确切的是观后感了。</p>

<p>呵呵，电影最近是看了蛮多的，一天差不多至少是一部，两个小时吧。喜欢看泰国片，那种小清新的，没有多少压力和内涵，让人放松，给人一种繁忙后的室外桃园。嗯，还有一些日本片，但是日本的这种电影，给人的感觉不像台湾或者泰国那样的悠闲，自在；可能这么说并不是很恰当，但是日本电影它似乎总想把某种思想哲学，对于人生，对于爱情，对于人性的理解加入到其中，看完后会有一些压抑，脑袋里沉浮了一些东西，所以对于日本片来说，我看的并不像泰国片那么频繁。</p>

<p>最近看的是一部叫<em>&lt;恋空></em>的电影，回想起来，对于其中的剧情和影片想要表述的意思还是可以回味一二，并且有着不小的余音。但那天看完后并没有写一些东西出来，应该是自己的问题，一方面投入的感情并没有想象中的那么多，所以写出来的东西并不会让我很满意；另一方面应该就是太久未能写影评了，看完电影后也不会去深入挖掘，只是偶尔在脑子里溜达一圈也就罢了，想想好笑，也就是前几天才看的电影，忽然又见到其中的主角，而我却叫不出那部影片的名字，惰性思想还是要不得啊！</p>

<p>今天其实也并没有打算写这篇影评的，我已经是关机上床的状态，但是手机在充电，一时半会开不了机，于是就在脑海里想着今天看过的电影。看了两部，今天晚上，第一部是<em>&lt;宿醉></em>，嗯，纯粹的商业搞笑片，没有太多的感情，属于那种看过就忘的。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/17285214112051.jpg" alt="hugo" height="500"/></p>

<!--more-->


<p>第二部是<em>&lt;雨果></em>，它的IMDB是8.2，在床上我就慢慢回忆起影片中的一些信息，那些情节对话，当然是从宏观的角度来想。那时就想着，奇怪啊，这部片子，我越看就觉得不是上8.0的料啊，也就7.6,7.8那个样子，为什么他就能上8.0呢，要想在我眼中，上8.0的片子那都是非常值得一看的，但是对于<em>&lt;雨果></em>来说，我觉得不看我也不回后悔什么，就是并没有让我觉得非常出色，是其他影片所体现不出的东西。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/00e93901213fb80ed31f827636d12f2eb8389441.jpg" alt="Chloe Grace Moretz"/></p>

<p>心存疑惑，于是就好好的剪辑着这部电影。嗯，首先是演员选择上不错，第一眼见到我就认为是下一个赫敏的科洛·莫瑞兹，初时觉得很熟悉，后来查资料发现是<em>&lt;和莎莫的500天></em>里那个超级可爱早熟的小女孩。哦，天哪，她才15岁现在，这是一个非常有天赋的演员啊。在电影里头的表演也是非常的到位，特别是面部的表情，呵呵，导演摄像师估计也知道她的这一优点，给了非常多的特写。嗯，还有那个小男孩也不错，额，名字就不查了，因为对我没有太大的吸引力，哈哈。他的表演也非常的到位，但是还是略显青涩啊，动作和表情都有一些不自然，幅度过大。其他演员就不说了，值得一提的是影片中有3个以上的演员是Harry
Potter中的。哈哈，有个有是什么意思呢&hellip;</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/201112081732267907.jpg" alt="Chloe Grace Moretz"/></p>

<p>然后还有比较出色的地方就是对于画面，cg动画的处理，paris的黎明，黄昏，深夜，一幅幅的图画都非常的经典，而且给人感觉并不像阿凡达中的娇作，嗯，是那种返璞的，柔和的，写实油画的清新。画面中的建筑物多，结构细节繁琐，但整个画面来说却是画风细腻，布局清晰，勾勒得当，写意清明。真实大师风范，是我看过的cg中最精彩的之一，特别是开场的引入，我当时直呼没有到电影院去看3D真是太可惜了。</p>

<p>其他地方对我来说就显得十分的一般，无论是主题，情节的发展还是布局，没多少好点评细说的。但仔细的思考后，<em>&lt;雨果></em>作为一部商业片来说，在儿童节是上映的娱乐片来说，这部影片的以上优点足以让这部影片利于不败之地，它是成功的。这可能正是它的8.2的缘由。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互联网发展方向思考]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/hu-lian-wang-fa-zhan-fang-xiang-si-kao/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/hu-lian-wang-fa-zhan-fang-xiang-si-kao</id>
    <content type="html"><![CDATA[<p><em>edited from <a href="http://www.36kr.com/p/201525.html">36氪</a></em></p>

<hr />

<p><img src="http://a.36krcnd.com/photo/c9ef3536af556bb5530af32befaaeae8.png" title="T-E-C-H法则" alt="" /></p>

<p> 在互联网领域，要找到新的创新点，还是需要借鉴美国发展的模式。虽然美国与中国有着各自不同的国情，美国成功的应用在中国不一定可以找到适合它们的土壤，但是从中国几个新兴的创业巨头来看，无一不是根植与美国，由于中国的网络壁垒或者美国应用的本土化不强而创造出在中国的机会。从发展上看来，都是有先有多家startup的成立，在各自独立发展用户，或从相同的客户群中寻找潜在的用户资源，或是在不同的用户群众寻找，但是有一个共同点都是在美国成功的应用中进行借鉴。从《结网》中可以看到，对一个新兴的应用来说最为关键的不止是借鉴先有的成功的应用，还需要找到这个应用idea的起源，因为这里面包含有应用最核心的本质。在各个独立应用发展到一定阶段，圈到了一定的用户之后，关键在与培养用户的黏合度，用户是不是对这个产品有所依赖，是不是形成技术壁垒和用户壁垒即特定的用户群。在成功圈到一定用户之后，开始扩张领域，向其他同类产品拼抢用户资源，开始了互联网中最残酷的战争，这时也是公司最应该小心的时候，水桶中的任何一块木头都可能是潜在的漏洞，给对手带来机会。所以，方向的选择、良好的产品发展思路和绝对的执行力是成功的三大要素。从方向上来看我们习惯盯准美国，而美国的核心是加州，加州的辐射点是硅谷，硅谷的成功很大程度上在standford。关注standford。</p>

<!--more-->


<p><strong><em>近期的互联网方向</em></strong></p>

<p>在近期的互联网方向，有三个方向值得注意：</p>

<p>​1. 移动习惯培养</p>

<p>从最近极为成功的应用中都可以看到它们的影子，twitter，yelp，dropbox等等。但是作为存储、计算和执行终端的手机，未来将不仅仅给出信息和推荐，而是直接参与规划和执行。所谓的习惯培养，应该一脉相承的应用整合平台。只是如今市场浑水一汪，想要出类拔萃实在不易。</p>

<p>​2. 企业级应用</p>

<p>企业应用（X to
C）的行业准入壁垒高，往往在研发、投市、特别是赢得企业最终订单上的投入，并非一般
start-up
能企及。在美国前景看佳，完全由于美国大公司从来没有“节源”的概念——花的多？那我们挣得更多就是了。</p>

<p>在中国大多数都被国有企业给垄断，所以不是很被看好。</p>

<p>​3. 软硬件结合的小玩具</p>

<p>主要指 API-able
的硬件（模件）搭载简易运算软件的生活用品，很多用品都是一飞冲天，在VC上看来，这类产品是有极高的投资价值的。</p>

<p><strong><em>初创精神的DNA</em></strong></p>

<p>校园最深重又新鲜的记忆来源于是小团体，死党，外加食堂。初创团队也应当打成一片，鱼雷都炸不开，而每个人又因性格、功能的不同，各自作为一个节点向外缘延伸出触角，感知社会和用户的反馈。Felisa
总结出初创团队最常见的三种交际方式：</p>

<p>• 以“盈利”为驱动的纵向交际\
• 以“功能”为纽带的横向交际\
• 以“吃吃喝喝”为纽带的点面交际</p>

<p>国内高压竞争让前两者过分被强调，其实许多成功的合作往往来自于第三项——甚至有时候你们并没有直接的合作或是竞争关系，只是偶然对同一项热点事物感到好奇，饭桌茶几上两三人随口抛出的一组辩证说不定成为日后指导企业发展的要旨。</p>

<p><strong><em>地域分化的疼痛不是交通，是沟通</em></strong></p>

<p>初创生态圈是中心化还是去中心化？这是一个问题。创新工场给出的答案在 Felisa
听来太简单了，面对面比排排坐好，同层办公比上下楼好，
中关村“一锅杂烩”比江浙沪“遍地开花”好，世界是平的比有屋脊和海沟好……问题是，在及时讯息领域如此发达的今天，可以思考为什么沟通障碍的疼痛仍然大于其他所有原因可能带来的高损耗？移动办公还差了些什么？</p>
]]></content>
  </entry>
  
</feed>
