---
layout: post
title: "C++ inline"
date: 2014-02-16 09:18
comments: true
categories: language
tags: [c++, inline]
---

`inline`定义的函数，比起没有`inline`的函数来说，没有执行函数调用所带来的负担，因此它是高效率的；比起宏来，它具有**函数的可预期行为和参数类型检验**。

`inline`对于编译器而言，意味着“在编译阶段，将调用动作以被调用函数的本体替换之”。但是它只是一种建议，编译器可以去做，也可以不去做。从逻辑上来说，编译器将函数`inline`的步骤如下：

1. 将`inline`函数体复制到`inline`函数调用点处；
1. 为所用`inline`函数中的局部变量分配内存；
1. 将`inline`函数的的输入参数和返回值映射到调用方法的局部变量空间中；
1. 如果`inline`函数有多个返回点，将其转变为`inline`函数代码块末尾的分支（使用GOTO）。

`inline`函数的缺点有哪些呢？

1. **代码膨胀。**如果`inline`函数体过大且编译器还让它`inline`成功，那么你最终的程序会代码膨胀，从而造成设备缓冲命中率低，引起较多的页面错误，读写硬盘的次数增多，这样程序的性能就下降了！建议：**`inline`函数体一般不要超过5行，不包括循环，不包括递归调用。**
1. **`inline`函数内部不要有static变量。**`inline`函数的定义几乎总是放在头文件（.h）里，这允许多个实现文件（.cpp）得以引用。我们知道编译器是分别编译的，所以这个时候，在多个实现文件里就会有多个`inline`函数的展开，也就是说有个多个static变量，这恐怕不是我们期望的！
1. **`inline`函数无法随着函数库升级而升级。**如果f是函数库中的一个`inline`函数，使用它的用户会将f函数实体编译到他们的程序中。一旦函数库实现者改变f，所有用到f的程序都必须重新编译。如果f是non-`inline`的，用户程序只需重新连接即可。如果函数库采用的是动态连接，那这一升级的f函数可以不知不觉的被程序使用。
1. **不要获取`inline`函数的地址。**如果要取得一个`inline`函数的地址，编译器就必须为此函数产生一个函数实体，无论如何，编译器无法交出一个“不存在函数”的指针。注意，有些编译器可能会使用类的constructors和destructors的函数指针，用以构造和析构一个class对象的数组。另外类的constructors和destructors可能简单，但是其父类的类的constructors和destructors可能是复杂的，所以**类的constructors和destructors往往不是`inline`函数的最佳选择**！
1. **`inline`虚函数往往是无效的。**虚函数往往是运行时确定的，而`inline`是在编译时进行的，所以`inline`虚函数往往无效。当然如果直接用类的对象来使用虚函数，那么对有的编译器而言，也可起到优化的作用。
1. **`inline`函数无法调试。**原因请参见上面编译器将函数`inline`的步骤。所以请在项目后期，**对程序进行profile后，再决定将那些函数`inline`化。**