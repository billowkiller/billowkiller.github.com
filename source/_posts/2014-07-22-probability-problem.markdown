---
layout: post
title: "Probability Problem"
date: 2014-08-02 02:18
comments: true
categories: algorithm
tags: [algorithm, probability]
---

##一、抛硬币问题

**问题1 有一苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面者吃。问先抛这吃到苹果的概率是多少？**

假设第一个人吃到苹果的概率是P。第一次抛硬币若为正面则先抛者赢；若为负面且后抛者也为负面，则主动权回到先抛者，回到原问题。

得到关系：P = 1/2 + 1/2 * 1/2 * P  

得出 P = 2/3

**问题2 游戏规则为，连续2次抛到硬币朝上，则游戏结束。问平均抛多少次游戏可以结束？**

<!--more-->

平均抛多少次，即是求问题的期望。

首先先抛一枚硬币，如果是花，那么需要重头开始；如果是字，那么再抛一枚硬币，新抛的这枚如果也是字，则游戏结束，如果是花，那么又需要重头开始。根据这个过程，设抛硬币的期望次数为T，可以得到关系：T = 1/2(1 + T) + 1/4 * 2 + 1/4(2 + T)

得出 T = 6 

**问题3 连续抛 k 次朝上的解法：**

假设连续k次正面朝上的期望为Ek，在连续出现k次正面朝上后，下次一也为正面的期望为

E(k+1) = 1/2 (Ek + 1) + 1/2(Ek + 1 + E(k+1))

推到出公式 (E(k+1) +2) /(Ek +2) = 2 得出 Ek = 2^(k+1) -2

**问题4 A和B2人投硬币,正面A得1元,反面B得一元.起始时A有1元,B有100元.游戏持续进行,直到其中1人破产才终止.**

1. 如果硬币正反概率相同,游戏的期待长度(expected duration)是几次投掷?

	目前认为只有奇数次才可能破产。`1*0.5 + 3*0.5^3 + 5*0.5^5+...`

2. 如果硬币是不公正的,正面概率为P,反面概率为Q.(P+Q=1), 那么游戏的期待长度(expectedduration)是几次投掷?

	那么问题的答案是计算E(T(n)),即该事件的期望值。

	第1次出现破产的概率是p  //只可能A破产

	第2次出现            0  //因为A第1次赢了1个，共2个了，最多只能输1个，还会剩1个

	第3次出现            `q×p×p`

	第4次出现            0

	第5次                `q*q*p*p*p`
	
	第99次               q(49次方)×P(50次方)

	--------------------------------------

	在100次以下投掷次数时，不可能是B破产，只有可能是A破产
	
	第100次时            只有B破产可能  即  q（100次方）
	
	第101次              q(50次方)×P(51次方) 
	
	第102次              q(102次方)*p
	
	**综上所述，奇数次时，唯A可能破产，偶数次>=100时，唯B可能破产**。
	
	E（T(n))=`∑ n*T(n)  n=1...+∞`
	        =`∑奇数次  +∑偶数次`
	         =`p/(1-p*q)+q(100次方)/(1-P*q)`
	
	其中q=1-p
	问题1把p=q=1/2 代入即可。

##二、骰子问题

**问题1 一个骰子，6面，1个面是 1， 2个面是2， 3个面是3， 问平均掷多少次能使1,2,3都至少出现一次？**

这是一个求数学期望的问题，最终是求1，2，3出现至少一次的最短长度的期望。

这样分叉树的每个节点是一个期望状态，而每个分叉是一次投掷结果。将后续期望出现1、2、3各至少一次的情形记作L123（即题目所求），将后续期望出现1、2各至少一次（3无关）情形记作L12，而1至少一次（2，3无关）情形L1，其余数值符号类推，则树结构如下（列出4级结构已经足够）：

	           L123
		   /1    |2    \3
	      L23    L13    L12
	   /1  |2  \3 
	  L23  L3   L2
			  /1 |2 \3  
	         L2  P2  L3  

	L123 = p1 (L23+ 1) + p2 (L13+1) + p3 (L12 + 1) = p1*L23 +p2*L13+ p3*L12 + 1
	L23 = p1*L23 +p2*L3+ p3*L2 + 1
	L13 = p1*L3 +p2*L13+ p3*L1 + 1
	L12 = p1*L2 +p2*L1+ p3*L12 + 1
	L1 = p1 + p2*(L1+1) + p3*(L1 +1) =p2*L1+ p3*L1 + 1
	L2 = p1*L2 + p3*L2 + 1
	L3 = p1*L3 + p2*L3 + 1

	解得：
	L1 = 6， L2 = 3， L3 = 2
	L12 = 7， L13 = 13/2， L23 = 19/56
	L123 = 219/30 = 7.3

## 其他

**从n个数中生成m个不重复的随机数**

对于第一个数，可以用概率m/n选取；但是对于下一个，必须考虑之前的数是否被选取而以(m-1)/(n-1)或m/(n-1)的概率选取。

可用下列代码得到结果：

	void random_generate(int n, int m)  
	{  
	    int i=1,t，remain;  
	    while(n-i>m)  
	    {  
	        t = rand()%(n-i);  
	        if(t<m){  
	            printf("%d ",i);  
	            m--;  
	        }  
	        i++;  
	    }  
	    while(++i<=n)printf("%d ",i);  
	}  

**利用等概率Rand互换**

	#Rand5到Rand3
	def Rand3():
	  x = -1
	  while not 0 <= x < 3:
	    x = Rand5()
	  return x

	#Rand5到Rand7
	def Rand7():
	  x = -1
	  while not 0 <= x < 21:
	    x = Rand5() * 5 + Rand5()
	  return x % 7

**单次遍历，等概率随机选取问题**

[http://www.gocalf.com/blog/random-selection.html](http://www.gocalf.com/blog/random-selection.html)

**条件概率：两个都是男孩的概率**

[http://www.gocalf.com/blog/the-probability-of-two-boys.html](http://www.gocalf.com/blog/the-probability-of-two-boys.html)

**平均要取多少个(0,1)中的随机数才能让和超过1**

![](http://hi.csdn.net/attachment/201203/13/0_1331634834uu6L.gif)



