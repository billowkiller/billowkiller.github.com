---
layout: post
title: "最短路径算法"
date: 2013-05-14 01:09
comments: true
categories: [algorithm, shortest path]
---

**单源最短路径**

​1. Dijkstra

 Dijkstra算法解决有向图上带权的单源最短路径问题，要求所有边的权值非负。

用到了顶点的最小优先队列，排序关键字为顶点的d值。即开始出了根为0，其他

顶点为正无穷，后来d值根据松弛算法变化。

总计运行时间为O((V+E)lgV)，如果所有顶点都可达的话，则为O(ElgV)。

 

​2. Bellman-ford

算法用来解决一般，即边的权值可以为负的单源最短路径问题。算法同时也可以检查

是否有从源点可达的负权回路。

算法的运行时间为O(VE)。

 <!--more-->

在Dijkstra算法以及关于有向无回路图的最短路径算法中，对每条边执行一次松弛操作。

在Bellman-Ford算法中，对每条边要执行多次松弛操作。

 

**每对顶点间的最短路径**

​1. Floyd-Wallshall

属于动态规划方案，允许存在权值为负的边，但不存在权值为负的回路。

算法考虑最短路径上的中间顶点，自底向上利用中间顶点K值递增的顺序计算权值

利用的递归式为

*D~i,j,k~ = min(D~i,k,k −\\ 1~ + D~k,j,k −\\ 1~,D~i,j,k −\\ 1~)　　K \>=
1*

*　　　= W~i,j~                                 　　　　  K = 0*

*\
*算法运行时间为Φ(n^3^)。

利用Floyd算法可以计算出有向图的传递闭包，即确定对所有顶点对，图中是否都存在一条

从 i 到 j 的路径。

用相应的逻辑运算或和并来替换 min 和 + 用以增加运算速度。

 

​2. 稀疏图上的Johnson算法

对于稀疏图改算法在渐进意义上要好于矩阵的重复平方或Floyd-Wallshall算法。

Johnson算法吧Dijkstra算法和Bellman-Ford算法作为其的子程序。

通过重新赋权值保持最短路径和产生非负的权。

若采用斐波那契堆来实现Dijkstra算法的最小优先队列则运算时间是

O(V^2^lgV + VE)。更简单的二叉堆实现，则可以得到O(VElgV)的运行时间。
