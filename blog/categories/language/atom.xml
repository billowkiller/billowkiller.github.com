<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: language | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/categories/language/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2014-07-25T21:14:45+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ string copy-on-write]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/12/c%2B%2B-string-copy-on-write/"/>
    <updated>2014-07-12T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/12/c++-string-copy-on-write</id>
    <content type="html"><![CDATA[<p>不同版本的C++ string实现时不同的，sizeof(string)得出来的结果也不尽相同，其中有种实现采用copy-on-write的方式来共享内存。</p>

<p>引用计数就是string类中写时才拷贝的原理！当第一个类构造时，string的构造函数会根据 传入的参数从堆上分配内存，当有其它类需要这块内存时，这个计数为自动累加，当有类析构时，这个计数会减一，直到最后一个类析构时，此时的RefCnt为1或是0，此时，程序才会真正的Free这块从堆上分配的内存。</p>

<p>string类的内存是在堆上动态分配的，共享内存的各个类指向的是同一个内存区。这块内存区域还包括引用计数，其位于字符串内存区域的上方，通过<code>_Ptr[-1]</code>来访问。这样所有共享这块内存的类都可以访问到引用计数，也就知道这块内存的引用者有多少了。</p>

<p>于是，有了这样一个机制，每当我们为string分配内存时，我们总是要多分配一个空间用来存放这个引用计数的值，只要发生拷贝构造可是赋值时，这个内存的值就会加一。而在内容修改时，string类为查看这个引用计数是否为0，如果不为零，表示有人在共享这块内存，那么自己需要先做一份拷贝，然后把引用计数减去一，再把数据拷贝过来。</p>

<!--more-->
<p>具体做法如下：</p>

<pre><code>//构造函数（分存内存）
string::string(const char* tmp)
{
	_Len = strlen(tmp);
	_Ptr = new char[_Len+1+1];
	strcpy( _Ptr, tmp );
	_Ptr[-1]=0;  // 设置引用计数  
}

//拷贝构造（共享内存）
string::string(const string&amp; str)
{
	if (*this != str){
	this-&gt;_Ptr = str.c_str();   //共享内存
	this-&gt;_Len = str.szie();
	this-&gt;_Ptr[-1] ++;  //引用计数加一
}

//写时才拷贝Copy-On-Write
char&amp; string::operator[](unsigned int idx)
{
	if (idx &gt; _Len || _Ptr == 0 ) {
		static char nullchar = 0;
		return nullchar;
	}

	_Ptr[-1]--;   //引用计数减一
	char* tmp = new char[_Len+1+1];
	strncpy( tmp, _Ptr, _Len+1);
	_Ptr = tmp;
	_Ptr[-1]=0; // 设置新的共享内存的引用计数
	
	return _Ptr[idx];
}


//析构函数的一些处理
~string()
{ 
	_Ptr[_Len+1]--;   //引用计数减一
	// 引用计数为0时，释放内存
	if (_Ptr[_Len+1]==0) {
		delete[] _Ptr;
	}
}
</code></pre>

<p>但这样的方式也会造成一些麻烦。容易造成内存访问异常。
<strong>两个例子：</strong></p>

<h3 id="section">动态库</h3>
<p>动态链接库中有一个函数返回string类：</p>

<pre><code>string GetIPAddress(string hostname)
{
	static string ip;
	……
	return ip;
}
</code></pre>

<p>主程序中动态地载入这个动态链接库，并调用其中的这个函数：</p>

<pre><code>main()
{
	//载入动态链接库中的函数
	void(*pTest)();
	void*pdlHandle = dlopen("libtest.so", RTLD_LAZY);   
	pTest = dlsym(pdlHandle, "GetIPAddress");
	//调用动态链接库中的函数
	string ip = (*pTest)(“host1”);
	……
	//释放动态链接库
	 dlclose(pdlHandle);
	……
	cout &lt;&lt; ip &lt;&lt; endl;
}
</code></pre>

<p>当主程序释放了动态链接库后，那个共享的内存区也随之释放。所以，以后对ip的访问，必然做造成内存地址访问非法，造成程序crash。即使你在以后没有使用到ip这个变量，那么在主程序退出时也会发生内存访问异常，因为程序退出时，ip会析构，在析构时就会发生内存访问异常。</p>

<h3 id="section-1">多线程</h3>

<p>在多线程中，对于多线程来说，引用计数就是一个全局变量。指向同一个buffer的多个string的引用计数有可能变得混乱，从而导致delete异常。尤其是在.h中定义const string A = “XXXX”， 如果多个对象都引用了A，则可能在多线程中出现问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[deep C and C++]]></title>
    <link href="http://billowkiller.github.io/blog/2013/10/12/deep-c-and-c-plus-plus/"/>
    <updated>2013-10-12T16:12:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/10/12/deep-c-and-c-plus-plus</id>
    <content type="html"><![CDATA[<p>摘自<a href="http://share.csdn.net/#/detail/1050">CSDN Share</a></p>

<p>花了一个上午的时间看了下这个PPT，觉得收获颇多。
特别是这个PPT的组织方式，采用两个程序员面试对比的方式，非常的实用，也很有触动和感悟。已经很久没见到这样精彩的PPT了。</p>

<p>本PPT介绍了作为普通的程序员和高级的程序员如何看待C与C++，从编译、链接、运行的角度来介绍，有非常多的干货，也许不是很系统，但确实是非常的实用；特别是在回答面试官的提问上，需要认真思考，从<code>不同的角度</code>、<code>深层次</code>地回答技术官的问话。也许两个程序员的功力差不多，但是在回答技术问题的方法上也许对面试官有很大的影响，最终也就是面试是否成功的关键。</p>

<p><img src="http://www.atmel.com/zh/cn/Images/compiler.jpg" alt="" /></p>

<!--more-->

<p>有一点提示就是，今后在看书的时候，要时常记住一些<code>RULE</code>，语言中更有效的惯用用法(<code>effective conventional language</code>)，特别是深入底层细节的知识，要不断的积累实证，而且得<code>学以致用</code>。一点点细小的差距就是<code>professional programmer</code>与common programmer的区别。最重要的一点是常看优秀的代码，学习与你知识相违背的用例。</p>

<p>&lt;iframe height=620 width=670 scrolling=”no” src=”http://share.csdn.net/#/frame/1050” frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;</p>

<p>截取几张精彩的ppt</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/2_zpsde979321.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/_zpsfe2bfd71.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/3_zpsc78ac177.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/5_zps28849be2.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/4_zpsff862edf.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python特殊语法：filter、map、reduce、lambda [转]]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/pythonte-shu-yu-fa-filter-map-reduce-lambda-zhuan/"/>
    <updated>2013-05-14T01:09:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/pythonte-shu-yu-fa-filter-map-reduce-lambda-zhuan</id>
    <content type="html"><![CDATA[<p><i><strong>from</strong> <a href="http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html">http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html</a></i></p>

<hr />

<p>Python内置了一些非常有趣但非常有用的函数，充分体现了Python的语言魅力！</p>

<p><strong>filter(function,
sequence)</strong> ：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回：</p>

<p>&gt;&gt;&gt; def f(x): return x % 2 != 0 and x % 3 != 0 </p>

<p>&gt;&gt;&gt; filter(f, range(2, 25)) 
[5, 7, 11, 13, 17, 19, 23]</p>

<p>&gt;&gt;&gt; def f(x): return x != ‘a’ </p>

<p>&gt;&gt;&gt; filter(f, “abcdef”) </p>

<p>‘bcdef’</p>

<p><strong>map(function,
sequence)</strong> ：对sequence中的item依次执行function(item)，见执行结果组成一个List返回：</p>

<p>&gt;&gt;&gt; def cube(x): return x<em>x</em>x </p>

<p>&gt;&gt;&gt; map(cube, range(1, 11)) </p>

<p>[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</p>

<p>&gt;&gt;&gt; def cube(x) : return x + x </p>

<p>… </p>

<p>&gt;&gt;&gt; map(cube , “abcde”) </p>

<p>[‘aa’, ‘bb’, ‘cc’, ‘dd’, ‘ee’]</p>

<p>另外map也支持多个sequence，这就要求function也支持相应数量的参数输入：
&gt;&gt;&gt; def add(x, y): return x+y </p>

<p>&gt;&gt;&gt; map(add, range(8), range(8))</p>

<p>[0, 2, 4, 6, 8, 10, 12, 14]</p>

<!--more-->

<p><strong>reduce(function, sequence,
starting_value)</strong>：对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：</p>

<p>&gt;&gt;&gt; def add(x,y): return x + y </p>

<p>&gt;&gt;&gt; reduce(add, range(1, 11)) </p>

<p>55 （注：1+2+3+4+5+6+7+8+9+10）</p>

<p>&gt;&gt;&gt; reduce(add, range(1, 11), 20) </p>

<p>75 （注：1+2+3+4+5+6+7+8+9+10+20）</p>

<p><strong>lambda</strong>：这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数，是从LISP借用来的，可以用在任何需要函数的地方： </p>

<p>&gt;&gt;&gt; g = lambda x: x * 2 </p>

<p>&gt;&gt;&gt; g(3) </p>

<p>6 </p>

<p>&gt;&gt;&gt; (lambda x: x * 2)(3) </p>

<p>6</p>

<p>我们也可以<strong>把filter map reduce
和lambda结合起来</strong>用，函数就可以简单的写成一行。</p>

<p>例如</p>

<p>kmpathes = filter(lambda kmpath: kmpath,                <br />
map(lambda kmpath: string.strip(kmpath),
string.split(l, ‘:’)))   </p>

<p>看起来麻烦，其实就像用语言来描述问题一样，非常优雅。
对 l
中的所有元素以’:’做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被’:’分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。</p>

<p>[转] <a href="http://hi.baidu.com/black/item/307001d18715fc322a35c747">http://hi.baidu.com/black/item/307001d18715fc322a35c747</a></p>

<hr />

<p><strong>lambda表达式</strong>返回一个函数对象</p>

<p>例子：</p>

<pre><code>func = lambda x,y:x+y
</code></pre>

<p>func相当于下面这个函数</p>

<pre><code>def func(x,y):
    return x+y
</code></pre>

<p>注意def是语句而lambda是表达式</p>

<p>下面这种情况下就只能用lambda而不能用def</p>

<pre><code>[(lambda x:x*x)(x) for x in range(1,11)]
</code></pre>

<p>map，reduce，filter中的function都可以用lambda表达式来生成！</p>

<p><strong>map(function,sequence)</strong></p>

<p>把sequence中的值当参数逐个传给function，返回一个包含函数执行结果的list。</p>

<p>如果function有两个参数，即
map(function,sequence1,sequence2)。</p>

<p>例子：</p>

<p>求1<em>1,2</em>2,3<em>3,4</em>4</p>

<pre><code>map(lambda x:x*x,range(1,5))
</code></pre>

<p>返回值是[1,4,9,16]</p>

<p><strong>reduce(function,sequence)</strong></p>

<p>function接收的参数个数只能为2</p>

<p>先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给</p>

<p>function，然后只返回一个结果。</p>

<p>例子：</p>

<p>求1到10的累加</p>

<pre><code>reduce(lambda x,y:x+y,range(1,11))
</code></pre>

<p>返回值是55。</p>

<p><strong>filter(function,sequence)</strong></p>

<p>function的返回值只能是True或False</p>

<p>把sequence中的值逐个当参数传给function，如果function(x)的返回值是True，就把x加到filter的返回值里面。一般来说filter的返回值是list，特殊情况如sequence是string或tuple，则返回值按照sequence的类型。</p>

<p>例子：</p>

<p>找出1到10之间的奇数</p>

<pre><code>filter(lambda x:x%2!=0,range(1,11))
</code></pre>

<p>返回值</p>

<p>[1,3,5,7,9]</p>

<p>如果sequence是一个string</p>

<pre><code>filter(lambda x:len(x)!=0,'hello')
</code></pre>

<p>返回’hello’</p>

<pre><code>filter(lambda x:len(x)==0,'hello')
</code></pre>

<p>返回’’</p>

<p>[转] <a href="http://blog.csdn.net/myzhan/article/details/7269471">http://blog.csdn.net/myzhan/article/details/7269471</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python dict sorted]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/13/python-dict-sorted/"/>
    <updated>2013-05-13T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/13/python-dict-sorted</id>
    <content type="html"><![CDATA[<p><i><strong>from</strong> <a href="http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html">http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html</a></i></p>

<hr />

<p>我们知道Python的内置dictionary数据类型是无序的，通过key来获取对应的value。可是有时我们需要对dictionary中
的item进行排序输出，可能根据key，也可能根据value来排。到底有多少种方法可以实现对dictionary的内容进行排序输出呢？下面摘取了
一些精彩的解决办法。 </p>

<!--more-->

<p>#最简单的方法，这个是按照key值排序： </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">sortedDictValues1</span><span class="p">(</span><span class="n">adict</span><span class="p">):</span>
</span><span class='line'>    <span class="n">items</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
</span><span class='line'>    <span class="n">items</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#又一个按照key值排序，貌似比上一个速度要快点 </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">sortedDictValues2</span><span class="p">(</span><span class="n">adict</span><span class="p">):</span>
</span><span class='line'>    <span class="n">keys</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</span><span class='line'>    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#还是按key值排序，据说更快。。。而且当key为tuple的时候照样适用 </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">sortedDictValues3</span><span class="p">(</span><span class="n">adict</span><span class="p">):</span>
</span><span class='line'>    <span class="n">keys</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</span><span class='line'>    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#一行语句搞定： </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">di</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#来一个根据value排序的，先把item的key和value交换位置放入一个list中，再根据list每个元素的第一个值，即原来的value值，排序： </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">sort_by_value</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
</span><span class='line'>    <span class="n">items</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
</span><span class='line'>    <span class="n">backitems</span><span class="o">=</span><span class="p">[[</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
</span><span class='line'>    <span class="n">backitems</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span> <span class="n">backitems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">backitems</span><span class="p">))]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#还是一行搞定： </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="p">[</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#用lambda表达式来排序，更灵活： </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>, 或反序： 
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>#用sorted函数的key= 参数排序： 
# 按照key进行排序 </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p># 按照value进行排序 </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面给出python内置sorted函数的帮助文档： </p>

<p>sorted(…) </p>

<p>sorted(iterable, cmp=None, key=None, reverse=False) –&gt; new sorted
list </p>

<p>看了上面这么多种对dictionary排序的方法，其实它们的核心思想都一样，即把dictionary中的元素分离出来放到一个list中，对list排序，从而间接实现对dictionary的排序。这个“元素”可以是key，value或者item。 </p>

<p>#################################################################################</p>

<p>一上转 </p>

<p>按照value排序可以用 </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>若版本低不支持sorted </p>

<p>将key,value 以tuple一起放在一个list中 </p>

<p>l = [] </p>

<p>l.append((akey,avalue))… </p>

<p>用sort（） </p>

<p>l.sort(lambda a,b :cmp(a[1],b[1]))(cmp前加“-”表示降序排序)</p>

]]></content>
  </entry>
  
</feed>
