<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: language | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/categories/language/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2014-08-13T15:46:44+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Template]]></title>
    <link href="http://billowkiller.github.io/blog/2014/04/23/Template-in-C%2B%2B/"/>
    <updated>2014-04-23T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/04/23/Template-in-C++</id>
    <content type="html"><![CDATA[<p>modified from <a href="http://www.cnblogs.com/assemble8086/archive/2011/10/02/2198308.html">http://www.cnblogs.com/assemble8086/archive/2011/10/02/2198308.html</a></p>

<h2 id="section">模版</h2>

<p><code>template</code> 是声明类模板的关键字，表示声明一个模板，模板参数可以是一个，也可以是多个，可以是<strong>类型参数</strong> ，也可以是<strong>非类型参数</strong>。类型参数由关键字<code>class</code>或<code>typename</code>及其后面的标识符构成。非类型参数由一个普通参数构成，代表模板定义中的一个常量。</p>

<p><strong>类模板什么时候会被实例化呢？</strong></p>

<ol>
  <li>当使用了类模板实例的名字，并且上下文环境要求存在类的定义时。</li>
  <li>对象类型是一个类模板实例，当对象被定义时。此点被称作类的实例化点。</li>
  <li>一个指针或引用指向一个类模板实例，当检查这个指针或引用所指的对象时。</li>
</ol>

<!--more-->

<p><strong>非类型参数的模板实参</strong></p>

<ol>
  <li>绑定给非类型参数的表达式必须是一个常量表达式。</li>
  <li>从模板实参到非类型模板参数的类型之间允许进行一些转换。包括左值转换、限定修饰转换、提升、整值转换。</li>
  <li>
    <p>可以被用于非类型模板参数的模板实参的种类有一些限制。</p>

    <pre><code> Template&lt;int* ptr&gt; class Graphics{…….};
	
 Template&lt;class Type,int size&gt; class Rect{……..};
	
 const int size=1024;
	
 Graphics&lt;&amp;size&gt; bp1;//错误:从const int*－&gt;int*是错误的。
	
 Graphics&lt;0&gt; bp2;//错误不能通过隐式转换把０转换成指针值
	
 const double db=3.1415;
	
 Rect&lt;double,db&gt; fa1;//错误：不能将const double转换成int.
	
 unsigned int fasize=255;
	
 Rect&lt;String, fasize&gt; fa2;//错误：非类型参数的实参必须是常量表达式，将unsigned改为const就正确。
	
 Int arr[10];
	
 Graphics&lt;arr&gt; gp;//正确
</code></pre>
  </li>
</ol>

<p><strong>类模板的成员函数</strong></p>

<ol>
  <li>类模板的成员函数可以在类模板的定义中定义(<code>inline</code>函数)，也可以在类模板定义之外定义(此时成员函数定义前面必须加上<code>template</code>及模板参数)。</li>
  <li>
    <p>类模板成员函数本身也是一个模板，类模板被实例化时它并不自动被实例化，只有当它被调用或取地址，才被实例化。</p>

    <pre><code> template&lt;class type&gt;
 Class Graphics{
     Graphics(){…}//成员函数定义在类模板的定义中
     void out();
 };
	
 template&lt;class type&gt;//成员函数定义在类模板定义之外
 void Graphics&lt;type&gt;::out(){…}
</code></pre>
  </li>
</ol>

<p><strong>类模板的友元声明</strong></p>

<ol>
  <li>非模板友元类或友元函数</li>
  <li>
    <p>绑定的友元类模板或函数模板。</p>

    <pre><code> template&lt;class type&gt;
 void create(Graphics&lt;type&gt;);
	
 template&lt;class type&gt;
 class Graphics{
     friend void create&lt;type&gt;(Graphics&lt;type&gt;);
 };
</code></pre>
  </li>
  <li>
    <p>非绑定的友元模板</p>

    <pre><code> template&lt;class type&gt;
 class Graphics{
     template&lt;class T&gt;
     friend void create(Graphics&lt;T&gt;);
 };
</code></pre>
  </li>
</ol>

<p><strong>注意：</strong>当把非模板类或函数声明为类模板友元时，它们不必在全局域中被声明或定义，但将一个类的成员声明为类模板友元，该类必须已经被定义，另外在声明绑定的友元类模板或函数模板时，该模板也必须先声明。</p>

<p><strong>类模板的静态数据成员</strong></p>

<ol>
  <li>静态数据成员的模板定义必须出现在类模板定义之外。</li>
  <li>类模板静态数据成员本身就是一个模板，它的定义不会引起内存被分配，只有对其实例化才会分配内存。</li>
  <li>当程序使用静态数据成员时，它被实例化，每个静态成员实例都与一个类模板实例相对应，静态成员的实例引用要通过一个类模板实例。</li>
</ol>

<p><strong>成员模板</strong></p>

<ol>
  <li>在一个类模板中定义一个成员模板,意味着该类模板的一个实例包含了可能无限多个嵌套类和无限多个成员函数．</li>
  <li>只有当成员模板被使用时，它才被实例化.</li>
  <li>成员模板可以定义在其外围类或类模板定义之外．</li>
</ol>

<p><strong>类模板的编译模式</strong></p>

<ol>
  <li>
    <p>包含编译模式</p>

    <p>这种编译模式下，类模板的成员函数和静态成员的定义必须被包含在“要将它们实例化”的所有文件中，如果一个成员函数被定义在类模板定义之外，那么这些定义应该被放在含有该类模板定义的头文件中。</p>
  </li>
  <li>
    <p>分离编译模式</p>

    <p>这种模式下，类模板定义和其inline成员函数定义被放在头文件中，而非inline成员函数和静态数据成员被放在程序文本文件中。</p>

    <pre><code> //------Graphics.h---------
	
 export template&lt;class type&gt;
 Class Graphics
 {void Setup(const type &amp;);};
	
 //-------Graphics.c------------
	
 #include “Graphics.h”
 Template &lt;class type&gt;
 Void Graphics&lt;type&gt;::Setup(const type &amp;){…}
	
 //------user.c-----
	
 #include “Graphics.h”
 Void main(){
     Graphics&lt;int&gt; *pg=new Graphics&lt;int&gt;;
     Int ival=1;
     //Graphics&lt;int&gt;::Setup(const int &amp;)的实例（下有注解）
     Pg-&gt;Setup(ival);
 }
</code></pre>

    <p>Setup的成员定义在User.c中不可见,但在这个文件中仍可调用模板实例Graphics<int>::Setup(const int &amp;)。为实现这一点，须将类模声明为可导出的：**当它的成员函数实例或静态数据成员实例被使用时，编译器只要求模板的定义，它的声明方式是在关键字template前加关键字export**</int></p>
  </li>
  <li>
    <p>显式实例声明</p>

    <p>当使用包含编译模式时，类模板成员的定义被包含在使用其实例的所有程序文本文件中，何时何地编译器实例化类模板成员的定义，我们并不能精确地知晓，为解决这个问题，标准C++提供了显式实例声明：关键字template后面跟着关键字class以及类模板实例的名字。<strong>显式实例化类模板时，它的所有成员也被显式实例化</strong>。</p>

    <pre><code> #include “Graphics.h”
 Template class Graphics&lt;int&gt;;//显式实例声明
</code></pre>
  </li>
</ol>

<p><strong>类模板的特化</strong></p>

<p><code>template&lt;&gt;</code>成员函数特化定义</p>

<ol>
  <li>只有当通用类模板被声明后，它的显式特化才可以被定义。</li>
  <li>若定义了一个类模板特化，则必须定义与这个特化相关的所有成员函数或静态数据成员，此时类模板特化的成员定义不能以符号<code>template&lt;&gt;</code>作为打头。(<code>template&lt;&gt;</code>被省略)</li>
  <li>类模板不能够在某些文件中根据通用模板定义被实例化，而在其他文件中却针对同一组模板实参被特化。</li>
</ol>

<p><strong>类模板部分特化</strong></p>

<p>如果模板有一个以上的模板参数，则有些人就可能希望为一个特定的模板实参或者一组模板实参特化类模板，而不是为所有的模板参数特化该类模板。即，希望提供这样一个模板：它仍然是一个通用的模板，只不过某些模板参数已经被实际的类型或值取代。通过使用类模板部分特化，可以实现这一点。</p>

<pre><code>template&lt;int hi,int wid&gt;
Class Graphics{…};

Template&lt;int hi&gt;//类模板的部分特化
Class Graphics&lt;hi,90&gt;{…};
</code></pre>

<ol>
  <li>部分特化的模板参数表只列出模板实参仍然未知的那些参数。</li>
  <li>类模板部分特化是被隐式实例化的。编译器选择“针对该实例而言最为特化的模板定义”进行实例化，当没有特化可被使用时，才使用通用模板定义。</li>
  <li>类模板部分特化必须有它自己对成员函数、静态数据成员和嵌套类的定义。</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C/C++ Byte Alignment]]></title>
    <link href="http://billowkiller.github.io/blog/2014/04/22/byte-alignment/"/>
    <updated>2014-04-22T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/04/22/byte-alignment</id>
    <content type="html"><![CDATA[<p><strong>字节对齐的细节和编译器实现相关，但一般而言，满足三个准则</strong>：</p>

<ol>
  <li>结构体变量的首地址能够被其<strong>最宽基本类型</strong>成员的大小所整除；</li>
  <li>结构体每个成员相对于结构体首地址的偏移量（offset）都是<strong>成员大小的整数倍</strong>，如有需要编译器会在成员之间加上填充字节（internal adding）；</li>
  <li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</li>
</ol>

<p>需要仔细体会上面的三个准则。</p>

<!--more-->

<ul>
  <li>
    <p>结构体某个成员相对于结构体首地址的偏移量可以通过宏offsetof()来获得，这个宏也在stddef.h中定义，如下：</p>

    <pre><code>  #define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m)
</code></pre>
  </li>
  <li>
    <p>基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型。这里所说的“数据宽度”就是指其sizeof的大小。由于结构体的成员可以是复合类型，比如另外一个结构体，所以在寻找最宽基本类型成员时，应当包括复合类型成员的子成员，而不是把复合成员看成是一个整体。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。</p>

    <pre><code>  struct S1
  {
      char c;
      int i;
  };

  struct S3
  {
      char c1;
      S1 s;
      char c2;
  };
</code></pre>

    <p>S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，所以S3的最宽简单类型为int。这样，通过S3定义的变量，其存储空间首地址需要被4整除，整个sizeof(S3)的值也应该被4整除。</p>

    <p>c1的偏移量为0，s的偏移量呢？这时s是一个整体，它作为结构体变量也满足前面三个准则，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需要了，所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补上3个填充字节。最后得到sizeof(S3)的值为16。</p>
  </li>
</ul>

<h2 id="pragma-pack"><code> #pragma pack</code></h2>

<p><code>#pragma pack</code>规定的对齐长度，实际使用的规则是：</p>

<p>结构，联合，或者类的数据成员，第一个放在偏移为0的地方，以后每个数据成员的对齐，按照<code>#pragma pack</code>指定的数值和这个数据成员自身长度中，比较小的那个进行。也就是说，当<code>#pragma pack</code>的值等于或超过所有数据成员长度的时候，这个值的大小将不产生任何效果。而结构整体的对齐，则按照结构体中最大的数据成员和<code>#pragma pack</code>指定值之间，较小的那个进行。</p>

<pre><code>   #pragma pack(4)
　　class TestB
　　{
　　public:
　　　　int aa; //第一个成员，放在[0,3]偏移的位置，
　　　　char a; //第二个成员，自身长为1，#pragma pack(4),取小值，也就是1，所以
这个成员按一字节对齐，放在偏移[4]的位置。
　　　　short b; //第三个成员，自身长2，#pragma pack(4)，取2，按2字节对齐，所以
放在偏移[6,7]的位置。
　　　　char c; //第四个，自身长为1，放在[8]的位置。
　　};
</code></pre>

<p>这个类实际占据的内存空间是9字节类之间的对齐，是按照类内部最大的成员的长度，和<code>#pragma pack</code>规定的值之中较小的一个对齐的。所以这个例子中，类之间对齐的长度是<code>min(sizeof(int),4)</code>，也就是4。9按照4字节圆整的结果是12，所以<code>sizeof(TestB)</code>是12。</p>

<pre><code>	#pragma pack(2)
    class TestB
　　{
　　public:
　　　　int aa; //第一个成员，放在[0,3]偏移的位置，
　　　　char a; //第二个成员，自身长为1，#pragma pack(4),取小值，也就是1，所以
这个成员按一字节对齐，放在偏移[4]的位置。
　　　　short b; //第三个成员，自身长2，#pragma pack(4)，取2，按2字节对齐，所以
放在偏移[6,7]的位置。
　　　　char c; //第四个，自身长为1，放在[8]的位置。
　　};
</code></pre>

<p>可以看出，上面的位置完全没有变化，只是类之间改为按2字节对齐，9按2圆整的结果是10。所以<code>sizeof(TestB)</code>是10。</p>

<pre><code>	#pragma pack(4)
　　class TestC
　　{
　　public:
　　　　char a;//第一个成员，放在[0]偏移的位置，
　　　　short b;//第二个成员，自身长2，#pragma pack(4)，取2，按2字节对齐，所以
放在偏移[2,3]的位置。
　　　　char c;//第三个，自身长为1，放在[4]的位置。
　　};
</code></pre>

<p>整个类的大小是5字节，按照<code>min(sizeof(short),4)</code>字节对齐，也就是2字节对齐，结果是6</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ string copy-on-write]]></title>
    <link href="http://billowkiller.github.io/blog/2014/03/12/c%2B%2B-string-copy-on-write/"/>
    <updated>2014-03-12T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/03/12/c++-string-copy-on-write</id>
    <content type="html"><![CDATA[<p>不同版本的C++ string实现时不同的，sizeof(string)得出来的结果也不尽相同，其中有种实现采用copy-on-write的方式来共享内存。</p>

<p>引用计数就是string类中写时才拷贝的原理！当第一个类构造时，string的构造函数会根据 传入的参数从堆上分配内存，当有其它类需要这块内存时，这个计数为自动累加，当有类析构时，这个计数会减一，直到最后一个类析构时，此时的RefCnt为1或是0，此时，程序才会真正的Free这块从堆上分配的内存。</p>

<p>string类的内存是在堆上动态分配的，共享内存的各个类指向的是同一个内存区。这块内存区域还包括引用计数，其位于字符串内存区域的上方，通过<code>_Ptr[-1]</code>来访问。这样所有共享这块内存的类都可以访问到引用计数，也就知道这块内存的引用者有多少了。</p>

<p>于是，有了这样一个机制，每当我们为string分配内存时，我们总是要多分配一个空间用来存放这个引用计数的值，只要发生拷贝构造可是赋值时，这个内存的值就会加一。而在内容修改时，string类为查看这个引用计数是否为0，如果不为零，表示有人在共享这块内存，那么自己需要先做一份拷贝，然后把引用计数减去一，再把数据拷贝过来。</p>

<!--more-->
<p>具体做法如下：</p>

<pre><code>//构造函数（分存内存）
string::string(const char* tmp)
{
	_Len = strlen(tmp);
	_Ptr = new char[_Len+1+1];
	strcpy( _Ptr, tmp );
	_Ptr[-1]=0;  // 设置引用计数  
}

//拷贝构造（共享内存）
string::string(const string&amp; str)
{
	if (*this != str){
	this-&gt;_Ptr = str.c_str();   //共享内存
	this-&gt;_Len = str.szie();
	this-&gt;_Ptr[-1] ++;  //引用计数加一
}

//写时才拷贝Copy-On-Write
char&amp; string::operator[](unsigned int idx)
{
	if (idx &gt; _Len || _Ptr == 0 ) {
		static char nullchar = 0;
		return nullchar;
	}

	_Ptr[-1]--;   //引用计数减一
	char* tmp = new char[_Len+1+1];
	strncpy( tmp, _Ptr, _Len+1);
	_Ptr = tmp;
	_Ptr[-1]=0; // 设置新的共享内存的引用计数
	
	return _Ptr[idx];
}


//析构函数的一些处理
~string()
{ 
	_Ptr[_Len+1]--;   //引用计数减一
	// 引用计数为0时，释放内存
	if (_Ptr[_Len+1]==0) {
		delete[] _Ptr;
	}
}
</code></pre>

<p>但这样的方式也会造成一些麻烦。容易造成内存访问异常。
<strong>两个例子：</strong></p>

<h3 id="section">动态库</h3>
<p>动态链接库中有一个函数返回string类：</p>

<pre><code>string GetIPAddress(string hostname)
{
	static string ip;
	……
	return ip;
}
</code></pre>

<p>主程序中动态地载入这个动态链接库，并调用其中的这个函数：</p>

<pre><code>main()
{
	//载入动态链接库中的函数
	void(*pTest)();
	void*pdlHandle = dlopen("libtest.so", RTLD_LAZY);   
	pTest = dlsym(pdlHandle, "GetIPAddress");
	//调用动态链接库中的函数
	string ip = (*pTest)(“host1”);
	……
	//释放动态链接库
	 dlclose(pdlHandle);
	……
	cout &lt;&lt; ip &lt;&lt; endl;
}
</code></pre>

<p>当主程序释放了动态链接库后，那个共享的内存区也随之释放。所以，以后对ip的访问，必然做造成内存地址访问非法，造成程序crash。即使你在以后没有使用到ip这个变量，那么在主程序退出时也会发生内存访问异常，因为程序退出时，ip会析构，在析构时就会发生内存访问异常。</p>

<h3 id="section-1">多线程</h3>

<p>在多线程中，对于多线程来说，引用计数就是一个全局变量。指向同一个buffer的多个string的引用计数有可能变得混乱，从而导致delete异常。尤其是在.h中定义const string A = “XXXX”， 如果多个对象都引用了A，则可能在多线程中出现问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ inline]]></title>
    <link href="http://billowkiller.github.io/blog/2014/02/16/c%2B%2B-inline/"/>
    <updated>2014-02-16T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/02/16/c++-inline</id>
    <content type="html"><![CDATA[<p><code>inline</code>定义的函数，比起没有<code>inline</code>的函数来说，没有执行函数调用所带来的负担，因此它是高效率的；比起宏来，它具有<strong>函数的可预期行为和参数类型检验</strong>。</p>

<p><code>inline</code>对于编译器而言，意味着“在编译阶段，将调用动作以被调用函数的本体替换之”。但是它只是一种建议，编译器可以去做，也可以不去做。从逻辑上来说，编译器将函数<code>inline</code>的步骤如下：</p>

<ol>
  <li>将<code>inline</code>函数体复制到<code>inline</code>函数调用点处；</li>
  <li>为所用<code>inline</code>函数中的局部变量分配内存；</li>
  <li>将<code>inline</code>函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
  <li>如果<code>inline</code>函数有多个返回点，将其转变为<code>inline</code>函数代码块末尾的分支（使用GOTO）。</li>
</ol>

<p><code>inline</code>函数的缺点有哪些呢？</p>

<ol>
  <li><strong>代码膨胀。</strong>如果<code>inline</code>函数体过大且编译器还让它<code>inline</code>成功，那么你最终的程序会代码膨胀，从而造成设备缓冲命中率低，引起较多的页面错误，读写硬盘的次数增多，这样程序的性能就下降了！建议：<strong><code>inline</code>函数体一般不要超过5行，不包括循环，不包括递归调用。</strong></li>
  <li><strong><code>inline</code>函数内部不要有static变量。</strong><code>inline</code>函数的定义几乎总是放在头文件（.h）里，这允许多个实现文件（.cpp）得以引用。我们知道编译器是分别编译的，所以这个时候，在多个实现文件里就会有多个<code>inline</code>函数的展开，也就是说有个多个static变量，这恐怕不是我们期望的！</li>
  <li><strong><code>inline</code>函数无法随着函数库升级而升级。</strong>如果f是函数库中的一个<code>inline</code>函数，使用它的用户会将f函数实体编译到他们的程序中。一旦函数库实现者改变f，所有用到f的程序都必须重新编译。如果f是non-<code>inline</code>的，用户程序只需重新连接即可。如果函数库采用的是动态连接，那这一升级的f函数可以不知不觉的被程序使用。</li>
  <li><strong>不要获取<code>inline</code>函数的地址。</strong>如果要取得一个<code>inline</code>函数的地址，编译器就必须为此函数产生一个函数实体，无论如何，编译器无法交出一个“不存在函数”的指针。注意，有些编译器可能会使用类的constructors和destructors的函数指针，用以构造和析构一个class对象的数组。另外类的constructors和destructors可能简单，但是其父类的类的constructors和destructors可能是复杂的，所以<strong>类的constructors和destructors往往不是<code>inline</code>函数的最佳选择</strong>！</li>
  <li><strong><code>inline</code>虚函数往往是无效的。</strong>虚函数往往是运行时确定的，而<code>inline</code>是在编译时进行的，所以<code>inline</code>虚函数往往无效。当然如果直接用类的对象来使用虚函数，那么对有的编译器而言，也可起到优化的作用。</li>
  <li><strong><code>inline</code>函数无法调试。</strong>原因请参见上面编译器将函数<code>inline</code>的步骤。所以请在项目后期，<strong>对程序进行profile后，再决定将那些函数<code>inline</code>化。</strong></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[deep C and C++]]></title>
    <link href="http://billowkiller.github.io/blog/2013/10/12/deep-c-and-c-plus-plus/"/>
    <updated>2013-10-12T16:12:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/10/12/deep-c-and-c-plus-plus</id>
    <content type="html"><![CDATA[<p>摘自<a href="http://share.csdn.net/#/detail/1050">CSDN Share</a></p>

<p>花了一个上午的时间看了下这个PPT，觉得收获颇多。
特别是这个PPT的组织方式，采用两个程序员面试对比的方式，非常的实用，也很有触动和感悟。已经很久没见到这样精彩的PPT了。</p>

<p>本PPT介绍了作为普通的程序员和高级的程序员如何看待C与C++，从编译、链接、运行的角度来介绍，有非常多的干货，也许不是很系统，但确实是非常的实用；特别是在回答面试官的提问上，需要认真思考，从<code>不同的角度</code>、<code>深层次</code>地回答技术官的问话。也许两个程序员的功力差不多，但是在回答技术问题的方法上也许对面试官有很大的影响，最终也就是面试是否成功的关键。</p>

<p><img src="http://www.atmel.com/zh/cn/Images/compiler.jpg" alt="" /></p>

<!--more-->

<p>有一点提示就是，今后在看书的时候，要时常记住一些<code>RULE</code>，语言中更有效的惯用用法(<code>effective conventional language</code>)，特别是深入底层细节的知识，要不断的积累实证，而且得<code>学以致用</code>。一点点细小的差距就是<code>professional programmer</code>与common programmer的区别。最重要的一点是常看优秀的代码，学习与你知识相违背的用例。</p>

<p>&lt;iframe height=620 width=670 scrolling=”no” src=”http://share.csdn.net/#/frame/1050” frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;</p>

<p>截取几张精彩的ppt</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/2_zpsde979321.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/_zpsfe2bfd71.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/3_zpsc78ac177.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/5_zps28849be2.png" /></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/4_zpsff862edf.png" /></p>
]]></content>
  </entry>
  
</feed>
