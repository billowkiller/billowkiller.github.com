<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2013-05-14T01:55:26-04:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[Wutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python特殊语法：filter、map、reduce、lambda [转]]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/pythonte-shu-yu-fa-%3Afilter%2C-map%2C-reduce%2C-lambda-zhuan/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/pythonte-shu-yu-fa-:filter,-map,-reduce,-lambda-zhuan</id>
    <content type="html"><![CDATA[<p><em><strong>from</strong> <a href="http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html">http://www.cnblogs.com/longdouhzt/archive/2012/05/19/2508844.html</a></em></p>

<hr />

<p> </p>

<p>Python内置了一些非常有趣但非常有用的函数，充分体现了Python的语言魅力！</p>

<p>\
<strong>filter(function,
sequence)</strong>：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回：\
>>> def f(x): return x % 2 != 0 and x % 3 != 0 \
>>> filter(f, range(2, 25)) \
[5, 7, 11, 13, 17, 19, 23]\
>>> def f(x): return x != &lsquo;a' \
>>> filter(f, &ldquo;abcdef&rdquo;) \
'bcdef&rsquo;</p>

<p>\
<strong>map(function,
sequence)</strong> ：对sequence中的item依次执行function(item)，见执行结果组成一个List返回：\
>>> def cube(x): return x*x*x \
>>> map(cube, range(1, 11)) \
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\
>>> def cube(x) : return x + x \
&hellip; \
>>> map(cube , &ldquo;abcde&rdquo;) \
[&lsquo;aa&rsquo;, &lsquo;bb&rsquo;, &lsquo;cc&rsquo;, &lsquo;dd&rsquo;, &lsquo;ee&rsquo;]\
另外map也支持多个sequence，这就要求function也支持相应数量的参数输入：\
>>> def add(x, y): return x+y \
>>> map(add, range(8), range(8)) \
[0, 2, 4, 6, 8, 10, 12, 14]</p>

<p>&lt;!&mdash;more&mdash;>
<strong>reduce(function, sequence,
starting_value)</strong>：对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：\
>>> def add(x,y): return x + y \
>>> reduce(add, range(1, 11)) \
55 （注：1+2+3+4+5+6+7+8+9+10）\
>>> reduce(add, range(1, 11), 20) \
75 （注：1+2+3+4+5+6+7+8+9+10+20）</p>

<p>\
<strong>lambda</strong>：这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数，是从LISP借用来的，可以用在任何需要函数的地方： \
>>> g = lambda x: x * 2 \
>>> g(3) \
6 \
>>> (lambda x: x * 2)(3) \
6\
\
\
我们也可以<strong>把filter map reduce
和lambda结合起来</strong>用，函数就可以简单的写成一行。\
例如\
kmpathes = filter(lambda kmpath: kmpath,                  \
map(lambda kmpath: string.strip(kmpath),\
string.split(l, &lsquo;:&rsquo;)))              \
看起来麻烦，其实就像用语言来描述问题一样，非常优雅。\
对 l
中的所有元素以':&lsquo;做分割，得出一个列表。对这个列表的每一个元素做字符串strip，形成一个列表。对这个列表的每一个元素做直接返回操作(这个地方可以加上过滤条件限制)，最终获得一个字符串被&rsquo;:&lsquo;分割的列表，列表中的每一个字符串都做了strip，并可以对特殊字符串过滤。</p>

<p> </p>

<p>[转] <a href="http://hi.baidu.com/black/item/307001d18715fc322a35c747">http://hi.baidu.com/black/item/307001d18715fc322a35c747</a></p>

<p> </p>

<p> </p>

<hr />

<p> </p>

<p><strong>lambda表达式</strong>返回一个函数对象</p>

<p>例子：</p>

<p>func = lambda x,y:x+y</p>

<p>func相当于下面这个函数</p>

<p>def func(x,y):</p>

<p>    return x+y</p>

<p> </p>

<p>注意def是语句而lambda是表达式</p>

<p>下面这种情况下就只能用lambda而不能用def</p>

<p>[(lambda x:x*x)(x) for x in range(1,11)]</p>

<p> </p>

<p>map，reduce，filter中的function都可以用lambda表达式来生成！</p>

<p> </p>

<p><strong>map(function,sequence)</strong></p>

<p>把sequence中的值当参数逐个传给function，返回一个包含函数执行结果的list。</p>

<p>如果function有两个参数，即map(function,sequence1,sequence2)。</p>

<p> </p>

<p>例子：</p>

<p>求1*1,2*2,3*3,4*4</p>

<p>map(lambda x:x*x,range(1,5))</p>

<p>返回值是[1,4,9,16]</p>

<p> </p>

<p><strong>reduce(function,sequence)</strong></p>

<p>function接收的参数个数只能为2</p>

<p>先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给</p>

<p>function，然后只返回一个结果。</p>

<p> </p>

<p>例子：</p>

<p>求1到10的累加</p>

<p>reduce(lambda x,y:x+y,range(1,11))</p>

<p>返回值是55。</p>

<p> </p>

<p><strong>filter(function,sequence)</strong></p>

<p>function的返回值只能是True或False</p>

<p>把sequence中的值逐个当参数传给function，如果function(x)的返回值是True，就把x加到filter的返回值里面。一般来说filter的返回值是list，特殊情况如sequence是string或tuple，则返回值按照sequence的类型。</p>

<p> </p>

<p>例子：</p>

<p>找出1到10之间的奇数</p>

<p>filter(lambda x:x%2!=0,range(1,11))</p>

<p>返回值</p>

<p>[1,3,5,7,9]</p>

<p> </p>

<p>如果sequence是一个string</p>

<p>filter(lambda x:len(x)!=0,&lsquo;hello&rsquo;)返回'hello'</p>

<p>filter(lambda x:len(x)==0,&lsquo;hello&rsquo;)返回''</p>

<p> </p>

<p>[转] <a href="http://blog.csdn.net/myzhan/article/details/7269471">http://blog.csdn.net/myzhan/article/details/7269471</a></p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python dict sorted]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/13/python-dict-sorted/"/>
    <updated>2013-05-13T02:18:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/13/python-dict-sorted</id>
    <content type="html"><![CDATA[<p><em><strong>from</strong> <a href="http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html">http://www.cnblogs.com/linyawen/archive/2012/03/15/2398292.html</a></em></p>

<hr />

<p>我们知道Python的内置dictionary数据类型是无序的，通过key来获取对应的value。可是有时我们需要对dictionary中
的item进行排序输出，可能根据key，也可能根据value来排。到底有多少种方法可以实现对dictionary的内容进行排序输出呢？下面摘取了
一些精彩的解决办法。 \</p>

<!--more-->


<p>#最简单的方法，这个是按照key值排序： \
def sortedDictValues1(adict): \
items = adict.items() \
items.sort() \
return [value for key, value in items] \
\
#又一个按照key值排序，貌似比上一个速度要快点 \
def sortedDictValues2(adict): \
keys = adict.keys() \
keys.sort() \
return [dict[key] for key in keys] \
\
#还是按key值排序，据说更快。。。而且当key为tuple的时候照样适用 \
def sortedDictValues3(adict): \
keys = adict.keys() \
keys.sort() \
return map(adict.get, keys) \
\
#一行语句搞定： \
[(k,di[k]) for k in sorted(di.keys())] \
\
#来一个根据value排序的，先把item的key和value交换位置放入一个list中，再根据list每个元素的第一个值，即原来的value值，排序： \
def sort_by_value(d): \
items=d.items() \
backitems=[[v[1],v[0]] for v in items] \
backitems.sort() \
return [ backitems[i][1] for i in range(0,len(backitems))] \
\
#还是一行搞定： \
[ v for v in sorted(di.values())] \
\
#用lambda表达式来排序，更灵活： \
sorted(d.items(), lambda x, y: cmp(x[1], y[1])), 或反序： \
sorted(d.items(), lambda x, y: cmp(x[1], y[1]), reverse=True) \
\
#用sorted函数的key= 参数排序： \
# 按照key进行排序 \
print sorted(dict1.items(), key=lambda d: d[0]) \
# 按照value进行排序 \
print sorted(dict1.items(), key=lambda d: d[1]) \
\
下面给出python内置sorted函数的帮助文档： \
sorted(&hellip;) \
sorted(iterable, cmp=None, key=None, reverse=False) &mdash;> new sorted
list \
\
看了上面这么多种对dictionary排序的方法，其实它们的核心思想都一样，即把dictionary中的元素分离出来放到一个list中，对list排序，从而间接实现对dictionary的排序。这个“元素”可以是key，value或者item。 \
\
################################################################################# \
\
一上转 \
\
按照value排序可以用 \
\
sorted(d.items, key=lambda d:d[1]) \
\
若版本低不支持sorted \
\
将key,value 以tuple一起放在一个list中 \
\
l = [] \
\
l.append((akey,avalue))&hellip; \
\
用sort（） \
\
l.sort(lambda a,b :cmp(a[1],b[1]))(cmp前加“-”表示降序排序)</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
</feed>
