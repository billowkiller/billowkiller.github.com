<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2013-05-14T01:55:26-04:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[Wutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最短路径算法]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zui-duan-lu-jing-suan-fa/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zui-duan-lu-jing-suan-fa</id>
    <content type="html"><![CDATA[<p><strong>单源最短路径</strong></p>

<p>​1. Dijkstra</p>

<p> Dijkstra算法解决有向图上带权的单源最短路径问题，要求所有边的权值非负。</p>

<p>用到了顶点的最小优先队列，排序关键字为顶点的d值。即开始出了根为0，其他</p>

<p>顶点为正无穷，后来d值根据松弛算法变化。</p>

<p>总计运行时间为O((V+E)lgV)，如果所有顶点都可达的话，则为O(ElgV)。</p>

<p> </p>

<p>​2. Bellman-ford</p>

<p>算法用来解决一般，即边的权值可以为负的单源最短路径问题。算法同时也可以检查</p>

<p>是否有从源点可达的负权回路。</p>

<p>算法的运行时间为O(VE)。</p>

<p> <!--more--></p>

<p>在Dijkstra算法以及关于有向无回路图的最短路径算法中，对每条边执行一次松弛操作。</p>

<p>在Bellman-Ford算法中，对每条边要执行多次松弛操作。</p>

<p> </p>

<p><strong>每对顶点间的最短路径</strong></p>

<p>​1. Floyd-Wallshall</p>

<p>属于动态规划方案，允许存在权值为负的边，但不存在权值为负的回路。</p>

<p>算法考虑最短路径上的中间顶点，自底向上利用中间顶点K值递增的顺序计算权值</p>

<p>利用的递归式为</p>

<p><em>D~i,j,k~ = min(D~i,k,k −\ 1~ + D~k,j,k −\ 1~,D~i,j,k −\ 1~)　　K >=
1</em></p>

<p><em>　　　= W~i,j~                                 　　　　  K = 0</em></p>

<p><em>\
</em>算法运行时间为Φ(n<sup>3</sup>^)。</p>

<p>利用Floyd算法可以计算出有向图的传递闭包，即确定对所有顶点对，图中是否都存在一条</p>

<p>从 i 到 j 的路径。</p>

<p>用相应的逻辑运算或和并来替换 min 和 + 用以增加运算速度。</p>

<p> </p>

<p>​2. 稀疏图上的Johnson算法</p>

<p>对于稀疏图改算法在渐进意义上要好于矩阵的重复平方或Floyd-Wallshall算法。</p>

<p>Johnson算法吧Dijkstra算法和Bellman-Ford算法作为其的子程序。</p>

<p>通过重新赋权值保持最短路径和产生非负的权。</p>

<p>若采用斐波那契堆来实现Dijkstra算法的最小优先队列则运算时间是</p>

<p>O(V<sup>2</sup><sup>lgV</sup> + VE)。更简单的二叉堆实现，则可以得到O(VElgV)的运行时间。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google PageRank]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/google-pagerank/"/>
    <updated>2013-05-14T01:09:00-04:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/google-pagerank</id>
    <content type="html"><![CDATA[<p><strong>edited</strong>from<strong><em>How Google Finds Your Needle in the Web&rsquo;s Haystack</em></strong></p>

<hr />

<p> Google搜索的核心算法当然不止是PageRank，但PageRank确实是其中的核心部分。Google就曾经说过：“the
heart of our software is PageRank”.</p>

<p>Google的PageRank算法声称他们比较了一个月来网页的受欢迎程度从而确定哪个网页显得比较重要。根据Sergey
Brin和Lawrence
Page的说法，一个网页的重要性不仅仅包括他们自身的重要程度，还包括链接向这个网页的其他网页数目。</p>

<p>综合公式为：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_1.gif" alt="\[ I(P_i)=\sum_{P_j\in B_i} \frac{I(P_j)}{l_j} \]
" /></p>

<p>呵呵，看到这个公式我第一反应就是，“我靠，这怎么整啊，这不是鸡生蛋，蛋生鸡”的问题吗？果然，下面就有解决办法。</p>

<p>我们将这个问题转化为一个数学问题。</p>

<!--more-->


<p>首先构造一个链接矩阵，<img src="http://www.ams.org/featurecolumn/images/december2006/index_2.gif" alt="\$ {\bf H}=[H_{ij}] \$
" />。其中：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_3.gif" alt="\[ H_{ij}=\left\{\begin{array}{ll}1/l_{j} &amp; \hbox{if } P_j\in
B_i \\ 0 &amp; \hbox{otherwise} \end{array}\right. \]
" /></p>

<p>同时也创建一个向量<img src="http://www.ams.org/featurecolumn/images/december2006/index_4.gif" alt="\$ I=[I(P_i)] \$
" />，它的构成正是PageRank的值，也就是页面的相对重要程度。用数学表达式定义为：<img src="http://www.ams.org/featurecolumn/images/december2006/index_5.gif" alt="\[
I = {\bf H}I \]
" /></p>

<p>这个表达式其实也就是向量 <em>I </em>为矩阵特征值为1的特征向量，也称呼它为H的固定向量。</p>

<p>下边是一个例子：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/goodnet.jpg" alt="" /></p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.0.gif" alt="" /> 
     
  <img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.0.gif" alt="" /></p>

<p>这样看来，问题貌似得到了解决，我们获得了这8个网页的PageRank值。但是在现实中，这个矩阵的n为250亿，其中的大部分值为0，实际上，研究表明每个网页链接的平均数量是10，这表明每一列只有10个数值不为0。下面我们用一个叫<em>power
method</em>的方法来寻找矩阵的固定向量。</p>

<p> <img src="http://www.ams.org/featurecolumn/images/december2006/index_6.gif" alt="\[ I^{k+1}={\bf H}I^k \]
" /></p>

<p><em><strong>General principle:</strong> The sequence </em>I ^k^<em> will converge to the
stationary vector </em>I<em>.</em></p>

<p>通过这个方法解释上面的例子</p>

<hr />

<p>  <em>I ^0^</em>   <em>I ^1^</em>   <em>I ^2^</em>   <em>I ^3^</em>   <em>I ^4^</em>   &hellip;   <em>I ^60^</em>   <em>I ^61^</em>
  1         0         0         0         0.0278    &hellip;   0.06       0.06
  0         0.5       0.25      0.1667    0.0833    &hellip;   0.0675     0.0675
  0         0.5       0         0         0         &hellip;   0.03       0.03
  0         0         0.5       0.25      0.1667    &hellip;   0.0675     0.0675
  0         0         0.25      0.1667    0.1111    &hellip;   0.0975     0.0975
  0         0         0         0.25      0.1806    &hellip;   0.2025     0.2025
  0         0         0         0.0833    0.0972    &hellip;   0.18       0.18
  0         0         0         0.0833    0.3333    &hellip;   0.295      0.295</p>

<hr />

<p>得到的结果只是网页重要程度的相对比值，如果要的到最终的PageRank数值，还需要对它进行线性增加，使得它们的总和为1。</p>

<p> </p>

<p>有三个问题自然地就提出来了：</p>

<ul>
<li> <em>I^ k^</em>是否会汇聚到1</li>
<li>向量是否与<em>I<sup>0</sup>^</em>的取值无关</li>
<li>是否包含了我们想要的信息，也就是达到充分统计</li>
</ul>


<p>现在我们对这三个问题还只能说No，但接下来我们将会修改我们的方法使得对这三个问题的回答得到肯定。</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/dangling.jpg" alt="" /></p>

<p>with matrix</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.3.gif" alt="" /></p>

<p>结果如下：</p>

<hr />

<p>  <em>I ^0^</em>   <em>I ^1^</em>   <em>I ^2^</em>   <em>I ^3^=</em>I**
  1         0         0         0
  0         1         0         0</p>

<hr />

<p>上面例子的问题是P2并没有链接，它在每次迭代中获取了P1的一些权重，但是却不传给其他网页。像这样没有链接的节点我们称它为悬挂节点，显然，真实环境中这样的网页还很多。要解决这个问题，我们可以转换一种思维方式来思考PageRank，或者说用另外一种视角。</p>

<p>设想我们随机的上网冲浪，我们会随机地从一个页面跳转到另外一个页面。设我们浏览的页面为Pj，它拥有j个链接，其中一个将我们链接到Pi这个页面，那么我们最终浏览Pi页面的概率为1/lj。因为是随机冲浪的，所以我们可以用时间来类比，我们是将在Pj上面浏览的一个时间碎片交给了Pi，也就是Tj/lj。如此叠加，我们可以确定Pi的时间为：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_10.gif" alt="\[ T_i = \sum_{P_j\in B_i} T_j/l_j \]
" /></p>

<p>也就是说<img src="http://www.ams.org/featurecolumn/images/december2006/index_11.gif" alt="\$ I(P_i) = T_i \$
" />。</p>

<p>利用这种视角考虑一个没有任何链接的悬挂节点。我们不可能在这个页面上终止我们的网上冲浪，我们会随机的浏览另外一个网页，可能是通过浏览器的地址栏输入或以其他方式跳转，那么我们可以得到我们跳转向某个页面的概率为1/n，n为总的页面数。下面我们重新定义下上一个例子：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/dangling.jpg" alt="" /></p>

<p>with matrix</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.4.gif" alt="" /></p>

<p>and eigenvector</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.4.gif" alt="" /></p>

<p>通常说来，<em>power
method</em>是用来寻找矩阵特征向量对应的最大特征值的。在我们上面的例子中使用了特征值为1，实际上我们可以用比1小的特征值。
假设S的特征值为<img src="http://www.ams.org/featurecolumn/images/december2006/index_14.gif" alt="\$ \lambda_j \$
" />。有</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_15.gif" alt="\[ 1 = \lambda_1 > |\lambda_2| \geq |\lambda_3| \geq \ldots
\geq |\lambda_n| \]
" /></p>

<p>则有：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_17.gif" alt="\[ I^0 = c_1v_1+c_2v_2 + \ldots + c_nv_n \]
" /></p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_18.gif" alt=" \begin{eqnarray*} I^1={\bf S}I^0 &amp;=&amp;c_1v_1+c_2\lambda_2v_2
+ \ldots + c_n\lambda_nv_n \\ I^2={\bf S}I^1
&amp;=&amp;c_1v_1+c_2\lambda_2^2v_2 + \ldots + c_n\lambda_n^2v_n
\\ \vdots &amp; &amp; \vdots \\ I^{k}={\bf S}I^{k-1}
&amp;=&amp;c_1v_1+c_2\lambda_2^kv_2 + \ldots + c_n\lambda_n^kv_n
\\ \end{eqnarray*}
" /></p>

<p>Since the eigenvalues <img src="http://www.ams.org/featurecolumn/images/december2006/index_19.gif" alt="\$ \lambda_j \$
" /> with <img src="http://www.ams.org/featurecolumn/images/december2006/index_20.gif" alt="\$
j\geq2 \$
" /> have
magnitude smaller than one, it follows that <img src="http://www.ams.org/featurecolumn/images/december2006/index_21.gif" alt="\$ \lambda_j^k\to0 \$
" /> if <img src="http://www.ams.org/featurecolumn/images/december2006/index_22.gif" alt="\$
j\geq2 \$
" />and
therefore <img src="http://www.ams.org/featurecolumn/images/december2006/index_23.gif" alt="\$ I^k\to I=c_1v_1 \$
" /> ,
an eigenvector corresponding to the eigenvalue 1.</p>

<p>It is important to note here that the rate at which <img src="http://www.ams.org/featurecolumn/images/december2006/index_24.gif" alt="\$ I^k\to I \$
" /> is
determined by <img src="http://www.ams.org/featurecolumn/images/december2006/index_25.gif" alt="\$ |\lambda_2| \$
" /> .
When <img src="http://www.ams.org/featurecolumn/images/december2006/index_26.gif" alt="\$ |\lambda_2| \$
" /> is
relatively close to 0, then <img src="http://www.ams.org/featurecolumn/images/december2006/index_27.gif" alt="\$ \lambda_2^k\to0 \$
" /> relatively
quickly.</p>

<p>以上的讨论中，我们假设矩阵S的 <img src="http://www.ams.org/featurecolumn/images/december2006/index_34.gif" alt="\$ \lambda_1=1 \$
" /> 并且<img src="http://www.ams.org/featurecolumn/images/december2006/index_35.gif" alt="\$
|\lambda_2|&lt;1 \$
" /> ，但实际上不常是这样的。</p>

<p>下面的例子:</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/cyclic.jpg" alt="" /><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.1.gif" alt="" /></p>

<p>那么有</p>

<p> </p>

<p> </p>

<hr />

<p>  <em>I ^0^</em>   <em>I ^1^</em>   <em>I ^2^</em>   <em>I ^3^</em>   <em>I ^4^</em>   <em>I ^5^</em>
  1         0         0         0         0         1
  0         1         0         0         0         0
  0         0         1         0         0         0
  0         0         0         1         0         0
  0         0         0         0         1         0</p>

<hr />

<p>the sequence of vectors <em>I <sup>k</sup>^</em> fails to converge。这是因为<img src="http://www.ams.org/featurecolumn/images/december2006/index_36.gif" alt="\$
|\lambda_2|=1 \$
" />，所以power
method就失效了。</p>

<p>为了保证<img src="http://www.ams.org/featurecolumn/images/december2006/index_37.gif" alt="\$ |\lambda_2|&lt;1 \$
" /> ,
矩阵<strong>S</strong> 必须 <em>primitive。</em>这意味着对于某个自然数<strong>m*, </strong>S<em><em>^</em>m</em>^<em>中的数值全为正。也就是说，对于两个页面，最多经过m个链接，可以从第一个页面跳转到第二个页面。显然，上个例子并不满足。</em>\
*</p>

<p>下面是另外一个例子：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/reducible.jpg" alt="" /></p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.2.gif" alt="" /></p>

<p>with stationary vector</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.2.gif" alt="" /></p>

<p>有4个网页的PageRank为0，这显然不对，原因是上图中内涵一个更小的网络。</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/reduciblewithbox.2.jpg" alt="" /></p>

<p>就像上面所说的悬挂节点一样，前4个页面的权值进入蓝色的区域后，就在内部消化而不返回出来，其余4个页面获得了前4个页面所有的权值。这是因为矩阵S是可约的，也就是如下形式：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_39.gif" alt="\[ S=\left[\begin{array}{cc} * &amp; 0 \\ * &amp; *
\end{array}\right]. \]
" /></p>

<p>要达到不可约，则网络图必须是强连通的，只有强连通图，才能保证有不可约的矩阵。</p>

<p>最终修改：</p>

<p>我们需要重新构造我们的上网行为：我们在浏览有链接的网站时，仍然有一定的几率不遵守这个网站上面的链接，而直接在地址栏上面输入我们想要去的网站，假设这个概率为<img src="http://www.ams.org/featurecolumn/images/december2006/index_42.gif" alt="\$
1-\alpha \$
" />。</p>

<p>最终的公式为：<img src="http://www.ams.org/featurecolumn/images/december2006/index_44.gif" alt="\[ {\bf G}=\alpha{\bf S}+
(1-\alpha)\frac{1}{n}{\bf 1} \]
" /></p>

<p>显然<img src="http://www.ams.org/featurecolumn/images/december2006/xx.gif" alt="\$\alpha\$
" />值应该要非常接近1，根据大量的实验结果，Serbey
Brin和Larry Page选择了0.85。</p>

<p>使用<em>power method</em>则公式为：</p>

<p> </p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_52.gif" alt="\[ {\bf S}={\bf H} + {\bf A} \]
" /></p>

<p> </p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_53.gif" alt="\[ {\bf G}=\alpha{\bf H} + \alpha{\bf A} +
\frac{1-\alpha}{n}{\bf 1} \]
" /></p>

<p> </p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_54.gif" alt="\[ {\bf G}I^k=\alpha{\bf H}I^k + \alpha{\bf A}I^k +
\frac{1-\alpha}{n}{\bf 1}I^k \]
" /></p>
]]></content>
  </entry>
  
</feed>
