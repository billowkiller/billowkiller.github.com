<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: book | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/categories/book/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2015-07-26T17:21:00+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Notes]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/22/network-programming/"/>
    <updated>2014-07-22T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/22/network-programming</id>
    <content type="html"><![CDATA[<p>记录Linux网络编程中的一些知识点…</p>

<hr />

<h3 id="section">网络编程可能会遇到的三种情况</h3>

<ol>
  <li>当<code>fork</code>子进程时，必须捕获<code>SIGCHLD</code>信号。</li>
  <li>当捕获信号时，必须处理被中断的系统调用；</li>
  <li>
    <p><code>SIGCHLD</code>的信号处理函数必须正确编写，应使用<code>waitpid</code>函数以免留下僵死进程。</p>

    <p><code>waitpid</code>是可以非阻塞的等待信号终止，因此可以使用循环调用。</p>
  </li>
</ol>

<!--more-->

<h3 id="socket">网络socket</h3>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/socket_zpsdcdfab1b.png" alt="" /></p>

<p><strong>对应的TCP分组</strong></p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/TCP_zpsb7790efe.png" alt="" /></p>

<h3 id="shutdown">shutdown函数</h3>

<p>终止网络连接的通常方法是调用<code>close</code>函数。不过<code>close</code>有两个限制，可以使用<code>shutdown</code>来避免。</p>

<ol>
  <li><code>close</code>把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。使用<code>shutdown</code>可以不管引用计数就激发TCP的正常连接终止序列。</li>
  <li><code>close</code>终止读和写两个方向的数据传送。</li>
</ol>

<p>说明：</p>

<ul>
  <li><code>shutdown</code>根本没有关闭socket,任何与socket关联的资源直到调用closesocket才释放。</li>
  <li>TCP连接的socket是全双工的，也就是说它可以发送和接收数据，但是一个方向上的数据流动和另一个方向上的数据流动是不相关的，shutdown函数的功能也就是体现在这里，它通过设置how选择关闭哪条数据通道(发送通道和接收通道)，如果关闭了发送通道，那么这个socket其实还可以通过接收通道接受数据.</li>
  <li>当通过以how=1(<code>SHUT_WR</code>)的方式调用<code>shutdown</code>，就可以保证对方收到一个EOF，而不管其他的进程是否已经打开了套接字，而调用<code>close</code>或closesocket就不能保证，因为直到套接字的引用计数减为0时才会发送FIN消息给对方，也就是说，直到所有的进程都关闭了套接字。</li>
</ul>

<p><strong>为了保证在连接撤销之前，保证双方都能接收到对等方的所有数据，在调用closesocket之前，先调用shutdown关闭发送数据通道。</strong></p>

<h3 id="tcpclosewait">tcp中close_wait状态出现的原因</h3>

<p><code>close_wait</code>出现的原因: 就是某一方在网络连接断开后，对等方没有检测到这个错误（对方断开）而没有调   用 closesocket，导致了这个状态的出现.</p>

<p>模拟这样一个环境:服务器192.168.1.112:4500在接收到一个客户端的连接后，休眠五秒后，服务器关闭与客户 端通讯的socket后正常退出，而客户端在连接服务器后，等待用户输入字符后，发送给客户端。现在有这样几个问题:</p>

<ol>
  <li>
    <p>服务器在休眠五秒后，正常退出了，但是由于客户端还在等待用户输入，此时服务器端TCP的状态是什么？(<code>FIN_WAIT_2</code>)，客户端的TCP状态是什么?(<code>CLOSE_WAIT</code>)</p>
  </li>
  <li>
    <p>服务器在休眠五秒后，正常退出了，在服务器退出后，如果客户端异常退出，那么服务器端TCP的状态是什么？客户端的TCP状态是什么?</p>
  </li>
</ol>

<pre><code>   在服务器正常退出后，客户端异常退出，那么客户端就会向服务器发送RST标志，然后客户端和服务器端的TCP状态都是`CLOSED`
</code></pre>

<ol>
  <li>服务器在休眠五秒后，正常退出了，在服务器退出后,从客户端输入数据后，向服务器发送，此时服务器怎样处理这个数据?</li>
</ol>

<pre><code>   客户端通过PSH标志向服务器段发送数据，能够发送成功，但因为服务器的TCP处于(`FIN_WAIT_2`)状态，此时服务器会向客户端发送一个RST标示，并且服务器端口状态和客户端的TCP状态都变为`CLOSED`。
</code></pre>

<ol>
  <li>在服务器休眠的过程中，杀死服务器进程，服务器端TCP状态是什么?客户端的TCP状态是什么?</li>
</ol>

<pre><code>在服务器休眠的过程中，杀死服务器进程，此时服务器方会向客户端发送一个RST标志，服务器TCP状态是`CLOSED`，客户端的TCP状态也是`CLOSE`.
在服务器休眠五秒后，如果不关闭与客户端通讯的Socket直接正常退出，此时，服务器方也向客户端发送了RST标志。
</code></pre>

<p>对于上面的四个问题，必须注意到服务器正常断开的时候，向客户端发送的FIN根本不能被客户端的所正常处理，因为客户端正处于接收用户的输入。所以由于每次都是服务器主动断开，但是服务器TCP状态却有可能不能进入到<code>Time_Wait</code>状态。</p>

<h3 id="section-1">服务器终止可能出现的情况</h3>

<ol>
  <li><code>accept、read、write、select、open</code>等慢系统调用中断，系统调用可能返回<code>EINTR</code>错误。需要重启被中断的系统调用。并且编写捕获信号的程序时，必须对慢系统调用返回<code>EINTR</code>有所准备。</li>
  <li>三路握手完成后，客户TCP发送一个RST。服务器进程在调用<code>accept</code>的时候RST到达。accept返回一个错误给服务器进程，POSIX指出返回的errno值必须是<code>ECONNABORTED</code>（“software caused connection abort.”）。服务器忽略它，再次调用accept。</li>
  <li>服务器进程终止。服务端调用<code>kill</code>命令杀死服务器子进程。子进程中所有打开的描述符都被关闭，进而会向客户发送一个FIN，客户TCP则响应一个ACK。而客户进程此时阻塞在<code>fgets</code>调用上。由于FIN的接收并没有告知客户服务器进程已经终止，所以客户进程照常发送数据。此时服务端响应RST。客户进程看不到这个RST，因为它在调用<code>writen</code>后立即调用<code>readline</code>，并且由于接收到FIN，<strong>所调用的readline立即返回0（EOF）</strong>。于是以出错信息（“server terminated prematurely”）退出。</li>
  <li>如果客户不理会<code>readline</code>函数返回的错误，写更多的数据到服务器上。当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个<code>SIGPIPE</code>信号。该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止。</li>
  <li>服务器主机崩溃。客户端到服务端之间网络断掉，或者服务端断电等，物理连接断掉了，这种情况下客户端不会退出（此情况称为<strong>半开连接</strong>），<code>send</code>函数正常执行，不会感觉到自己出错。因为由于物理网络断开，服务端不会给客户端回应错误消息。此时，客户TCP持续重传数据分节，试图从服务器上接收一个ACK。最终返回的错误是<code>ETIMEDOUT</code>。然而如果某个中间路由器判定服务器主机已不可达，从而响应一个“destination unreachable”ICMP消息，那么返回的错误是<code>EHOSTUNREACH</code>或<code>ENETUNREACH</code>。</li>
  <li>服务器主机崩溃后重启。服务进程对客户端<code>send</code>来的消息会产生RST响应。客户收到RST时，客户正阻塞于<code>read</code>调用，导致该调用返回<code>ECONNESET</code>错误。</li>
  <li>服务器主机关机。unix系统关机时，<code>init</code>进程通常先给所有进程发送<code>SIGTERM</code>信号（可捕获），等待固定一段时间后，给所有仍在运行的进程发送<code>SIGKILL</code>信号。接下里就和3一样。</li>
</ol>

<p>下图是检测各种TCP条件的方法</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/2014-08-01183756__zpse1970a67.jpg" alt="" /></p>

<h3 id="solinger">SO_LINGER套接字选项</h3>

<p>在默认情况下，当调用<code>close</code>关闭socket的使用，<code>close</code>会立即返回；但是，如果send buffer中还有数据，系统会试着先把send buffer中的数据发送出去，然后close才返回。</p>

<p><code>SO_LINGER</code>选项则是用来修改这种默认操作的。于SO_LINGER相关联的一个结构体如下:</p>

<pre><code>#include &lt;sys/socket.h&gt;
struct linger {
      int l_onoff  //0=off, nonzero=on(开关)
      int l_linger //linger time(延迟时间)
}
</code></pre>

<p>当调用<code>setsockopt</code>之后,该选项产生的影响取决于<code>linger</code>结构体中<code>l_onoff</code>和<code>l_linger</code>的值:</p>

<ul>
  <li>当<code>l_onoff</code>被设置为0的时候,将会关闭<code>SO_LINGER</code>选项,即TCP或则SCTP保持默认操作:<code>close</code>立即返回、<code>l_linger</code>值被忽略.</li>
  <li><code>l_lineoff</code>值非0，<code>l_linger</code>为0，那么当<code>close</code>某个连接时TCP将终止该连接。send buffer中未被发送的数据将被丢弃,并向对方发送一个RST信息.值得注意的是，由于这种方式，是非正常的4中握手方式结束TCP链接，所以，TCP连接将不会进入<code>TIME_WAIT</code>状态，这样会导致新建立的可能和就连接的数据造成混乱。</li>
</ul>

<p>设置<code>SO_LINGER</code>套接字选项后，<code>close</code>的成功返回只是告诉我们先前发送的数据（和FIN）已由对端TCP确认，而不能告诉我们对端应用进程是否已读取数据。如果不设置该套接字选项，那么我们连对断TCP是否确认了数据都不知道。
让客户知道服务器已读取其数据的一个方法是改为调用<code>shutdown</code>，并设置它的第二个参数为<code>SHUT_WR</code>，而不是调用<code>close</code>。</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/1_zps7ad163b0.png" alt="" /></p>

<p>关闭连接的本地端（客户端）时，根据所调用的函数（<code>close</code>和<code>shutdown</code>）以及是否设置了<code>SO_LINGER</code>套接字选项，<strong>可在以下3个不同的时机返回</strong>。</p>

<ol>
  <li><code>close</code>立即返回，根本不等待（默认情况）。</li>
  <li><code>close</code>一直拖延到接受了对于客户端FIN的ACK才返回。</li>
  <li>后跟一个<code>read</code>调用的<code>shutdown</code>一直等到接受对端FIN才返回。</li>
</ol>

<p><strong>下图汇总了对shutdown的两种可能调用和对close的三种可能调用，以及它们对TCP套接字的影响。</strong>
<img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/_zps2eb27157.png" alt="" /></p>

<h3 id="soreuseaddr">SO_REUSEADDR套接字选项</h3>

<p>SO_REUSEADDR套接字选项能起到以下功能。</p>

<ol>
  <li>
    <p>SO_REUSEADDR允许一个server程序listen监听并bind到一个端口,既是这个端口已经被一个正在运行的连接使用了.</p>

    <p>例如，以下情况：</p>

    <ol>
      <li>一个监听(listen)server已经启动</li>
      <li>当有client有连接请求的时候,server产生一个子进程去处理该client的事物.</li>
      <li>server主进程终止了,但是子进程还在占用该连接处理client的事情.虽然子进程终止了,但是由于子进程没有终止,该socket的引用计数不会为0，所以该socket不会被关闭.</li>
      <li>server程序重启.</li>
    </ol>

    <p><strong>所有的TCP server都必须设定此选项,用以应对server重启的现象.</strong></p>
  </li>
  <li>
    <p>SO_REUSEADDR允许多个server绑定到同一个port上,只要这些server指定的IP不同</p>

    <p>SO_REUSEADDR需要在bind调用之前就设定。另外，还可以在绑定IP通配符。但是最好是先绑定确定的IP，最后绑定通配符IP。运行在这些端口上的服务器实例可以相同，也可以不同。在TCP中，不允许建立起一个已经存在的相同的IP和端口的连接。但是在UDP中，是允许的，特别是在多播中。</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Summary of TCP/IP ILLustrated Volume 1]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/18/TCP-IP/"/>
    <updated>2014-07-18T09:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/18/TCP-IP</id>
    <content type="html"><![CDATA[<p>Modified from several blogs. Sorry for failing to detailed list.</p>

<hr />

<p>要快速学习一本书，最简单的途径是在网上找一些靠谱的读书笔记、总结之类的博文，然后细细研读，再根据重要的或者未详尽描述的知识点在书中阅读。根据这样的学习方法，总结了《TCP/IP详解 卷1：协议》这本书。</p>

<p>介绍是以图为驱动的，接下来就开始吧。</p>

<h2 id="tcpip">tcp/ip协议簇</h2>

<p><img src="http://dl.iteye.com/upload/attachment/598180/ebd73be4-de65-38cc-adde-514a3d486844.jpg" alt="" /></p>

<!--more-->

<p>上图左侧是数据包在各个网络层的状态，右侧是数据包在各个网络层的传递。其中，以太网口通过以太网地址来决定丢弃还是交付通过以太网口的数据包（此时称为以太网帧）；以太网驱动程序通过检验和来决定将其丢弃还是交付给上一层；接着，驱动程序通过以太网首部中的“类型”字段对以太网帧进行分用，确定这是一个ip数据报，还是一个ARP/RARP请求/应答；如果是后者，则通过协议进行应答；如果是ip数据报，则脱去帧头帧尾，将其交付到Ip层。IP层首先进行检验和计算以决定交付还是丢弃报文，然后通过ip首部中的“协议”字段确定其是UDP数据报、TCP段还是ICMP、IGMP报文，从而对IP数据报进行分用。如果是ICMP或IGMP，则根据协议对其进行处理，如果是TCP或UDP，则去其头部，将其交付到运输层；TCP/UDP则是通过端口号将数据分用到对该端口进行监听的应用程序。</p>

<h2 id="section">链路层</h2>

<h3 id="section-1">以太网帧</h3>

<p><img src="http://dl.iteye.com/upload/attachment/598848/99c6503e-20d5-34f3-976f-8c1fc239d179.jpg" alt="" /></p>

<p>上图是以太网帧的封装格式。其中的“类型”字段正是用于IP数据报、ARP报文和RARP报文的分用。可以看到，每个以太网帧有最小长度和最大长度，最小长度为64字节，是为了检测冲突；最大长度是1518，最大传输单元MTU为1500字节。</p>

<h3 id="arp--rarp">ARP &amp; RARP</h3>

<p>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址。</p>

<p><strong>ARP</strong>（地址解析协议）是设备<strong>通过自己知道的IP地址来获得自己不知道的物理地址</strong>的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，网络上的无盘工作站就是这种情况，设备知道的只是网络接口卡上的物理地址。这种情况下应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。
RARP以与ARP相反的方式工作。<strong>RARP发出要反向解析的物理地址并希望返回其对应的IP地址</strong>，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p>

<p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存，这个高速缓存存放了最近IP地址到硬件地址之间的映射记录。高速缓存中的每一项的生存时间为20分钟，开始时间从被创建时开始算起。可以使用<code>arp -a</code>来检查ARP高速缓存。下图为ARP的分组格式。</p>

<p><img src="http://dl.iteye.com/upload/attachment/599192/e13ec54f-0994-358e-9772-fcfb934e2741.jpg" alt="" /></p>

<ul>
  <li>对于arp请求，其以太网帧首部中的<strong>硬件地址为全1</strong>，<strong>代表广播</strong>，请求主机向它所在的网络广播一份arp请求。</li>
  <li>ARP请求从一个网络发往另一个网络，连接2个网络的路由可以回答该请求，这个过程叫做委托ARP或<strong>代理ARP</strong>。</li>
  <li>arp请求还有另外一个特性叫<strong>免费arp</strong>，它是指主机发送arp查找自己的ip地址。
    <ul>
      <li>一个主机可以通过它来确定另一个主机是否设置了相同的ip地址。检测<strong>网络存在ip冲突</strong>。</li>
      <li>如果发送免费arp的主机正好改变了硬件地址，那么这个分组就可以使其他主机高速缓存中旧的硬件地址<strong>进行相应的更新</strong>。</li>
    </ul>
  </li>
</ul>

<h2 id="section-2">网络层</h2>

<h3 id="ip">IP协议</h3>

<p><strong>IP提供不可靠、无连接的数据报传送服务</strong>。<strong>不可靠是指它不能保证IP数据报能成功地到达目的地</strong>，如果发生某种错误时（如路由器暂时用完了缓冲区），IP有一个简单的处理算法：丢弃该数据报，然后发送ICMP消息给信源端。<strong>无连接的意思是，IP数据报不维护任务关于后续数据报的状态信息</strong>，每个数据报的处理是相互独立的。首先看一下IP数据报的格式：</p>

<p><img src="http://dl.iteye.com/upload/attachment/598868/830a6b5c-cf71-39e2-bd0f-6b5bfa25e2ab.jpg" alt="" /></p>

<p>特地说明下检验和是怎么产生的。TCP和IP协议中都有校验和字段。IP协议根据IP首部计算的检验和码，它不对首部后面的数据进行计算。为了计算一份数据报的IP检验和，首先把检验和字段置为0，然后对首部中每16bit进行二进制反码求和。而TCP、UDP协议的检验和需要对数据进行计算，并且要伪造一个IP头，包括IP地址、报文长度等数据。</p>

<p>IP协议的协议字段包含了被IP包封装了的协议，这个逆过程称为<strong>分用</strong>。包括TCP、UDP、ICMP及IGMP等。</p>

<h3 id="ip-1">IP路由选择</h3>

<p>路由器与主机的本质区别在于，主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据。IP可以从TCP、 UDP、ICMP、IGMP接口数据报（即本地待发送的数据），也可以从一个网络接口接收数据报。IP层在内存中有一个<strong>路由表</strong>，当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数 据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么（1）主机将丢弃报文；（2）路由器对数据报进行转发。</p>

<p>路由表中的每一项包括：(通过<code>netstat -rn</code>可以查到该路由表）</p>

<ol>
  <li>目的IP地址，它既可以是一个完整的主机地址，也可以是一个网络地址，主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的主机。</li>
  <li>下一跳路由器的ip地址，或者有直接连接的网络IP地址。</li>
  <li>标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由是路由器还是一个直接相连的接口。总共有五种不同的标 志：U（该路由可用）、G（该路由是到一个网关）、H（该路由是到一个主机）、D（该路由是由重写向报文创建的）、M（该路由已被重定向报文修改）。</li>
</ol>

<p>IP路由选择主要完成以下这些功能：</p>

<ol>
  <li>搜索路由表，寻找能与目的IP地址完全匹配的表目，如果找到，就把报文发往该地址；</li>
  <li>搜索路由表，寻找能与目的网络号相匹配的表目，如果找到，则把报文发送给该表目指定的下一站路由器直接连接的网络接口；</li>
  <li>搜索路由表，寻找标为“默认”的表目，如果找到，把报文发送给该表目指定的下一站路由器。</li>
</ol>

<p>如果上面这些步骤都没有成功，那么该数据报就不能被发送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。</p>

<p>下图描述了IP层处理过程的简单流程：</p>

<p><img src="http://dl.iteye.com/upload/attachment/599650/5ba5f055-2428-35fa-8791-c03dae480fce.jpg" alt="" /></p>

<p>系统通过三种途径改变路由表的表项，一个是<strong>route命令</strong>，由管理员手动配置路由，一个是<strong>ICMP重定向报文</strong>，这是一种只能由路由器生成的ICMP差错报文，最后一个则是<strong>路由守护程序</strong>，路由守护程序是一个应用程序，它通过发送ICMP路由器请求报文，接收ICMP路由器通告报文来获知相邻的网络情况。</p>

<h3 id="icmp">ICMP</h3>

<p>ICMP是Internet控制报文协议，用于查询和传输出错报告控制信息。</p>

<p>其中<strong>ICMP查询报文</strong>包括：</p>

<ul>
  <li>回显应答/请求， <strong>ping程序使用的报文</strong></li>
  <li>路由器通告/请求，用于IP选路（另一种是RIP路由选择信息协议）</li>
  <li>时间戳请求/应答，允许系统向另一个系统查询当前的时间</li>
  <li>子网掩码请求/应答， 用于无盘系统在引导过程中获取自己的子网掩码</li>
</ul>

<p><strong>ICMP差错报文</strong>：</p>

<ul>
  <li>不可达报文</li>
  <li>超时报文</li>
  <li>重定向差错报文，修改路由表</li>
  <li>源站抑制差错，系统接收数据报的速度大于数据处理的数据</li>
</ul>

<p><strong>ICMP超时+ICMP端口不可达+TTL是traceroute程序的工作原理。</strong>traceroute程序发送一份TTL字段为1的IP数据报文给目的主机，处理这份数据报的第一个路由器将其TTL值减1，丢弃该数据报，并发回一份ICMP超时报文，通过报文中的信源地址我们将得到该路由器的地址；接着，traceroute发送一份TTL值为2的IP数据报文给目的主机，这样，第二个路由器将发回一份ICMP超时报文，….，直到最后该报 文到达目的主机并被接收，那么如何判断报文已经到达目的主机了呢？traceroute将选择一个不可能的值作为目的端口号（大于30000），使目的主机的任何一个应用程序都不可能使用该端口，这样，目的主机收到该报文时，将产生一份“ICMP端口不可达”报文给，这样，当traceroute收到的 ICMP报文是“目的端口不可达”时，可以判断已经完成了整个traceroute的过程。记得IP首部中的“选项”部分还可以设置“严格的源站选路”和 “宽松的源站选路”选项，可以在traceroute发送的IP数据报首部中加入该选项，来规划traceroute的路径。</p>

<h3 id="section-3">互联网的地址、广播、多播</h3>

<p><img src="http://dl.iteye.com/upload/attachment/599740/8fca4629-889a-3533-9abe-bd3915fdbb6f.jpg" alt="" /></p>

<ul>
  <li>A类   0.0.0.0 – 127.255.255.255</li>
  <li>B类 <strong>128</strong>.0.0.0 – 191.255.255.255</li>
  <li>C类 <strong>192</strong>.0.0.0 – 223.255.255.255</li>
  <li>D类 <strong>224</strong>.0.0.0 – 239.255.255.255</li>
  <li>E类 <strong>240</strong>.0.0.0 – 247.255.255.255</li>
</ul>

<p>有三类地址：<strong>单播地址，多播地址和广播地址</strong>。主机号为全0代表网络号，主机号为全1代表在该网络的广播。有<strong>四种广播地址</strong>：</p>

<ol>
  <li>受限的广播地址255.255.255.255.该地址用于主机配置过程中IP数据报的目的地址，在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样数据报仅出现在地址网络中。</li>
  <li>指向网络的广播地址，主机号为全1.如A类广播地址为netid.255.255.255，一个路由器必须转发指向网络的广播。</li>
  <li>指向子网的广播。指向子网的广播地址为主机号为全1且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码，例如，如果路由 器收到发往128.1.2.255的数据报，当B类网络128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但如果该子 网的掩码为255.255.254.0，该地址就不是指向子网的广播地址。</li>
  <li>指向所有子网的广播。指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来，指向所有子网的广播地址的子网号和主机号全为1。例如，如果目的子网掩码为255.255.255.0，那么IP地址128.1.255.255就是一个指向所有子网的广播地址，然而，如 果网络没有划分子网，这就是一个指向网络的广播。</li>
</ol>

<p>广播给网络中的主机产生了很多负担，<strong>广播的数据报要直到UDP层才被确定是否为主机所需要</strong>（没有监听的端口）然后才会被丢弃。多播是介于单播与广播之间的一种方式。</p>

<p>能够接收发往一个特定多播组地址数据的主机集合称为主机组。一个主机组可以跨越多个网络，主机组中成员可以随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。
下图是多播组地址到以太网地址的转换：</p>

<p><img src="http://dl.iteye.com/upload/attachment/599747/65577750-0fa4-3a4c-addd-dcdf7b62e2f9.jpg" alt="" /></p>

<h3 id="igmp">IGMP协议</h3>

<p>Internet组管理协议（IGMP）是因特网协议家族中的一个<strong>组播协议</strong>，用于 IP主机向任一个直接相邻的路由器报告他们的组成员情况。它规定了处于不同网段的主机如何进行多播通信，其前提条件是路由器本身要支持多播。</p>

<p>它用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。IGMP不包括组播路由器之间的组成员关系信息的传播与维护，这部分工作由各组播路由协议完成。</p>

<p>参与IP组播的主机可以在任意位置、任意时间、成员总数不受限制地加入或退出组播组。组播路由器不需要也不可能保存所有主机的成员关系，它只是通过IGMP协议了解每个接口连接的网段上是否存在某个组播组的接收者，即组成员。而主机方只需要保存自己加入了哪些组播组。多播路由器并不关心有多少主机属于一个多播组，它只是想知道给定接口上的多播组是否还有人对这个多播组感兴趣。</p>

<h3 id="section-4">选路协议</h3>

<p>当相邻的路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器之间必须采用选路协议进行通信，这样的协议有很多种，如RIP、OSPF，路由守护进程运行选路协议，并与其相邻的一些路由器进行通信。路由守护程序将选路策略加入到系统中，选择路由并加入到内核的路由表中。如果守护程序发现前往同一信宿存在多条路由，那么它将（以某种方法）选择最佳路由并加入内核路由表中。如果路由守护程序发现一条链路已经断开，它可以删除受影响的路由或加入另一条路由以绕过该问题。</p>

<p>在像Internet这样的系统中，目前采用了许多不同的选路协议。Internet是以一组自治系统的方式组织的，每个自治系统通常由单个实体管 理。常常将一个公司或大学校园定义为一个自治系统。每个自治系统可以选择该自治系统中各个路由器之间的选路协议，这种协议称之为内部网关协议（IGP）， 常用的IGP有RIP和OSPF。不同自治系统的路由器之间进行通信协议称为外部网关协议（BGP）。</p>

<h2 id="section-5">传输层</h2>

<p>终于到了传输层，先来个开胃菜UDP，再介绍TCP。</p>

<h3 id="udp-">UDP 用户数据报协议</h3>
<p>下图是UDP首部的格式：</p>

<p><img src="http://dl.iteye.com/upload/attachment/599727/3174ddc1-a81b-36ea-ac8e-a72a8418188d.jpg" alt="" /></p>

<p>当UDP数据报的长度超过网络的MTU时，必须对其进行分片。如果IP层设置了DF位但是通过某个网络时需要分片，将会产生ICMP“不可达（需要分片）”的差错报文。</p>

<p>分片需要注意的是：(1)在分片时，除最后一片外，其他每一 、片中的数据部分（除IP首部外的其余部分）必须是8整数倍；(2)运输层首部只出现在第一片中。UDP比较简陋，所有包丢失、重传问题都必须由上层应用程序来管理。</p>

<h3 id="tcp-">TCP 传输控制协议</h3>

<p>TCP提供<strong>面向连接的，可靠的</strong>字节流服务， 它设计了各种机制以实现丢包、重发、乱序、链路传输错误等传输过程中可能出现的错误。</p>

<p><strong>1. TCP报文格式</strong></p>

<p><img src="http://dl.iteye.com/upload/attachment/599787/eccadd8c-6160-3bda-837c-704c0d09c0b0.jpg" alt="" /></p>

<p>其中6个标志比特，它们中的多个可以被同时设置为1：</p>

<ul>
  <li>URG：紧急指针有效，与后面的紧急指针结合起来</li>
  <li>ACK：确认序号有效</li>
  <li>PSH：接收方尽快将这个报文段交给应用层</li>
  <li>RST：重建连接</li>
  <li>SYN：同步序号用来发起一个连接</li>
  <li>FIN：发端完成发送任务，将要关闭连接</li>
</ul>

<p>其他字段有：</p>

<ul>
  <li>窗口大小表明接收端当前的接收能力，以字节为单位，16位窗口限制了最大值为65535字节，在选项字段中，有一个窗口刻度选项，允许这个值按比例放大。</li>
  <li>紧急指针是一个正的偏移量，和序号中的值相加表示紧急指针最后一个字节的序号。</li>
  <li>选项字段可以包括<strong>最长报文大小（MSS）</strong>，这是最常见的可选字段。每个连接方通常都在通信的第一个报文段中指明这个选项，表明本端所能接收的最大长度的报文段；还有窗口扩大选项以及时间戳选项。</li>
</ul>

<p><strong>2. 连接与终止</strong></p>

<p><img src="http://dl.iteye.com/upload/attachment/599805/5991ccb8-afaa-3670-9f00-4da6f24a38ea.jpg" alt="" /></p>

<p>tcp连接的其中一方发起主动连接，它填写目的端口和源端口号，初始化序列号，设置SYN位，并设置了mss选项，将该TCP段发给连接的另一方。 另一方收到tcp段后，与主动连接方做了同样的事情，同时携带ACK，把对主动连接方的初始序号加1填入确认序列号字段，发送给主动连接方。主动连接方向 被动连接方发去一个ack，连接由此建立。</p>

<p>图中还演示了连接关闭的过程，终止一个连接需要四次握手。任何一方在最后的发送数据段中设置FIN位来终止这个方向的连接。当一端收到一个FIN， 它必须通知应用层另一端已经终止了那个方向的数据传输，也就是说，不再会有数据从那个方向传来，但它仍然能够发送数据，收到FIN方回复一个ack。</p>

<p>由图我们还可以看到，SYN和FIN各占用了一个序号。</p>

<p>图中的端口A、B还让我们想起一个问题，如果不存在用户进程在监听端口B（<strong>即端口B没有打开</strong>）时，主机A将会收到什么呢？在UDP中，发送端将收到一份ICMP端口不可达报文，那么在TCP连接中呢？TCP使用复位，即在回应发送端的TCP段中设置了RST位，携带ack主动发送端的确认序列号，自己的序列号为0。发送端收到这样的tcp段后，即知道连接被拒绝了。</p>

<p>那如果<strong>主机B根本就不存在</strong>呢？这时主机A将过一段时间再发送一个SYN到主机B请求连接，一般建立一个连接的最长时间限制为75秒。</p>

<p>如果一方已经关闭或导演终止而另一方却不知道，我们将这样的TCP连接称为<strong>半打开</strong>的。比方说在主机A（客户端）上运行telnet程序，通过它和主机B（服务器）连接，由于突然停电，主机A没有向主机B的telnet端口发送FIN消息，结果主机B就以为与主机A的连接还在。主机A重新启动后再次与主机B连接将会启动新的服务器程序，这样<strong>将会导致主机B上产生很多半打开的TCP连接</strong>。如果是服务器主机B突然当掉了，而客户端A并不知道，它继续向主机B发送数据，假如主机B很快恢复了，然而先前的所有连接信息都丢失了，收到来自主机A的消息时，它<strong>回复以RST消息</strong>（相当于没有端口在监听）。</p>

<p>TCP支持同时打开或同时关闭，不过同时打开将经历4次握手。同时关闭进入<code>TIME_WAIT</code>状态，要再经过2MSL超时才关闭。</p>

<p><img src="http://blog.chinaunix.net/photo/91603_100713212857.jpg" alt="同时打开" /></p>

<p><img src="http://blog.chinaunix.net/photo/91603_100713213550.jpg" alt="同时关闭" /></p>

<p><strong>3. TCP的状态变迁</strong></p>

<p><img src="http://blog.chinaunix.net/photo/91603_100707001221.jpg" alt="" /></p>

<p>状态图中比较重要的一点就是，主动关闭方在收到对方的对自己FIN的ACK以及对方的FIN后，进入一个状态叫<code>TIME_WAIT</code>，这种状态也称为<code>2MSL</code> 等待状态。每个TCP实现必须选择一个报文段最大生存时间MSL(Maximum Segment Lifetime)，它是任何报文段被丢弃前在网络内的最长时间。对于一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在<code>TIME_WAIT</code>状态停留的时间为2倍的MSL，<strong>以防这个ACK丢失的时候，可以重发一个ACK（对应另一端收不到ACK重发最后的FIN消息）</strong>。这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务的IP地址和端口号）不能再被使用，这个连接只能在2MSL结束后才能被使用。</p>

<p><img src="http://blog.chinaunix.net/photo/91603_100708211823.jpg" alt="" /></p>

<p><strong><code>TIME_WAIT</code>是执行主动关闭的那一段进入的状态，存在的理由有两个</strong>：</p>

<ol>
  <li>可靠地实现TCP全双工连接的终止，也就是上面的那个理由。</li>
  <li>
    <p>运行老的重复分节在网络中消逝。</p>

    <p>防止上一个连接到达的TCP误解为现在的连接的TCP。<code>TIME_WAIT</code>存在2MSL，而两个方向上的TCP都最多存活MSL秒即被丢弃。</p>
  </li>
</ol>

<p><strong>4. 呼叫连接请求队列</strong></p>

<p>TCP处理呼入连接请求规则:</p>

<ol>
  <li>正等待连接的一端有一个固定长度的连接队列，该队列中的连接已经完成3次握手，但还没有被应用层接收。</li>
  <li>
    <p>应用层指定这个连接队列的最大长度，这个值通常叫做积压值(backlog)。取值范围为0至5的整数。</p>

    <p>不同环境下，backlog的含义与实现都将不同：</p>

    <blockquote>
      <p>The behaviour of the backlog parameter on TCP sockets changed with Linux 2.2. Now it specifies the queue length for completely established sockets waiting to be accepted， instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using the tcp_max_syn_backlog sysctl. When syncookies are enabled there is no logical maximum length and this sysctl setting is ignored.</p>
    </blockquote>
  </li>
  <li>当一个请求连接到达(SYN)，TCP根据连接队列中的连接数确认是否接收这个连接。但这时的最大排队连接数并不等于积压值。</li>
  <li>如果连接队列中的连接数少于最大排队的连接数，TCP将确认建立连接。在客户端主动连接成功而服务端应用层还没接收这个连接时，客户端发送的数据将保存在服务端的TCP缓存队列。</li>
  <li>如果连接队列没有空间，TCP将丢弃收到的SYN请求，不发回任何报文(包括RST)。客户端将超时重传SYN请求，等待连接队列有空间。</li>
</ol>

<p>TCP服务器无法使客户端的主动打开失效。因为服务器接收到请求时，TCP的三次握手已经完成。所以对于限定远程IP地址的服务器，必须在客户端三次握手建立连接后才能判断是否合法。</p>

<p><strong>5. TCP的数据流</strong></p>

<p>建立完连接后，两台主机开始进行数据的传输。传输的数据可以分成两种，一种是<strong>交互式数据的传输</strong>，如通过telnet发送指令；一种是<strong>大量数据的传输</strong>，如通过ftp传输文件。TCP显然需要同时能够处理这两种类型的数据，但使用的算法有所不同。</p>

<p><img src="http://blog.chinaunix.net/photo/91603_100717121935.jpg" alt="交互式输入" /></p>

<p>上图为没有优化的字符输入回显的数据传输过程。一共需要四个报文段。</p>

<p>上图第二，三个报文段可以合并—按键确认和按键回显一起发送。这种技术叫做<strong>经受时延的确认</strong>。
通常TCP在接收到数据时并不立即发送ACK，将以不大于TCP定时器的延时等待是否有数据一起发送，有时也称这种现象为<strong>数据捎带ACK</strong>。</p>

<p>ACK延时等待时间不大于TCP定时器的原因：
假如TCP使用200ms的定时器，该定时器将相对于内核引导的200ms固定时间溢出，由于将要确定的数据随机到达，TCP将在下一次内核的200ms定时器溢出时得到通知，所以ACK实际等待的时间为1~200ms中任一刻。</p>

<p><strong>Nagle算法对发送方要求TCP连接上最多只有一个未被确认的未完成小分组</strong>，在该分组确认到达之前不能发送其他的小分组。且同时TCP收集这些小分组，在确认到达后以一个大的分组发出去。
该算法可以减少网络上的微小分组，降低拥塞出现的可能。但相应的，也会增加更多的时延。流程:</p>

<ol>
  <li>发送端TCP将从应用进程接收到的第一数据块立即发送，不管其大小，哪怕只有一个字节。</li>
  <li>发送端输出第一块数据后开始收集数据，并等待确认。</li>
  <li>确认未达到时，若收集数据达到窗口的一半或一个MSS段，立即发送。</li>
  <li>确认到达后，把缓冲区中的数据组成一个TCP段，然后发送。</li>
</ol>

<p><strong>对于成块的数据流，TCP更应该关注的是流量的控制。</strong>发送端有发送缓冲区（即从应用程序到tcp），接收端有接收缓冲区，并不是接收到的数据马上就能被应用程序处理，如果发送端不断地发送数据，而接收端的缓冲区已经被占满，它必须通知发送端在缓冲区有空隙前，请不要再发送数据了。在TCP中，缓冲区被形象地比喻成一个可以滑动的窗口，TCP通过一些算法来根据窗口的大小发送数据，<strong>滑动窗口协议</strong>。这是端到端的。还有另外一种情况，就是，当发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题，一些中间路由器必须缓冲分区，并有可能耗存储器的空间。因此，连接建立时，双方应该慢慢了解去往对方的路况，然后以一个比较合适的速率大小发送块数据。TCP支持一种被称为“<strong>慢启动</strong>”的算法，该算法通过观察到新分组进入网速的速率应该与另一端返回确认的速率相同而进行工作。慢启动为发送方的TCP增加了另一个窗口：<strong>拥塞窗口</strong>，当与另一个网络建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ack，拥塞窗口就增加一个报文段，发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口是接收方使用的流量控制。</p>

<p><strong>PUSH标志：</strong>如果待发送数据会清空发送缓冲区，该包将自动设置PUSH标志。</p>

<ol>
  <li>发送方将发送缓冲区的数据立即发送给接收方。</li>
  <li>接收方将接收缓冲区的数据立即提交给接收进程。</li>
</ol>

<p><strong>6. TCP的超时与重传</strong></p>

<p><img src="http://blog.chinaunix.net/photo/91603_100803210729.jpg" alt="" /></p>

<ul>
  <li>RTT(往返时间)：指发送端发送TCP报文段开始到接收到对方的确定所使用的时间。</li>
  <li>RTO(超时重传时间)：发送端发送TCP报文段后，在RTO时间内没有收到对方确定，即重传该报文段。</li>
</ul>

<p><strong>拥塞避免算法</strong></p>

<p>拥塞避免算法和慢启动算法通常一起使用。维持两个变量：拥塞窗口( cwnd )  慢启动门限( ssthresh )。</p>

<ol>
  <li>对一个给定的连接，初始化cwnd为1个报文段， ssthresh为65535个字节.</li>
  <li>TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小.拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制.前者是发送方感受到的网络拥塞的估计，后者则与接收方在该连接上的可用缓存大小有关.</li>
  <li>当拥塞发生时(超时或收到重复确认)，ssthresh被设置为当前窗口大小的一半(cwnd和接收方通告窗口大小的最小值，但最少为2个报文段).此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动).</li>
  <li>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免.如果cwnd &lt;= ssthresh，则正在进行慢启动，否则正在进行拥塞避免.</li>
</ol>

<p><strong>cwnd增加方式</strong></p>

<ul>
  <li>慢启动初始cwnd为1，每收到一个确定就加1.成指数增长.</li>
  <li>拥塞避免算法在每个RTT内增加 1/cwnd 个报文，成线性增长.</li>
  <li>慢启动根据收到的ACK次数增加cwnd，而拥塞避免算法在一个RTT不管收有多少ACK也只增加一次.</li>
</ul>

<p><strong>快速重传和快速恢复算法</strong></p>

<p>如果收到3个重复ACK，可认为该报文段已经丢失，此时无需等待超时定时器溢出，直接重传丢失的包，这就叫<strong>快速重传算法</strong>.而<strong>接下来执行的不是慢启动而是拥塞避免算法</strong>，这就叫<strong>快速恢复算法</strong>.</p>

<ol>
  <li>当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半.重传丢失的报文段，设置cwnd为ssthresh加上3倍的报文段大小.</li>
  <li>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组(如果新的cwnd允许发送).</li>
  <li>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh(在第1步中设置的值).这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认.另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认.这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半.</li>
</ol>

<p><strong>7. TCP的四个定时器</strong></p>

<p>对每个连接，TCP管理4个不同的定时器：</p>

<ol>
  <li>
    <p><strong>重传定时器</strong>，用于等待另一端的确认。</p>

    <p>当发送端发送出数据后，经过一段时间后假如仍然没有收到接收端的确认，那么就重传该数据块</p>
  </li>
  <li>
    <p><strong>坚持定时器</strong>，使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口</p>

    <p>当接收方的窗口大小为0时，发送方将不能再向它发送数据，直到接收方用一个窗口大小为非0的消息来通告发送端。可是，万一这个消息丢失了呢？接收方就一直这样等着发送方发来数据，而发送端就一直等着接收方发来窗口大于0的消息，两方就都僵在那里了。为了避免这种情况的出现，便有了坚持定时器，<strong>发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。坚持定时器的定时时间也是指数退避的。</strong></p>

    <p><strong>糊涂窗口综合症</strong>是指接收方一旦有非0的窗口大小就向发送方通告，从而引起发送端发送少量的数据这样的情况。可以在任何一方采取措施避免出现这种状况：</p>

    <ol>
      <li>在接收方，接收方不通告小窗口，一般是除非窗口可以增加一个报文段大小或可以增加接收方缓冲区空间的一半，不然通告窗口大小为0.</li>
      <li>在发送方，发送方除非收到一个比较大的窗口（如一个报文段小大、是接收方通告窗口大小一半的报文段）或者是还没有未被确认的数据的情况下，才会发送数据。</li>
    </ol>

    <p>接收方和发送方两方同时进行决策，因为接收方不能通告一个不合理的窗口大小（比方说，原先的窗口大小是1500，报文段长度为1024，发送方发送 了1024字节的数据后，这时候接收方的窗口大小是476，小于一个报文大小，但是如果通告窗口大小为0，岂不是很不合理？），因此在收到这个的窗口通告消息后，就轮到发送方使用它的策略了，发送方设定一个坚持定时器，在这个定时器的时间内，除非收到足够大的通告窗口，否则不发送数据。当然，如果定时器超时了，发送方还是要发送小数据量的报文的。</p>
  </li>
  <li>
    <p><strong>保活定时器</strong>，检测到一个空闲连接的另一端何时崩溃或重启。</p>

    <p>前面我们提到“半打开”的连接，这种情况很可能占用服务器很多端口，因此一般由服务器使用保活选项。如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户主机将必须以下四种状态之一：</p>

    <ol>
      <li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两个小时后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2个小时再复位。</li>
      <li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应，服务器将不能收到对探查的响应，并在75秒后超时。服务器总共发送10个探查，每个间隔75称。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
      <li>客户主机崩溃并且已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li>
      <li>客户主机正常运行，但是从服务器不可达。这跟情况2是一样的。</li>
    </ol>
  </li>
  <li>
    <p><strong>2MSL的时间测量器</strong></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some NB Translations]]></title>
    <link href="http://billowkiller.github.io/blog/2014/07/17/Some-NB-translation/"/>
    <updated>2014-07-17T20:07:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/07/17/Some-NB-translation</id>
    <content type="html"><![CDATA[<ul>
  <li><a href="http://blog.csdn.net/eroswang/article/details/1787456">Unix编程常见问题解答</a></li>
  <li><a href="http://blog.csdn.net/eroswang/article/details/1790351">从程序员角度看ELF</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective C++ Rework]]></title>
    <link href="http://billowkiller.github.io/blog/2014/04/17/Effective/"/>
    <updated>2014-04-17T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/04/17/Effective</id>
    <content type="html"><![CDATA[<h2 id="c">让自己习惯C++</h2>

<h3 id="item-01-view-c-as-a-federation-of-languages">Item 01： View C++ as a federation of languages</h3>

<p>C++同时支持过程形式、面对对象形式、函数形式、泛型形式、元编程形式。</p>

<p>次语言有</p>

<ul>
  <li>C</li>
  <li>Object-Oriented C++</li>
  <li>Template C++</li>
  <li>STL</li>
</ul>

<p>C++高效编程守则视状况而变化，取决于你使用C++的那一部分。</p>

<!--more-->

<h3 id="item-02-prefer-consts-enums-and-inlines-to-defines">Item 02： Prefer consts, enums and inlines to #defines</h3>

<ul>
  <li><code>#define</code>的变量没有进入记号表。并且没有作用域，不能提供任何封装性。</li>
  <li><code>#define</code>定义宏，需要为所有实参加上小括号，且不能够使用<code>++</code>和<code>--</code>。</li>
</ul>

<p><code>#define</code>难以调试、行为无法预料、类型不安全。</p>

<pre><code>class GamePlayer{
private:
	static const int NumTurns = 5; //常量申明式
};
</code></pre>

<p>通常C++要求你对你所使用的任何东西提供一个定义式，但那如果它是<code>class</code>专属常量又是<code>static</code>且为<strong>整数型</strong>(ints, chars, bools)则需特殊处理。只要是不取它们的地址，你可以申明并使用它们而无需提供定义式。如果需要取址，必须提供定义式：</p>

<pre><code>const int GamePlayer::NumTurns; //申明时获取了初值，定义不必赋值
</code></pre>

<p>“The enum hack”表示一个属于枚举类型的数值可权充int被使用，于是<code>GamePlayer</code>定义为</p>

<pre><code>class GamePlayer{
private:
	enum { NumTurns = 5 };
	static const int NumTurns = 5;
};
</code></pre>

<ul>
  <li>取一个<code>enum</code>地址是非法的。<code>enum</code>和<code>#define</code>一样不会导致非必要的内存分配。</li>
  <li><code>enum hack</code>是<code>template metaprogramming</code>的基础技术。</li>
</ul>

<p><code>template inline</code>可以提供宏带来的效率以及一般函数的所有可预料行为和类型安全。遵守作用域和访问规则。</p>

<h3 id="item-03-use-const-whenever-possible">Item 03： Use const whenever possible</h3>

<p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而不至于放弃安全性和高效性。</p>

<pre><code>const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs);
Rational a, b, c;
...
(a * b) = c;  //错误
</code></pre>

<p>重载<code>operator[]</code>并对不同的版本给予不同的返回类型，就可以令<code>const</code>和<code>non-const</code>获得不同的处理。返回 <code>char&amp;</code>也是必要的。</p>

<pre><code>const char&amp; operator[](std::size_t position) const; //operator[] for const Object
char&amp; operator[](std::size_t position); //operator[] for non-const object
</code></pre>

<ul>
  <li>成员函数式<code>const</code>有两个流行的概念：<code>bitwise constness</code>, <code>logical constness</code>。</li>
  <li><code>mutable</code>变量成员可以再const成员函数中改变。</li>
  <li><code>static_cast</code>将<code>non-const</code>对象转为<code>const</code>对象。<code>const_cast</code>相反。</li>
</ul>

<h3 id="item-04-make-sure-that-objects-are-initialized-before-theyre-used">Item 04： Make sure that objects are initialized before they’re used</h3>

<ul>
  <li><code>C++</code>对定义与不同编译单元(文件)内的<code>non-local static</code>对象的初始化次序并无明确定义。</li>
  <li>函数内的<code>local static</code>对象会在该函数被调用期间首次遇上该对象的定义式时被初始化。</li>
</ul>

<p>为内置对象进行手工初始化，<code>C++</code>不保证初始化它们。
构造函数使用<code>成员初值列</code>，不要在函数内使用赋值操作。其排列次序应该和申明次序相同。
为免除跨编译单元初始化次序问题。以<code>local static</code>对象替代<code>non-local static</code>对象。</p>

<h2 id="constructors-destructors-and-assignment-operators">Constructors, destructors, and Assignment Operators</h2>

<h3 id="item-05-know-what-functions-c-silently-writes-and-calls">Item 05： Know what functions C++ silently writes and calls</h3>

<ul>
  <li><code>default</code>构造函数和析构函数调用<code>base classes</code>和<code>non-static</code>成员变量的构造函数和析构函数。且只有base是<code>virtual</code>析构时，它才是<code>virtual</code>的。</li>
  <li>如果类内含<code>reference</code>或<code>const</code>成员，或者<code>base classes</code>将<code>copy assignment</code>操作符申明为<code>private</code>，则需要自己定义<code>copy assignment</code></li>
</ul>

<h3 id="item-06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want">Item 06: Explicitly disallow the use of compiler-generated functions you do not want</h3>

<p>不实现<code>copy</code>或<code>copy assignment</code>的方法：</p>

<ol>
  <li>将成员函数声明为private而且故意不实现它们。</li>
  <li>设计一个专门为了组织copying动作的<code>base class</code>， 将<code>copy</code>和<code>copy assigment</code>声明为<code>private</code>。接着私有继承base class</li>
  <li><code>Boost</code>提供的class，<code>nonecopyable</code></li>
</ol>

<h3 id="item-07-declare-destructors-virtual-in-ploymorphic-base-classes">Item 07: Declare destructors virtual in ploymorphic base classes</h3>

<pre><code>Base *pt = new Derived;
delete pt;
</code></pre>

<p><code>derived class</code>对象经由一个<code>base class</code>指针被删除，如果<code>base class</code>有个<code>non-virtual</code>析构函数，则对象的<code>derived</code>成分没被销毁。</p>

<p>无端地将所有classes的析构函数声明为<code>virtual</code>，就像从未声明它们为<code>virtual</code>一样，都是错误的，带来对象体积的增加。只有当class内含有至少一个<code>virtual</code>函数才为它声明<code>virtual</code>析构函数。</p>

<p>为你希望它成为抽象的那个class(polymorphic base classes)声明一个<code>pure virtual</code>析构函数。</p>

<pre><code>class AWOV {
public:
	virtual  ~AWOV() = 0;
};
AWOV::~AWOV() {}  //pure virtual 析构函数的定义 
</code></pre>

<p>然而必须为这个<code>pure virtual</code>函数提供一份定义，根据析构函数的运作方式，编译器会在AWOV的<code>derived classes</code>的析构函数中创建一个对~AWOV的调用动作，所以必须为这个函数提供一份定义。否则，连接器会发出抱怨。</p>

<h3 id="item-08-prevent-exceptions-from-leaving-destructors">Item 08: Prevent exceptions from leaving destructors</h3>

<ul>
  <li>析构函数绝对不要突出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li>
  <li>如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>

<h3 id="item-09-never-call-virtual-functions-during-construction-or-destruction">Item 09: Never call virtual functions during construction or destruction</h3>

<p><strong>在base class构造期间，virtual函数不是virtual函数</strong>。因为derived class对象还未构造好，所以base class构造期间virtual函数绝不会下降到derived classes阶层。在derived class对象的base class构造期间，对象类型是base class而不是derived class。</p>

<p>在构造期间，可以借由“令derived classes将必要的构造信息向上传递至base class构造函数”替换之。</p>

<p><strong>同样的道理也适用于析构函数</strong>。一旦derived class析构函数开始执行，对象内的derived class成员变量变成未定义值，所以C++是它们仿佛不再存在。进入base class析构函数后对象就称为一个base class 对象，而C++的任何部分包括virtual函数、<code>dynamic_cast</code>等等也就这么看它。</p>

<p>所以，在构造和析构席间不要调用virtual函数，因为这类调用从不降至derived class（比起当前执行构造函数和析构函数的那层）。</p>

<h3 id="item-10-have-assignment-operators-return-a-reference-to-this">Item 10: Have assignment operators return a reference to *this</h3>

<pre><code>Widget&amp; operator=(const widget &amp;rhs) {
	...
	return *this;
}
</code></pre>

<h3 id="item-11-handle-assignment-to-self-in-operator">Item 11: Handle assignment to self in operator=</h3>

<p>容易掉进“在停止使用资源之前意外释放了它”的陷阱。</p>

<p>让<code>operator=</code>具备“异常安全性”往往自动获得“自我复制安全”的汇报。</p>

<pre><code>Widget&amp; operator=(const widget &amp;rhs) {
	Bitmap * pOrig = pb;
	pb = new Bitmap(*rhs.pb);
	delete pOrig;
	return *this;
}
</code></pre>

<p>还可以使用<code>copy and swap</code>技术。或利用一下事实：(1)某class的<code>copy assignment</code>操作符可能被声明<code>by value</code>的方式；(2)以<code>by value</code>的方式传递东西会造成一份副本。</p>

<h3 id="item-12-copy-all-parts-of-an-object">Item 12: Copy all parts of an object</h3>

<ul>
  <li>编写一个copying函数确保(1)复制所有local成员变量，(2)调用所有base classes内的适当的copy函数。</li>
  <li>不要尝试以某个copying函数实现另一个copying函数。应该讲共同机能放进第三个函数中，并有两个copying函数共同调用。</li>
</ul>

<h2 id="section">资源管理</h2>

<h3 id="item-13-use-objects-to-manage-resources">Item 13: Use objects to manage resources.</h3>

<ul>
  <li>获得资源后立即放进资源对象内。<code>RAII</code>–Resource Acquisition Is initialization</li>
  <li>管理对象运用析构函数确保资源被释放。</li>
  <li>auto_ptr通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得到的指针将取得资源的唯一拥有权。</li>
  <li>动态分配得到的<code>array</code>身上使用auto_ptr或tr1::shared_ptr是个馊主意。两者再析构函数内做delete而不是delete[]动作。</li>
</ul>

<h3 id="item-14-think-carefully-about-copying-behavior-in-resource-managing-classes">Item 14: Think carefully about copying behavior in resource-managing classes</h3>

<p>当一个RAII对象被复制，考虑两种可能性：</p>

<ul>
  <li>禁止复制</li>
  <li>对底层资源采用<code>引用计数法</code>， 
    <ul>
      <li><code>shared_ptr</code>的缺省行为是“当引用次数为0时删除其所指之物”，允许制定特定的删除器(<code>deleter</code>)</li>
    </ul>
  </li>
  <li>复制底部资源</li>
  <li>转移底部资源的拥有权</li>
</ul>

<h3 id="item-15-provide-access-to-raw-resources-in-resource-managing-classes">Item 15: Provide access to raw resources in resource-managing classes</h3>

<p>智能指针重载了指针取值操作符(operator-&gt; 和 operator*)，它们允许隐式转换至底部原始指针。</p>

<p>隐式转换举例：</p>

<pre><code>class Font {
public:
	...
	operator FontHandle() const //隐式转换函数
	{ return f; }
	...
}
</code></pre>

<ul>
  <li>API往往要求访问原始资源，所以每个RAII class应该提供一个取得原始资源的方法。</li>
  <li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐私转换对客户比较方便。</li>
</ul>

<h3 id="item-16-use-the-same-form-in-corresponding-uses-of-new-and-delete">Item 16: Use the same form in corresponding uses of new and delete</h3>

<p>new对应delete，new[] 对应delete[]</p>

<p>对于typedef,必须要在程序中说明清楚</p>

<pre><code>typedef std::string AddressLines[4];
std::string * pal = new AddressLines;
delete [] pal; //delete pal 导致行为未有定义 因此，最好尽量不要对数组形式做typedef动作。
</code></pre>

<h3 id="item-17-store-newed-objects-in-smart-pointers-in-standalone-statements">Item 17: Store newed objects in smart pointers in standalone statements.</h3>

<p>假设有个函数解释处理程序的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p>

<pre><code>int priority();
void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);
</code></pre>

<p>如果这样调用</p>

<pre><code>processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); 编译器创建代码，做以下三件事：
</code></pre>

<ul>
  <li>调用priority</li>
  <li>执行new Widget</li>
  <li>调用tr1::shared_ptr构造函数。</li>
</ul>

<p>只能保证new Widget在shared_ptr构造函数之前被调用。如果priority在两者中间被调用，而且导致异常。那么new Widget返回的指针将会遗失。</p>

<h2 id="section-1">设计与声明</h2>

<h3 id="item-18-make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly">Item 18: Make interfaces easy to use correctly and hard to use incorrectly</h3>

<ul>
  <li>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
  <li>“促进正确使用”的办法包括借口的一致性，以及与内置类型的行为兼容。任何接口如果要求客户必须记得做某些事情，就是有着“不正确使用”的倾向，因为客户可能会忘记做那件事。</li>
  <li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
  <li>tr1::shared_ptr支持定制性删除器(custom deleter)。可以防范<code>cross-DLL problem</code>(在一个DLL中被new创建，却在另一个DLL中被delete销毁)，自动解除互斥锁等等。</li>
</ul>

<h3 id="item-20-prefer-pass-by-reference-to-const-to-pass-by-value">Item 20: Prefer pass-by-reference-to-const to pass-by-value.</h3>

<ul>
  <li>尽量以<code>pass-by-reference-to-const</code>替换<code>pass-by-value</code>。前者通常比较高效，并可以避免切割问题。</li>
  <li>以上规则并不适用于<strong>内置类型，以及STL的迭代器和函数对象</strong>。对它们而言，pass-by-value往往比较适当。</li>
</ul>

<h3 id="item-21-dont-try-to-return-a-reference-when-you-must-return-an-object">Item 21: Don’t try to return a reference when you must return an object</h3>

<p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</p>

<h3 id="item-22-declare-data-members-private">Item 22: Declare data members private.</h3>

<ul>
  <li>封装的重要性比你最初见到它时还要重要</li>
  <li>切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
  <li>protected并不比public更具有封装性。</li>
</ul>

<h3 id="item-23-prefer-non-member-non-friend-functions-to-member-functions">Item 23: Prefer non-member non-friend functions to member functions</h3>

<ul>
  <li>提供更大的封装性</li>
  <li>比较自然的做法是让 non-member non-friend函数作为便利函数位于类所在的同一个namespace内。并将同类便利函数声明放在同一头文件中。</li>
  <li>将所有便利函数放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组便利函数。</li>
</ul>

<h3 id="item-24-declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters">Item 24: Declare non-member functions when type conversions should apply to all parameters</h3>

<pre><code>class Rational {
public:
	const Rational operator* (const Rational &amp;rhs) const;
};

Rational oneHalf(1, 2);
result = oneHalf * 2; // oneHalf.operator*(2)，可以执行
result = 2 * oneHalf; // 2.operator*(oneHalf)，错误
</code></pre>

<p>所以让函数称为一个<code>non-member</code>函数</p>

<pre><code>const Rational operator* (const Rational &amp;lhs， const Rational &amp;rhs);	 允许编译器在每一个实参身上执行隐私转换类型。
</code></pre>

<h3 id="item-25-consider-support-for-a-non-throwing-swap">Item 25: Consider support for a non-throwing swap</h3>

<pre><code>namespace std {
	template&lt;&gt; //全特化
	void swap&lt;Widget&gt;( Widget &amp;a, Widget &amp;b) {
		swap(a.pImpl, b.pImpl); //私有变量，编译不通过，需要创建类的成员函数
	} }

class Widget {
public:
	void swap(Widget&amp; other) {
		using std::swap; //声明是有必要的，下个swap调用std版本的
		swap(pImpl, other.pImpl);
</code></pre>

<ul>
  <li>当<code>std::swap</code>对你的类型效率不高时，提供一个<code>swap</code>成员函数，并确定这个函数不抛出异常</li>
  <li>如果你提供一个<code>member swap</code>，也应该提供一个<code>non-member swap</code>用来调用前者。对于classes（而非templates），也请特化<code>std::swap</code></li>
  <li>调用<code>swap</code>时应针对<code>std::swap</code>使用<code>using</code>声明式，然后调用<code>swap</code>并且不带任何“命名空间资格修饰”。</li>
  <li>为“用户定义类型”进行<code>std templates</code>全特化是好的，但千万不要尝试在<code>std</code>内加入某些对<code>std</code>而言是全新的东西</li>
</ul>

<h2 id="section-2">实现</h2>

<h3 id="item-26-postpone-variable-definitions-as-long-as-possible">Item 26: Postpone variable definitions as long as possible</h3>

<p>不止应该延后变量的定义，这道非得使用该变量的前一刻为止，甚至应该尝试延后这份定义知道能够给它初值实参为止。</p>

<h3 id="item-27-minimize-casting">Item 27: Minimize casting</h3>

<ul>
  <li><code>const_cast</code>被用来将对象的常量性转除，也是唯一有此能力的c++ style转型操作符</li>
  <li><code>dynamic_cast</code>主要用来执行“safe downcasting”，可能需要耗费重大运行成本。</li>
  <li><code>reinterpret_cast</code>执行低级转型，实际动作及结果可能取决于编译器，也就表示它不可移植。</li>
  <li><code>static_cast</code>用来强迫隐式转换。例如将non-const转为const对象，将int转为double。</li>
</ul>

<p>单一对象(例如一个类型为Derived的对象)<code>可能拥有一个以上的地址</code>(例如“以Base* 指向它”时的地址和“以Derived* 指向它”时的地址)。这至少意味着你通常应该避免作出“对象在C++中如何布局”的假设。</p>

<ul>
  <li>如果可以，尽量避免转型，特别是在注重效率的代码中避免<code>dynamic_cast</code>。如果有个设计需要转向动作，试着发展无需转型的替代设计。</li>
  <li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li>
  <li>宁可使用C++ style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li>
</ul>

<h3 id="item-28-avoid-returning-handles-to-object-internals">Item 28: Avoid returning “handles” to object internals</h3>

<p>避免返回handles(包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生dangling handles的可能性降至最低。</p>

<p>考虑一个例子：</p>

<pre><code>const Point&amp; Rectangle::upperLeft() const { return pData-&gt;ulhc; }	

class GUIObject{};
const Rectangle boundingBox(const GUIObject &amp;obj);

GUIObject *pgo;
const Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft()); //指向一个不存在的对象
</code></pre>

<h3 id="item-29-strive-for-exception-safe-code">Item 29: Strive for exception-safe code.</h3>

<ul>
  <li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分三种可能的保证：基本型、强烈型、不抛异常型。</li>
  <li>强烈保证往往能够以copy-and-swap实现出来，但强烈保证并非对所有函数都可实现或具备现实意义。</li>
  <li>函数提供的异常安全保证通常最高只等于其所调用之各个函数的异常安全保证中的最弱者。</li>
</ul>

<h3 id="item-30-understand-the-ins-and-outs-of-inlining">Item 30: Understand the ins and outs of inlining</h3>

<p><code>inline</code>只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。隐喻方式是将函数定义于class定义内：</p>

<pre><code>class Person {
public:
	int age() const { return theAge; } //隐喻的inline申请
private:
	int the Age;
};
</code></pre>

<p>这样的函数通常是成员函数，<code>friend</code>函数也可以被定义于class内，这样它们也是被隐喻为<code>inline</code>。</p>

<p><code>inline</code>和<code>template</code>函数通常都被定义于头文件内。</p>

<pre><code>inline void f() {}
void ( * pf )() = f;
f(); //这个调用将被inlined
pf(); //或许不被inlined，因为它通过函数指针达成。
</code></pre>

<ul>
  <li><code>inline</code>函数无法随着程序库升级而升级。调用<code>inline</code>函数的程序都必须重新编译。</li>
  <li>大部分调试器面对<code>inline</code>函数都束手无策。</li>
</ul>

<h3 id="item-31-minimize-compilation-dependencies-between-files">Item 31: Minimize compilation dependencies between files</h3>

<p>以<code>声明的依存性</code>替换<code>定义的依存性</code>：</p>

<ul>
  <li>如果使用<code>object reference</code>或<code>object pointers</code>可以完成任务，就不要使用objects。</li>
  <li>如果能够，尽量以class<code>声明式</code>替换class<code>定义式</code>。 </li>
  <li>为声明式和定义式提供不同的头文件。这种方法无论是否涉及templates都适用。
    <ul>
      <li>
        <iosfwd>内含iostream各组件的声明式，包括<sstream>, <streambuf>, <fstream>和<iostream>



</iostream></fstream></streambuf></sstream></iosfwd>
      </li>
    </ul>
  </li>
</ul>
<p>##继承和面向对象设计</p>

<h3 id="item-32-make-sure-public-inheritance-models-is-a">Item 32: Make sure public inheritance models “is-a”</h3>

<h3 id="item-33-avoid-hiding-inherited-names">Item 33: Avoid hiding inherited names</h3>

<pre><code>class Base {
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
	virtual void mf2();
	void mf3();
	void mf3(double);
};

class Derived: public Base {
public:	
	using Base::mf1;  //让base class内名为mf1和mf3的所有东西
	using Base::mf3;  //在Derived作用域内都可见
	virtual void mf1();
	void mf3();
};	

//或者
class Derived: private Base {
public:
	virtual void mf1() { Base::mf1(); }  //转交函数，暗自称为inline
};
</code></pre>

<ul>
  <li>derived class内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。
    <ul>
      <li>上述规则对不同参数类型也适用，而且不论函数式virtual或non-virtual。</li>
    </ul>
  </li>
  <li>为了让被遮掩的名称再见天日，可使用using声明式或转变函数。</li>
</ul>

<h3 id="item-34-differentiate-between-inheritance-of-interface-and-inheritance-of-implementation">Item 34: Differentiate between inheritance of interface and inheritance of implementation</h3>

<ul>
  <li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li>
  <li>pure virtual函数只具体指定接口继承。pure virtual函数必须在derived classes中重新声明，但它们也可以拥有自己的实现。</li>
  <li>简朴的impure virtual函数具体指定接口继承及缺省实现继承。</li>
  <li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>

<h3 id="item-35-consider-alternatives-to-virtual-functions">Item 35: Consider alternatives to virtual functions</h3>

<p>当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案。</p>

<ul>
  <li>使用non-virtual interface（NVI）手法，那是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected)的virtual函数, wrapper。</li>
  <li>将virtual函数替换为函数指针成员变量，这是Strategy设计模式的一种分解表现形式。</li>
  <li>以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物(callable entity)搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。</li>
  <li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。</li>
</ul>

<h3 id="item-36-never-redefine-an-inherited-non-virtual-function">Item 36: Never redefine an inherited non-virtual function</h3>

<p>non-virtual是静态绑定，调用的方法是静态类型所拥有的方法，而不是实际类型所拥有的方法。</p>

<h3 id="item-37-never-redefine-a-functions-inherited-default-parameter-value">Item 37: Never redefine a function’s inherited default parameter value</h3>

<p>virtual函数是动态绑定，而缺省参数值确实静态绑定。静态绑定为early binding，动态绑定为late binding。即使子类重新定义了virtual函数的缺省参数，调用还是用了父类的缺省参数。这是为了运行期效率。如果缺省参数值是动态绑定，编译器就必须有某种办法在运行期间为virtual函数决定适当的缺省参数值。</p>

<p>可以使用NVI（non-virtual interface）手法：</p>

<pre><code>class Shape {
public:
	enum ShapeColor { Red, Green, Blue};
	void draw(ShapeColor color = Red) const {
		doDraw(color);
	}
private:
	virtual void doDraw(ShapeColor color) const = 0;//真正的工作在此处
}；
class Rectangle: public Shape {
public:
	...
private:
	virtual void doDraw(ShapeColor color) const; //不须制定缺省参数值
};
</code></pre>

<h3 id="item-39-use-private-inheritance-judiciously">Item 39: Use private inheritance judiciously</h3>

<ul>
  <li>编译器不会自动将一个derived class对象转换为一个base class对象。</li>
  <li>由private base class继承而来的所有成员，在derived class 中都会变成private 属性。</li>
  <li>private继承在软件设计层面没有意义，只有在软件实现层面有意义。</li>
  <li>Private继承意味is-implemented-in-terms of(根据某物实际出)。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。
和</li>
  <li>复合不同，private继承可以造成empty base最优化。这对致力于对象尺寸最小化的程序库开发者而言，可能很重要。</li>
</ul>

<p>怎样阻止derived classes重新定义virtual函数？</p>

<pre><code>class Widget {
private:
	class WidgetTimer: public Timer {
	public:
		virtual void onTick() const;
	};
	WidgetTimer timer;
};
</code></pre>

<p>私有继承空类并不继承空类的空间</p>

<pre><code>class Empty {}; //sizeof Empty == 1;
class HoldsAnInt: private Empty { int x; }; //sizeof HoldsAnInt == 4;
</code></pre>

<h3 id="item-40-use-multiple-inheritance-judiciously">Item 40: Use multiple inheritance judiciously</h3>

<ul>
  <li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
  <li>virtual继承会增加大小、速度、</li>
  <li>初始化（及赋值）复杂度等等成本。如果virutal base classes不带任何数据，将是最具使用价值的情况。Java和.Net的Interfaces指的注意，它在许多方面兼容于C++的virtual base classes，而且也不允许含有任何数据。</li>
  <li>多重继承的确有正当用途。其中一个情节涉及public继承某个Interface class和private继承某个协助实现的class的两相结合。</li>
</ul>

<h2 id="section-3">模版与泛型编程</h2>

<h3 id="item-41-understand-implicit-interfaces-and-compile-time-polymorphism">Item 41: Understand implicit interfaces and compile-time polymorphism</h3>

<ul>
  <li>classes和templates都支持接口和多态。</li>
  <li>对classes而言接口是显示的，以数字签名为中心。多态则是通过virtual函数发生于运行期。</li>
  <li>对template参数而言，接口是隐式的，奠基于<strong>有效表达式</strong>。多态则是通过template具现化和函数重载解析发生于编译器。</li>
</ul>

<h3 id="item-42-understand-the-two-meanings-of-typename">Item 42: Understand the two meanings of typename.</h3>

<p>在template声明式中，<code>class</code>和<code>typename</code>不一定相同。</p>

<pre><code>template&lt;typename C&gt;
void print2nd(const C&amp; container) {
	if(container.size() &gt;= 2) {
		C::const_iterator iter(container.begin());
		++iter;
		int value = *iter;
	{
}
</code></pre>

<p><code>iter</code>的类型是<code>C::const_iterator</code>，实际是什么值取决于<code>template</code>参数<code>C</code>。<code>template</code>内出现的名称如果相依于某个<code>template</code>参数，称之为从属名称。如果从属名称在<code>class</code>内呈嵌套状，我们称它为嵌套从属名称。<code>C::const_iterator</code>就是这样的一个名称。而<code>value</code>的类型<code>int</code>并不依赖<code>template</code>参数的名称，称之为非从属名称。<strong>在缺省情况下，嵌套从属名称不是类型</strong>。</p>

<p>改为<code>typename C::const_iterator iter(container.begin());</code>。</p>

<p>一种特列情况为，<code>typename</code>不可以出现在<code>base classes list</code>内的嵌套从属类型名称之前，也不可以在<code>member initialization list</code>中作为<code>base class</code>修饰符。</p>

<pre><code>template&lt;typename T&gt;
class Derived: public Base&lt;T&gt;::Nested {
public:
	explict Derived(int x): Base&lt;T&gt;::Nested(x) {
		typename Base&lt;T&gt;::Nested temp;
	}
};

最后一个例子：
template&lt;typename IterT&gt;
void workWithIterator(IterT iter) {
	typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter);
}
</code></pre>

<h3 id="item-43-know-how-to-access-names-in-templatized-base-classes">Item 43: Know how to access names in templatized base classes</h3>

<p>当我们从<code>Object Oriented C++</code>进入<code>Template C++</code>，继承就不像以前那般顺利。编译器知道<code>base class templates</code>有可能被特化，而那个特化版本可能不提供和一般性template相同的接口，因而它往往拒绝在<code>templatized base classes</code>内寻找继承而来的名称。</p>

<pre><code>template&lt;typename Company&gt;
class LoggingMsgSender: public MsgSender&lt;Company&gt; {
public:
	void sendClearMsg(const MsgInfo* info) {
		sendClear(info);  //调用base class函数；这段代码无法通过编译
	}
};
</code></pre>

<p>基类<code>MsgSender&lt;Company&gt;</code>的特化版本，可能不提供<code>sendClear()</code>方法。</p>

<p>解决方法：</p>

<ol>
  <li>base class函数调用动作之前加上<code>this-&gt;</code></li>
  <li>在函数前使用using声明式，<code>using MsgSender&lt;Company&gt;::sendClear</code>.</li>
  <li>直接使用<code>MsgSender&lt;Company&gt;：：sendClear(info)</code>。</li>
</ol>

<p>第三种做法有缺陷，如果被调用的是<code>virtual</code>函数，上述的做法会关闭<code>virtual绑定行为</code>。</p>

<h3 id="item-44-factor-parameter-independent-code-out-of-templates">Item 44: Factor parameter-independent code out of templates.</h3>

<ul>
  <li>Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li>
  <li>因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
  <li>因类型参数而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述的具现类型共享实现码。</li>
</ul>

<p>template &lt;T*&gt;可以改为<code>tempalte&lt;void*&gt;</code>减少代码膨胀。</p>

<h3 id="item-45-use-member-function-templates-to-accept-all-compatible-types">Item 45: Use member function templates to accept “all compatible types”</h3>

<p>如果以带有<code>base-derived</code>关系的B，D两类型分别具现化某个template，产生出来的两个具现体并不带有<code>base-derived</code>关系。</p>

<pre><code>template&lt;typename T&gt;
class SmartPtr {
public:
	tempalte&lt;typename U&gt; //member template, 为了生成copy构造函数
	SmartPtr(const SmartPtr&lt;U&gt;&amp; other); 
};
</code></pre>

<p>这一类构造函数根据SmartPtr&lt;U&gt;创建一个Smart&lt;T&gt;。未加上<code>explicit</code>是因为原始指针类型之间的转换（例如从derived转化base）是隐式转换。可以在构造模板实现代码中约束行为：</p>

<pre><code>template&lt;typename T&gt;
class SmartPtr {
public:
	tempalte&lt;typename U&gt; //以other的heldPtr初始化this的heldPtr
	SmartPtr(const SmartPtr&lt;U&gt;&amp; other):heldPtr(other.get()) {}
	T * get() const { return heldPtr; }
private:
	T* heldPtr; 
};
</code></pre>

<p>成员函数模板的效用不限于构造函数，它们常扮演的另一个角色是支持赋值操作。</p>

<pre><code>template&lt;typename T&gt;
class shared_ptr {
public:
	template&lt;class Y&gt;
	explicit shared_ptr(Y* p);
	template&lt;class Y&gt;
	shared_ptr(shared_ptr&lt;Y&gt; const&amp; r);
	template&lt;class Y&gt;
	explicit shared_ptr(weak_ptr&lt;Y&gt; const&amp; r);
	template&lt;class Y&gt;
	explicit shared_ptr(auto_ptr&lt;Y&gt; const&amp; r);
	template&lt;class Y&gt;
	shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r);
	template&lt;class Y&gt;
	shared_ptr&amp; operator=(auto_ptr&lt;Y&gt; &amp; r);
};
</code></pre>

<p>上述函数的<code>explict</code>表示从某个shared_ptr类型隐式转换至另一个shared_ptr类型是被允许的，但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可。auto_ptr不声明const是因为复制一个auto_ptr，它其实被改动了。</p>

<p>在class内声明泛化copy构造函数并不会阻止编译器生成它们自己的copy构造函数。</p>

<h3 id="item-46-define-non-member-functions-inside-templates-when-type-conversions-are-desired">Item 46: Define non-member functions inside templates when type conversions are desired.</h3>

<p>将Item24的例子改为模板：</p>

<pre><code>template&lt;typename T&gt;
class Rational {
public:
	Rational(const T&amp; numerator = 0, const T&amp; denominator = 1);
	
	template&lt;typename T&gt;
	const Rational&lt;T&gt; operator* (const Rational&lt;T&gt; &amp;rhs, const Rational&lt;T&gt; &amp;rhs);
};

Rational oneHalf(1, 2);
result = oneHalf * 2; // 无法通过编译，不加模板则可以
</code></pre>

<p>这是因为template实参推导过程中从不将隐式类型转换函数考虑在内。可以改为如下：</p>

<pre><code>friend const Rational operator* (const Rational &amp;rhs, const Rational &amp;rhs); //省略了&lt;T&gt;
</code></pre>

<p>当对象oneHalf被声明为一个Rational<int>, 模板被具现化出来，而作为过程的一部分friend函数（接受Rational<int> 参数）也就自动声明出来，后者作为一个函数而非函数模板，因此编译器可以在调用它时使用隐式转换函数。</int></int></p>

<h3 id="item-47-use-traits-classes-for-information-about-types">Item 47: Use traits classes for information about types</h3>

<p>``` c++
//define traits’ type
struct bidirectional_iterator_tag: public forward_iterator_tag { };</p>

<p>//functional class, contain iterator
template&lt;…&gt;
class list {
public:
    class iterator {
        typedef bidirectional_iterator_tag iterator_category;
    };
};</p>

<p>//partial template specialization
template<typename itert="">
struct iterator_traits {
    typedef IterT::iterator_category iterator_category;
};</typename></p>

<p>template&lt;typename IterT*&gt;
struct iterator_traits {
    typedef IterT::iterator_category iterator_category;
};</p>

<p>//overloading to do compiling verdict
template&lt;typename IterT, typename DistT&gt;
doAdvance(IterT &amp;iter, DistT d, std::bidirectional_iterator_tag) {
    …
}</p>

<p>template&lt;typename IterT, typename DistT&gt;
doAdvance(IterT &amp;iter, DistT d, std::forward_iterator_tag) {
    …
}</p>

<p>//specific function for iterator, advance
//judge the types for information
template&lt;typename IterT, typename DistT&gt;
void advance(IterT &amp;iter, DistT d) {
    doAdvance(iter, d, typename iterator_traits<itert>::iterator_category());
}
```</itert></p>

<h2 id="newdelete">定制new和delete</h2>

<h3 id="item-49-understand-the-behavior-of-the-new-handler">Item 49: Understand the behavior of the new-handler.</h3>

<p>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时候被调用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inside C++ Object]]></title>
    <link href="http://billowkiller.github.io/blog/2014/04/12/Inside-Object/"/>
    <updated>2014-04-12T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/04/12/Inside-Object</id>
    <content type="html"><![CDATA[<p>modified from <a href="http://blog.csdn.net/eroswang/article/details/1749609">http://blog.csdn.net/eroswang/article/details/1749609</a></p>

<hr />

<h2 id="ooob">面对对象（OO）和基于对象（OB）</h2>

<p>基于对象的数据类型可以展示封装的非多态形式，但是不支持类型的扩充。一个OB设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数引发操作都在编译时期解析完成，对象建构起来时不需要设置virtual机制；空间紧凑则是因为每一个class object不需要负担传统上为了支持virtual机制而需要的额外符合。不过，OB设计比较没有弹性。 </p>

<h2 id="c">C++对象模型</h2>

<p>在C++中，有两种<strong>class data members：static和nonstatic</strong>，以及三种<strong>class member functions：static、nonstatic和virtual</strong>。</p>

<p>Nonstatic data members被配置于每一个class object之内，static data members则被存放在所有的class object之外。Static和nonstatic function members也被放在所有的class object之外，Virtual functions则以两个步骤支持之：</p>

<ul>
  <li>每一个class产生出一堆指向virtual functions的指针，放在表格之中，这个表格被称为<strong>virtual table（vtbl）</strong>。每一个class所关联的type_info object（用以支持<strong>runtime type identification，RTTI</strong>）也经由virtual table被指出来，通常是放在表格的第一个slot处。</li>
  <li>每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为<strong>vptr</strong>。</li>
</ul>

<!--more-->

<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/arthurkingios/1.JPG" alt="" /></p>

<p><strong>重置vptr：</strong></p>

<p>假设Bear继承于ZooAnimal，如下所示：</p>

<pre><code>Bear b;
ZooAnimal za = b;  // 这会引起切割（sliced）
// 调用 ZooAnimal::rotate()
za.rotate();
</code></pre>

<p><strong>为什么rotate所调用的是ZooAnimal实体而不是Bear实体？</strong></p>

<p>ZooAnimal class object以另一个ZooAnimal class object作为初值，或Bear class object以另一个Bear class object作为初值，都可以直接靠bitwise copy semantics完成（剔除pointer member情况）
。</p>

<p>而当一个base class object以其derived class object内容做初始化操作时，其vptr复制操作也必须保证其安全。编译器必须确保如果某个object含有一个或一个以上的vptrs，那些vptrs的内容不会被base class object初始化改变。</p>

<h2 id="constructor">Constructor的建构操作</h2>

<h3 id="default-constructor">Default Constructor的建构操作</h3>

<p>default constructor仅在编译器需要它时，才会被合成出来。
通常来说，由编译器合成出来的default constructor是没啥用的（trivial），但有以下几种例外：</p>

<ol>
  <li>
    <p>带有“Default Constructor”的Member Class Object</p>

    <p>如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么编译器会在constructor真正需要被调用时未此class合成一个“nontrivial”的default constructor。</p>

    <p>为了避免合成出多个default constructor，解决方法是把合成的default constructor、copy constructor、destructor、assignment copy operator都以inline方式完成。一个inline函数有静态链接（static linkage），不会被档案以外者看到。如果函数太复杂，不适合做成inline，就会合成出一个explicit non-inline static实体。</p>
  </li>
  <li>“带有Default Constructor”的Base Class</li>
  <li>“带有一个Virtual Function”的Class
    <ul>
      <li>class声明（或继承）一个virtual function</li>
      <li>class派生自一个继承串链，其中有一个或更多的virtual base classes</li>
    </ul>
  </li>
  <li>
    <p>“带有一个virtual Base Class”的Class</p>

    <p>编译器需要在derived class object中为每一个virtual base classes安插一个指针，使得所有“经由reference或pointer来存取一个virtual base class”的操作可以通过相关指针完成。</p>
  </li>
</ol>

<p><strong>总结：</strong>
被合成出来的constructor只能满足编译器（而非程序）的需要。
没有存在着四种情况而又没有声明任何constructor的classes，它们拥有的是implicit trivial default constructor，实际上并不会被合成出来。</p>

<p>在合成的default constructor中，只有base class subobjects和member class objects会被初始化，所有其它的nonstatic data member，如整数、整数指针，整数数组等都不会被初始化。</p>

<p><strong>一般会对dafult constructor有两个误解：</strong></p>

<ol>
  <li>任何class如果没有定义default constructor，就会被合成出来。</li>
  <li>编译器合成出来的default constructor会明确设定“class内每一个data memeber”的默认值。</li>
</ol>

<h3 id="copy-constructor">Copy Constructor的建构操作</h3>

<p>有三种情况会以一个object的内容作为另一个class object的初值，即<strong>object赋值、object参数传递、object作为函数返回值</strong>。</p>

<p>如果class没有提供一个explicit copy constructor，其内部是以所谓的default memberwise initialization手法完成的，也就是把每一个内建的或派生的data member（例如一个指针或一个数组）的值，从某个object拷贝一份到另一个object身上，不过它并不会拷贝其中的member class object，而是以递归的方式施行memberwise initialization。</p>

<p>copy constructor仅在必要的时候（class不展现bitwise copy semantics）才由编译器产生出来。</p>

<p>比如，某个类含有<code>String&amp; str</code>成员变量，在这种情况下，编译器必须合成出一个copy constructor以便调用member class String object的copy constructor：</p>

<p><strong>一个class不展现出“bitwise copy semantics”的四种情况：</strong></p>

<ol>
  <li>当class内含一个member object而后者的class声明有一个copy constructor时（无论是被明确声明或被合成而得）</li>
  <li>当class继承自一个base class而后者存在有一个copy constructor时</li>
  <li>
    <p>当class声明了一个或多个virtual functions时</p>

    <p>由于编译器要对每个新产生的class object的vptr设置初值，因此，当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。特别地，当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作必须保证安全，而如果依旧采用bitwise copy的话，base class object的vptr会被设定指向derived class的virtual table，而这将导致灾难。</p>
  </li>
  <li>
    <p>当class派生自一个继承串链，其中有一个或多个virtual base classes时</p>

    <p>当一个class object以其derived classes的某个object作为初值时，为了完成正确的virtual base class pointer/offset的初值设定，编译器必须合成一个copy constructor，安插一些码以设定virtual base class pointer/offset的初值，对每一个member执行必要的memberwise初始化操作，以及执行其他的内存相关操作。</p>
  </li>
</ol>

<h2 id="section">成员的初始化列表</h2>

<p>下列情况中，为了让你的程序能够被顺利编译，你必须使用member initialization list：</p>

<ul>
  <li>当初始化一个reference member时；</li>
  <li>当初始化一个const member时；</li>
  <li>当调用一个base class的constructor，而它拥有一组参数时；</li>
  <li>当调用一个member class的constructor，而它拥有一组参数时。</li>
</ul>

<h2 id="class">class大小</h2>

<p>考虑下面的代码：</p>

<pre><code>#include "iostream"
using namespace std;

class X {};
class Y : public virtual X {};
class Z : public virtual X {};
class A : public Y,public Z {};

int main()
{
    cout&lt;&lt;"sizeof(X): "&lt;&lt;sizeof(X)&lt;&lt;endl;
    cout&lt;&lt;"sizeof(Y): "&lt;&lt;sizeof(Y)&lt;&lt;endl;
    cout&lt;&lt;"sizeof(Z): "&lt;&lt;sizeof(Z)&lt;&lt;endl;
    cout&lt;&lt;"sizeof(A): "&lt;&lt;sizeof(A)&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>得到的结果是什么呢？答案是</p>

<pre><code>sizeof(X): 1
sizeof(Y): 4
sizeof(Z): 4
sizeof(A): 8
</code></pre>

<ul>
  <li>对于一个class X这样的空的class，由于需要使得这个class的两个objects得以在内存中配置独一无二的地址，故编译器会在其中安插进一个char。因而class X的大小为1。</li>
  <li>由于class Y虚拟继承于class X，而在derived class中，会包含指向visual base class subobject的指针（4 bytes），而由于需要区分这个class的不同对象，因而virtual base class X subobject的1 bytes也出现在class Y中（1 bytes），此外由于Alignment的限制，class Y必须填补3bytes（3 bytes），这样一来，class Y的大小为8。<strong>编译器将一个empty virtual base class视为derived class object最开头的一部分，因而省去了其后的1 bytes，自然也不存在后面Alignment的问题，故实际的执行结果为4。</strong></li>
  <li>不管它在class继承体系中出现了多少次，一个virtual base class subobject只会在derived class中存在一份实体。因此，class A的大小有以下几点决定：（1）被大家共享的唯一一个class X实体（1 byte）；（2）Base class Y的大小，减去“因virtual base class X而配置”的大小，结果是4 bytes。Base class Z的算法亦同。（3）classs A的alignment数量。前述总和为9 bytes，需要填补3 bytes，结果是12 bytes。empty virtual base class所做的处理，class X实体的那1 byte将被拿掉，于是额外的3 bytes填补额也不必了，故实际的执行结果为8。</li>
</ul>

<p><strong>不管是自身class的还是继承于virtual或nonvirtual base class的nonstatic data members，其都是直接存放在每个class object之中的。至于static data members，则被放置在程序的一个global data segment中，不会影响个别的class object的大小，并永远只存在一份实体。</strong></p>

<h2 id="data-member">Data Member</h2>

<h3 id="data-member-1">Data Member布局</h3>

<p>同一个access section中的nonstatic data member在class object中的排列顺序和其被声明的顺序一致，而多个access sections中的data members可以自由排列。（虽然当前没有任何编译器会这么做）</p>

<p>编译器还可能会合成一些内部使用的data members（例如vptr，编译器会把它安插在每一个“内含virtual function之class”的object内），以支持整个对象模型。</p>

<h3 id="data-member-2">Data Member的存取</h3>

<p><strong>Static Data Members：</strong></p>

<ul>
  <li>每一个static data member只有一个实体，存放在程序的data segment之中，每次程序取用static member，就会被内部转化为对该唯一的extern实体的直接参考操作。</li>
  <li>若取一个static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向其class member的指针，因为static member并不内含在一个class object之中。</li>
  <li>如果有两个classes，每一个都声明了一个static member freeList，那么编译器会采用name-mangling对每一个static data member编码，以获得一个独一无二的程序识别代码。</li>
</ul>

<p><strong>Nonstatic Data Members：</strong></p>

<pre><code>Point3d origin, *pt = &amp;origin;
origin.x = 0.0;
pt-&gt;x = 0.0;
</code></pre>

<p><strong>这两种存取方式有什么区别吗？</strong></p>

<p>答案是“<strong>当Point3d是一个derived class，而在其继承结构中有一个virtual base class，并且并存取的member（如本例的x）是一个从该virtual base class继承而来的member时，就会有重大的差异</strong>”。这时候我们不能够说pt必然指向哪一种 class type（因此我们也就不知道编译期间这个member真正的offset位置），所以这个存取操作必须延迟到<strong>执行期</strong>，经由一个额外的简洁导引，才能够解决。但如果使用origin，就不会有这些问题，其类型无疑是Point3d class，而即使它继承自virtual base class，members的offset位置也在<strong>编译时期就固定了</strong>。</p>

<h3 id="data-member-3">继承与Data Member</h3>

<p><strong>1. 只要继承不要多态</strong></p>

<pre><code>class Concrete {
private:
int val;
char bit1;
};

class Concrete2 : public Concrete1 {
private:
char bit2;
};

class Concrete3 : public Concrete2 {
private:
char bit3;
};
</code></pre>

<p>现在Concrete3 object的大小为16 bytes，细分如下：（a）Concrete1内含两个members：val和bit1，加起来是5 bytes，再填补3 bytes，故一个Concrete1 object实际用掉8 bytes；（b）需要注意的是，Concrete2的bit2实际上是被放在填补空间之后的，于是一个Concrete2 object的大小变成12 bytes；（c）依次类推，一个Concrete3 object的大小为16 bytes。</p>

<p><strong>2. 加上多态</strong></p>

<p>virtual function带来的额外负担：</p>

<ul>
  <li>导入一个virtual table，用来存放它声明的每一个virtual function的地址；</li>
  <li>在每一个class object中导入一个vptr；</li>
  <li>加强constructor和destructor，使它们能设置和抹消vptr。</li>
</ul>

<p><strong>3. 多重继承</strong></p>

<p>对一个多重继承对象，将其地址指定给“第一个base class的指针”，情况将和单一继承时相同，因为二者都指向相同的起始地址，需付出的成本只有地址的指定操作而已。至于第二个或后继的base class的地址指定操作，则需要将地址修改过，加上（或减去，如果downcast的话）介于中间的base class subobjects的大小。</p>

<p><strong>4. 虚拟继承</strong></p>

<p>class如果内含一个或多个virtual base class subobject，将被分隔为两部分：一个不变局部和一个共享局部。不变局部中的数据，不管后继如何衍化，总是拥有固定的offset，所以这一部分数据可以被直接存取。至于共享局部，所表现的就是virtual base class subobject。这一部分的数据，其位置会因为每次的派生操作而变化，所以它们只可以被间接存取。
间接存取主要有以下三种主流策略：</p>

<ol>
  <li>在每一个derived class object中安插一些指针，每个指针指向一个virtual base class。要存取继承得来的virtual base class members，可以使用相关指针间接完成。由于虚拟继承串链得加长，导致间接存取层次的增加。</li>
  <li>在上一个的基础上，为了解决每一个对象必须针对每一个virtual base class背负一个额外的指针的问题，Micorsoft编译器引入所谓的virtual base class table。每一个class object如果有一个或多个virtual base classes，就会由编译器安插一个指针，指向virtual base class table。这样一来，就可以保证class object有固定的负担，不因为其virtual base classes的数目而有所变化。</li>
  <li>在virtual function table中放置virtual base class的offset。新近的Sun编译器采取这样的索引方法，若为正值，就索引到virtual functions，若为负值，则索引到virtual base class offsets。</li>
</ol>

<p><strong>小结：一般而言，virtual base class最有效的一种运用方式就是：一个抽象的virtual base class，没有任何data members。</strong></p>

<h3 id="data-members">指向Data Members的指针</h3>

<pre><code>class Point3d {
public:
	virtual ~Point3d();
protected:
	static Point3d origin;
	float x, y, z;
} 
</code></pre>

<p>如果你去取class中某个data member的地址时，得到的都是data member在class object中的实际偏移量加1。例如<code>&amp;Point3d::z</code>得到9或13，根据vptr放在对象头还是对象尾确定。为什么要这么做呢？主要是为了区分一个“没有指向任何data member”的指针和一个指向“的第一个data member”的指针。即，区分一下情况：</p>

<pre><code>float Point3d::*p1 = 0;
float Point3d::*p2 = &amp;Point3d::x;
</code></pre>

<p>为了区分<code>p1</code>和<code>p2</code>每一个真正的member offset值都被加上1。因此，无论编译器或使用者都必须记住，在真正使用该值以指出一个member之前，请先减掉1。</p>

<p>另外正确区分<code>&amp; Point3d::z</code>和<code>&amp;origin.z</code>：取一个nonstatic data member的地址将会得到它在class中的offset，取一个绑定于真正class object身上的data member的地址将会得到该member在内存中的真正地址。</p>

<p>在多重继承之下，若要将第二个（或后继）base class的指针和一个与derived class object绑定之member结合起来那么将会因为需要加入offset值而变得相当复杂。</p>

<pre><code>struct Base1 { int val1; };
struct Base2 { int val2; };
struct Derived : Base1, Base2 { ... };

void func1(int Derived::*dmp, Derived *pd)
{
	// 期望第一个参数得到的是一个“指向derived class之member”的指针
	// 如果传来的却是一个“指向base class之member”的指针，会怎样呢
	pd-&gt;*dmp;
}

void func2(Derived *pd)
{
	// bmp将成为1
	int Base2::*bmp = &amp;Base2::val2;
	// bmp == 1
	// 但是在Derived中，val2 == 5
	func1(bmp,pd);
}
</code></pre>

<p>也就是说<code>pd-&gt;*dmp</code>将存取到<code>Base1::val1</code>，为解决这个问题，当bmp被作为func1()的第一个参数时，它的值必须因介入的Base1 class的大小而调整：</p>

<pre><code>// 内部转换，防止bmp == 0
func1(bmp ? bmp + sizeof(Base1) : 0, pd);
</code></pre>

<h2 id="functions">Functions</h2>

<h3 id="nonstatic-member-functions">非静态成员函数（Nonstatic Member Functions）</h3>

<p>C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmember function有相同的效率。因为编译器内部已将“member函数实体”转化为对等的“nonmember函数实体”。下面是magnitude()的一个nonmember定义：</p>

<pre><code>loat Pointer3d::magnitude() const
{
	return sqrt(_x*_x + _y*_y + _z*_z);
}
// 内部转化为
float magnitude_7Point3dFv(const Point3d *this)  //已对函数名称进行“mangling”处理
{
	return sqrt(this-&gt;_x*this-&gt;_x + this-&gt;_y*this-&gt;_y + this-&gt;_z*this-&gt;_z);
}
</code></pre>

<p>现在，对该函数的每一个调用操作也都必须转换：</p>

<pre><code>obj.magnitude();
// 转换为
magnitude_7Point3dFv(&amp;obj);
</code></pre>

<p>mangling手法可在链接时期检查出任何不正确的调用操作，但由于编码时未考虑返回类型，故<strong>如果返回类型声明错误，就无法检查出来</strong>。</p>

<h3 id="virtual-member-functions">虚拟成员函数（Virtual Member Functions）</h3>

<p>一个class只会有一个virtual table，其中内含其对应的class object中所有active virtual functions函数实体的地址，具体包括：</p>

<ol>
  <li>
    <p>这个class所定义的函数实体</p>

    <p>它会改写一个可能存在的base class virtual function函数实体。若base class中不存在相应的函数，则会在derived class的virtual table增加相应的slot。</p>
  </li>
  <li>
    <p>继承自base class的函数实体</p>

    <p>这是在derived class决定不改写virtual function时才会出现的情况。具体来说，base class中的函数实体的地址会被拷贝到derived class的virtual table相对应的slot之中。</p>
  </li>
  <li>
    <p>pure_virtual_called函数实体</p>
  </li>
</ol>

<p>对于那些不支持多态的对象，经由一个class object调用一个virtual function，这种操作应该总是被编译器像对待一般的nonstatic member function一样地加以决议：</p>

<pre><code>// Point3d obj
obj.normalize();
// 不会转化为
(*obj.vptr[1])(&amp;obj);
// 而会被转化未
normalize_7Point3dFv(&amp;obj);
</code></pre>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/virtualtable_zpsc5065cda.png" alt="" /></p>

<h3 id="static-member-functions">静态成员函数（Static Member Functions）</h3>

<p>编译器的开发者针对static member functions，分别从编译层面和语言层面对其进行了支持：</p>

<p><strong>编译层面</strong>：当class设计者希望支持“没有class object存在”的情况时，可把0强制转型为一个class指针，因而提供出一个this指针实体：</p>

<pre><code>// 函数调用的内部转换
object_count((Point3d*)0);
</code></pre>

<p><strong>语言层面</strong>：static member function的最大特点是没有this指针，如果取一个static member function的地址，获得的将是其在内存中的位置，其地址类型并不是一个“指向class member function的指针”，而是一个“nonmember函数指针”：</p>

<pre><code>unsigned int Point3d::object_count() { return _object_count; }
&amp;Point3d::object_count();
// 会得到一个地址，其类型不是
unsigned int (Point3d::*)();
// 而是
unsigned int (*)();
</code></pre>

<ul>
  <li>它不能够直接存取其class的nonstatic members。</li>
  <li>它不能够被声明为const、volatile或virtual。</li>
  <li>它不需要经由class object才被调用。</li>
</ul>

<p>static member function经常被用作回调（callback）函数。</p>

<h3 id="virtual-functions">多重继承下的Virtual Functions</h3>

<p>在多重继承中支持virtual functions，其复杂度围绕在第二个及后继的base classes身上，以及“必须在执行期调整this指针”这一点。</p>

<p><strong>多重继承到来的问题：</strong></p>

<ol>
  <li>
    <p>经由指向“第二或后继之base class”的指针（或reference）来调用derived class virtual function，该调用操作连带的“必要的this指针调整”操作，必须在执行期完成；</p>

    <pre><code> Base2 *pbase2 = new Derived;
 //会被内部转化为：
 Derived *temp = new Derived;
 Base2 *pbase2 = temp ? temp + sizeof(Base1) : 0;
 // 必须调用正确的virtual destructor函数实体
 // pbase2需要调整，以指出完整对象的起始点
 delete pbase2;
</code></pre>

    <p>上述的offset加法却不能够在编译时期直接设定，因为pbase2所指的真正对象只有在执行期才能确定。自此，我们明白了在多重继承下所面临的独特问题：经由指向“第二或后继之base class”的指针（或reference）来调用derived class virtual function，该调用操作所连带的“必要的this指针调整”操作，必须在执行期完成。有两种方法来解决这个问题：</p>

    <ol>
      <li>将virtual table加大，每一个virtual table slot不再只是一个指针，而是一个聚合体，内含可能的offset以及地址。</li>
      <li>利用Thunk技术，允许virtual table slot继续内含一个简单的指针，slot中的地址可以直接指向virtual function，也可以指向一个相关的thunk。于是，对于那些不需要调整this指针的virtual function而言，也就不需要承载效率上的额外负担。</li>
    </ol>
  </li>
  <li>
    <p>由于两种不同的可能：（a）经由derived class（或第一个base class）调用；（b）经由第二个（或其后继）base class调用，同一函数在virtual table中可能需要多笔对应的slot；</p>

    <pre><code> Base1 *pbase1 = new Derived;
 Base2 *pbase2 = new Derived;
	
 delete pbase1;
 delete pbase2;
</code></pre>

    <p>虽然两个delete操作导致相同的Derived destructor，但它们需要两个不同的virtual table slots：</p>

    <p><strong>解决方法：</strong>在多重继承下，一个derived class内含n-1个额外的virtual tables，n表示其上一层base classes的数目。按此手法，Derived将内含以下两个tables：vtbl_Derived和vtbl_Base2_Derived。</p>
  </li>
  <li>
    <p>允许一个virtual function的返回值类型有所变化，可能是base type，可能是publicly derived type，这一点可以通过Derived::clone()函数实体来说明。</p>

    <pre><code> Base2 *pb1 = new Derived;

 // 调用Derived::clone()
 // 返回值必须被调整，以指向Base2 subobject
 Base2 *pb2 = pb1-&gt;clone();
</code></pre>

    <p>当运行pb1-&gt;clone()时，pb1会被调整指向Derived对象的起始地址，于是clone()的Derived版会被调用：它会传回一个指针，指向一个新的Derived对象；该对象的地址在被指定给pb2之前，必须先经过调整，以指向Base2 subobject。</p>
  </li>
</ol>

<p>virtual table多重继承内存布局图：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/virtualtable_zps7dae0fad.png" alt="多重继承" /></p>

<p>virtual table虚拟继承内存布局图：</p>

<p><img src="http://i1113.photobucket.com/albums/k512/billowkiller/LinkSource/virtualtable_zpsb4d94533.png" alt="" /></p>

<h2 id="section-1">其他</h2>

<h3 id="section-2">纯虚函数</h3>

<p>在设计抽象基类时，需要注意以下几点：</p>

<ol>
  <li>
    <p>不要将destructor声明为pure virtual function；</p>

    <p>如果将destructor声明为pure virtual function，则设计者一定得定义它。因为每一个derived class destructor会被编译器加以扩展，以静态调用得方式调用其“每一个virtual base class”以及“上一层base class”的destructor。</p>
  </li>
  <li>不要将那些函数定义内容并不与类型有关的函数设计为virtual function，因为其几乎不会被后继的derived class改写。</li>
  <li>对于其derived class可能修改某一个data member的函数，不应被声明为const。</li>
</ol>

<h3 id="section-3">对象构造</h3>

<p><strong>必须在构造函数初始化列表初始化的类型</strong>：</p>

<ul>
  <li>没有默认构造函数的类型成员</li>
  <li>const成员（整数型的可以申明时赋值）</li>
  <li>
    <p>引用类型的成员</p>

    <p>class Point {
  public:
      Point(float x = 0.0, float y = 0.0) : _x(x),_y(y) {}
      virtual float z();
  protected:
      float _x,_y;
  };</p>
  </li>
</ul>

<p>不能小看z()这个virtual function给class Point带来的巨大变化。virtual function的引入促使每一个class Point拥有一个vtpr，这样一来，编译器在constructor中添加了对vptr进行初始化的代码，而copy constructor和copy assignment operator也会对vptr进行设定，而不再是原先简单的bitwise操作了。</p>

<p>一般而言，如果你的设计之中有很多函数都需要以传值方式（by value）传回一个local class object，那么提供一个copy constructor就比较合理。</p>

<p><strong>constructor的执行算法通常如下：</strong></p>

<ul>
  <li>在derived class constructor中，所有virtual base classes的constructor会被调用；</li>
  <li>在derived class constructor中，上一层base class的constructor会被调用；</li>
  <li>上述完成之后，对象的vptr(s)被初始化，指向相关的virtual table(s)；</li>
  <li>如果class有member class object，而后者拥有constructor，那么它们会以其声明顺序的相反顺序被调用；</li>
  <li>用户所定义的代码。</li>
</ul>

<h3 id="section-4">析构函数</h3>

<p>如果class没有定义destructor，那么只有在class内含的member object（或是class自己的base class）拥有destructor的情况下，编译器才会自动合成出一个来。
其解构顺序与建构顺序正好相反。</p>

<p>一般而言，我们会把object尽可能放置在使用它的那个程序区段附近，这样做可以节省不必要的对象产生操作和销毁操作。</p>

<h3 id="section-5">全局对象</h3>

<p>全局对象的静态初始化策略包括以下几个步骤：</p>

<ol>
  <li>为每一个需要静态初始化的对象产生一个<code>_sti_...()</code>函数，内含必要的constructor调用操作或inline expansions；</li>
  <li>为每一个需要静态的内存释放操作的对象产生一个<code>_std_...()</code>函数，内含必要的destructor调用操作或inline expansions；</li>
  <li>在main()函数的首尾分别添加一个<code>_main()</code>函数（用以调用可执行文件中的所有<code>_sti()</code>函数）和一个<code>_exit()</code>函数（用以调用可执行文件中的所有<code>_std()</code>函数）。</li>
</ol>

<p><strong>建议根本不要用那些需要静态初始化的全局对象。</strong> </p>

<h3 id="section-6">局部静态对象</h3>

<pre><code>const Matrix&amp; identity() {
	static Matrix mat_identity;
	// ...
	return mat_identity;
}
</code></pre>

<p>此处的local static class object保证了以下语意：</p>

<ul>
  <li><code>mat_identity</code>的constructor必须只能施行一次，虽然上述函数可能会被调用多次；</li>
  <li><code>mat_identity</code>的destructor必须只能施行一次，虽然上述函数可能会被调用多次。</li>
</ul>

<p>编译器的实际做法如下：在第一次调用<code>identity()</code>时把<code>mat_identity</code>构造出来，而在与相应文件关联的静态内存释放函数中将其解构。（局部静态对象的地址在downstream component中将会被转换到程序内用来放置global object的data segment中）</p>

<h3 id="section-7">对象数组</h3>

<p>如何支持以下的语句：<code>complex::complex(double=0.0, double=0.0);</code></p>

<pre><code>complex c_array[10];
//内部转换
vec_new(&amp;c_array,sizeof(complex),10,&amp;complex::complex,0);
</code></pre>

<p>为了解决这个问题，可由编译器产生一个内部的constructor，没有参数，在其函数内调用由程序员提供的constructor，并将default参数值明确地指定过去：</p>

<pre><code>complex::complex() {
	complex(0.0, 0.0);
}
</code></pre>

<h3 id="new--delete">new &amp; delete</h3>

<p>以constructor来配置一个class object：<code>Point3d *origin = new Point3d;</code>
转为</p>

<pre><code>Point3d *origin;
if(origin = _new(sizeof(Point3d))) {
	try {
		origin = Point3d::Point3d(origin);
	}
	catch( ... ) {
		_delete(origin);  // 释放因new而配置的内存
		throw;  // 将原来的exception上传
	}
}
</code></pre>

<p>如果我们配置一个数组，内带10个Point3d objects，我们预期Point和Point3d的constructor被调用各10次，每次作用于数组中的一个元素：</p>

<pre><code>// 危险
Point *ptr = new Point3d[10];
// 只有Point::~Point被调用
delete []ptr;
</code></pre>

<p>由于其触发的<code>vec_delete()</code>是通过迭代走过每一个数组元素，而本例中被传递过去的是Point class object的大小而不是Point3d class object的大小，整个运行过程将会失败。
解决之道在于程序层面，而非语言层面：</p>

<pre><code>for(int ix = 0; ix &lt; 10; ix++)
{
	Point3d *p = &amp;((Point3d*)ptr)[ix];
	delete p;
}
</code></pre>

<p>当然，最好还是<strong>避免以一个base class指针指向一个derived class objects所组成的数组。</strong></p>

<h3 id="template">Template</h3>

<p><strong>member functions只有在member functions被使用的时候，C++ Standard才要求它们被“具现”出来</strong>。这个规则的由来主要有两个原因：</p>

<ol>
  <li>空间和效率的考虑。对于未使用的函数进行“具现”将会花费大量的时间和空间；</li>
  <li>尚未实现的功能。并不是一个template具现出来的所有类型一定能够完整支持一组member functions，因而只需具现真正需要的member functions。</li>
</ol>

<p>举个例子：<code>Point&lt;float&gt; *p = new Point&lt;float&gt;;</code></p>

<p>只有（a）Point template的float实例、（b）new 运算符、（c）default constructor需要被“具现”。</p>

<p><strong>并且所有与类型相关的检验，如果涉及到template参数，都必须延迟到真正的具现操作发生</strong>。</p>

<p>区分以下两种意义：一种是“<strong>scope of the template definition</strong>”，也就是“定义出template”的程序，另一种是“<strong>scope of the template instantiation</strong>”，也就是“具现出template”的程序。</p>

<pre><code>// scope of the template definition
extern double foo(double);

template &lt;class type&gt;
class ScopeRules {
public:
	void invariant() { _member = foo(_val); }
	type type_dependent() { return foo(_member); }
	// ...
private:
	int _val;
	type _member;
};

// scope of the template instantiation
extern int foo(int);

ScopeRules&lt;int&gt; sr0;
</code></pre>

<p>在“scope of the template definition”中，只有一个foo()函数声明位于scope之内；然而在“scope of the template instantiation”中，两个foo()函数声明都位于scope之内。对于以下函数操作：<code>sr0.invariant();</code>，那么，在invariant()中调用的究竟是哪一个foo()函数实体呢？</p>

<p>Template之中，对于一个nonmember name的决议结果是根据这个name的使用是否与“用以具现出该template的参数类型”有关而决定的，如果其使用互不相关，那么就以“scope of the template definition”来决定name，否则就以“scope of the template instantiation”来决定name。</p>

<pre><code>// 因为_val的类型是int，而函数的决议只和函数原型有关，与函数返回值无关
// 被用来具现这个template的真正类型对于_val的类型没有影响
_member = foo(_val);
</code></pre>

<p>故此处的调用操作由“scope of the template definition”来决议。</p>

<p>若是如下的函数调用：<code>sr0.type_dependent();</code>。由于_member的类型与template参数有关，故此处由“scope of the template instantiation”来决议。</p>

<h3 id="section-8">执行期类型识别</h3>

<p><code>dynamic_cast</code>运算符可以在执行期决定真正的类型。如果downcast是安全的（也就是说，一个base type pointer指向一个derived class object），这个运算符会传回被适当转型过的指针；如果downcast不是安全的，这个运算符会传回0。</p>

<pre><code>typedef type *ptype;
typedef fct *pfct;

simplify_conv_op(ptype pt)
{
	if(pfct pf = dynamic_cast&lt;pfct&gt;(pt)) {
	...
	}
	else { ... }
}
</code></pre>

<p>什么是<code>dynamic_cast</code>的真正成本？<code>pfct</code>的一个类型描述器会被编译器产生出来，由<code>pt</code>指向之class object类型描述器必须在执行期通过vptr取得。下面是可能的转换：</p>

<pre><code>// 取得pt的类型描述器
((type_info*)(pt-&gt;vptr[0]))-&gt;_type_description;
</code></pre>

<p>其中，<code>type_info</code>是C++ Standard所定义的类型描述器的class名称，该class中放置着待索求的类型信息。virtual table的第一个slot内含<code>type_info</code> object的地址，此<code>type_info</code> object与pt所指之class type有关。</p>

<p><code>dynamic_cast</code>运算符也适用于reference身上，然而对于一个non-type-safe-cast，其结果不会与施行于指针的情况一样。一个reference不可以像指针那样“把自己设为0便代表了no object”；若将一个reference设为0，会引起一个临时性对象（拥有被参考到的类型）被产生出来，该临时对象的初值为0，这个reference然后被设定为该临时变量的一个别名。</p>

<p>因而，如果reference并不真正是某一种derived class，那么可通过丢出一个<code>bad_cast exception</code>进行处理：</p>

<pre><code>simplify_conv_op(const type &amp;rt)
{
	try {
		fct &amp;rf = dynamic_cast&lt;fct&amp;&gt;(rt);
	}
	catch(bad cast) {
		// ...
	}
}
</code></pre>

<p>当然，你也可以使用typeid运算符来达到同样的目的：</p>

<pre><code>simplify_conv_op(const type &amp;rt)
{
	if(typeid(rt) == typeid(fct))
	{
		fct &amp;rf = dynamic_cast&lt;fct&amp;&gt;(rt);
	}
	else { ... }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
