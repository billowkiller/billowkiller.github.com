<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tags: algorithm | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/tags/algorithm/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2014-08-17T16:02:53+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Number Theory Introduction]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/09/Number-theory-introduction/"/>
    <updated>2014-08-09T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/09/Number-theory-introduction</id>
    <content type="html"><![CDATA[<h2 id="catalan">Catalan数</h2>

<p>卡塔兰数是组合数学中一个常在各种计数问题中出现的数列。卡塔兰数的一般项公式为：</p>

<p><img src="http://upload.wikimedia.org/math/d/1/1/d118d8cea7b639dfd5244fcba65910cf.png" alt="" /></p>

<p>它的另外一个表达式是：</p>

<p><img src="http://upload.wikimedia.org/math/f/7/9/f7943e307a891716ca1266a5f5957cdd.png" alt="" /></p>

<p><strong>递推关系：</strong></p>

<p><img src="http://upload.wikimedia.org/math/6/2/1/6217b3c99a3243afcd5d8dbd58186822.png" alt="" /></p>

<p><img src="http://upload.wikimedia.org/math/8/a/4/8a49332e4a46b3a2c7accec81160f5e3.png" alt="" /></p>

<h3 id="section">组合数学中的应用</h3>

<ol>
  <li>长度2n的dyck word的个数。Dyck word是一个有n个X和n个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。以下为长度为6的dyck words: <code>XXXYYY</code> <code>XYXXYY</code> <code>XYXYXY</code> <code>XXYYXY</code> <code>XXYXYY</code></li>
  <li>将上例的X换成左括号，Y换成右括号，Cn表示所有包含n组括号的合法运算式的个数</li>
  <li>
    <p>Cn表示有n个节点组成不同构二叉树的方案数。下图中，n等于3，圆形表示节点，月牙形表示什么都没有。</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/0/01/Catalan_number_binary_tree_example.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示有2n+1个节点组成不同构满二叉树（full binary tree）的方案数。</p>

    <p>证明：
 令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含n个1、n个0的2n位二进制数共有<img src="http://upload.wikimedia.org/math/c/9/2/c92da943df73dc077dbee5514376346a.png" alt="" />个，下面考虑不满足要求的数目。</p>

    <p>考虑一个含n个1、n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况），则后面的0-1排列中必有n-m个1和n-m-1个0。将2m+2及其以后的部分0变成1、1变成0，则对应一个n+1个0和n-1个1的二进制数。反之亦然（相似的思路证明两者一一对应）。从而：</p>

    <p><img src="http://upload.wikimedia.org/math/4/8/2/4828faf1c29e4b699529f2275cc63453.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示所有在n × n格点中不越过对角线的单调路径的个数。一个单调路径从格点左下角出发，在格点右上角结束，每一步均为向上或向右。计算这种路径的个数等价于计算Dyck word的个数：X代表“向右”，Y代表“向上”。下图为n = 4的情况：</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Catalan_number_4x4_grid_example.svg/450px-Catalan_number_4x4_grid_example.svg.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示通过连结顶点而将n + 2边的凸多边形分成三角形的方法个数。下图中为n = 4的情况：</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Catalan-Hexagons-example.svg/400px-Catalan-Hexagons-example.svg.png" alt="" /></p>
  </li>
  <li>
    <p>Cn表示用n个长方形填充一个高度为n的阶梯状图形的方法个数。下图为n = 4的情况：</p>

    <p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Catalan_stairsteps_4.svg/400px-Catalan_stairsteps_4.svg.png" alt="" /></p>
  </li>
</ol>

<h3 id="section-1">面试题</h3>

<p><strong>12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？</strong></p>

<p>我们先把这12个人从低到高排列，然后，选择6个人排在第一排，那么剩下的6个肯定是在第二排。</p>

<p>用0表示对应的人在第一排，用1表示对应的人在第二排，那么含有6个0，6个1的序列，就对应一种方案。问题转换为，这样的满足条件的01序列有多少个。</p>

<p><strong>给乘积X1X,X3……Xn加括号的方法数</strong></p>

<p><strong>n+m个人排队买票，并且满足$n \ge m$，票价为50元，其中n个人各手持一张50元钞票，m个人各手持一张100元钞票，除此之外大家身上没有任何其他的钱币，并且初始时候售票窗口没有钱，问有多少种排队的情况数能够让大家都买到票。</strong></p>

<p>这个题目是Catalan数的变形，不考虑人与人的差异，如果m=n的话那么就是我们初始的Catalan数问题，也就是将手持50元的人看成是+1，手持100元的人看成是-1，任前k个数值的和都非负的序列数。</p>

<p>这个题目区别就在于$n&gt;m$的情况，此时我们仍然可以用原先的证明方法考虑，假设我们要的情况数是$D_{n+m}$，无法让每个人都买到的情况数是$U_{n + m}$，那么就有$D_{n + m} + U_{n +m} = {n + m \choose n}$，此时我们求$U_{n + m}$，我们假设最早买不到票的人编号是k，他手持的是100元并且售票处没有钱，那么将前k个人的钱从50元变成100元，从100元变成50元，这时候就有$n+1$个人手持50元，$m-1$个手持100元的，所以就得到$U_{n + m} = {n + m \choose n + 1}$，于是我们的结果就因此得到了，表达式是$D_{n + m} = {n + m \choose n} - {n + m \choose n + 1}$。</p>

<h2 id="section-2">欧拉函数</h2>

<p>在数论中，对正整数n，欧拉函数$\varphi(n)$是小于或等于n的正整数中与n互质的数的数目。例如$\varphi(8)=4$，因为1,3,5,7均和8互质。</p>

<ul>
  <li>
    <p>$\varphi(1)=1$（小于等于1的正整数中唯一和1互质的数就是1本身）。</p>
  </li>
  <li>
    <p>若$n$是质数$p$的$k$次幂，$\varphi(n)=\varphi(p^k)=p^k-p^{k-1}=(p-1)p^{k-1}$，因为除了$p$的倍数外，其他数都跟$n$互质。</p>
  </li>
  <li>
    <p>若$n = p_1^{k_1} p_2^{k_2} \cdots p_r^{k_r}$, 则$\varphi(n) = \prod_{i=1}^r p_i^{k_i-1}(p_i-1) = \prod_{p\mid n} p^{\alpha_p-1}(p-1) = n\prod_{p|n}\left(1-\frac{1}{p}\right)$。
其中$\alpha_p$是使得$p^{\alpha}$整除$n$的最大整数$\alpha（这里\alpha_{p_i} = k_i）$。</p>

    <p>例如$\varphi(72)=\varphi(2^3\times3^2)=72\times(1 - \frac{1}{2})\times(1 - \frac{1}{3})=24$</p>
  </li>
  <li>
    <p>对任何两个互质的正整数$a, m（即 gcd(a,m) = 1），m\ge2$，有$a^{\varphi(m)} \equiv 1 \pmod m$。即<strong>欧拉定理</strong>。</p>
  </li>
  <li>
    <p>当$m$是质数$p$时，此式则为：$a^{p-1} \equiv 1 \pmod p$。即<strong>费马小定理</strong>。</p>
  </li>
</ul>

<p><strong>欧拉函数的程序:</strong></p>

<p><code>c++
int phi(int x) {
    int ans = x;
    int m = (int)sqrt(x+0.5);
    for(int i = 2; i &lt;= m; i++) {
        if(x % i == 0) {   // 求素因子
            ans = ans / i * (i - 1);    // 运用通项求解欧拉函数
            while(x % i == 0)  x /= i;  // 每个素因子只计算一次
        }
    }
    if(x &gt; 1)  ans = ans / x * (x - 1);  // 防质数
    return ans;
}
</code></p>

<p><strong>1-n中所有树的欧拉phi函数值。</strong>并不需要一次计算。可以用与筛法求素数类似的方法，在$O(nloglogn)$时间内计算完毕。</p>

<p>``` c++
void phi_table(int n, int* phi) {
    for(int i = 2; i &lt;= N; i++)  p[i] = 0;
    phi[1] = 1;</p>

<pre><code>for(int i = 2; i &lt;= N; i++) {
    if(!phi[i]) {
        for(int j = i; j &lt;= n; j += i) {    // 处理素因子phi[i]
            if(!phi[j]) phi[j] = j;
             phi[j] = phi[j] / i * (i - 1);    // 先除后乘，防止中间过程超出范围
        }
    }
} } ```
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Probability Problem]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/02/probability-problem/"/>
    <updated>2014-08-02T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/02/probability-problem</id>
    <content type="html"><![CDATA[<h2 id="section">一、抛硬币问题</h2>

<p><strong>问题1 有一苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面者吃。问先抛这吃到苹果的概率是多少？</strong></p>

<p>假设第一个人吃到苹果的概率是P。第一次抛硬币若为正面则先抛者赢；若为负面且后抛者也为负面，则主动权回到先抛者，回到原问题。</p>

<p>得到关系：P = 1/2 + 1/2 * 1/2 * P  </p>

<p>得出 P = 2/3</p>

<p><strong>问题2 游戏规则为，连续2次抛到硬币朝上，则游戏结束。问平均抛多少次游戏可以结束？</strong></p>

<!--more-->

<p>平均抛多少次，即是求问题的期望。</p>

<p>首先先抛一枚硬币，如果是花，那么需要重头开始；如果是字，那么再抛一枚硬币，新抛的这枚如果也是字，则游戏结束，如果是花，那么又需要重头开始。根据这个过程，设抛硬币的期望次数为T，可以得到关系：T = 1/2(1 + T) + 1/4 * 2 + 1/4(2 + T)</p>

<p>得出 T = 6 </p>

<p><strong>问题3 连续抛 k 次朝上的解法：</strong></p>

<p>假设连续k次正面朝上的期望为Ek，在连续出现k次正面朝上后，下次一也为正面的期望为</p>

<p>E(k+1) = 1/2 (Ek + 1) + 1/2(Ek + 1 + E(k+1))</p>

<p>推到出公式 (E(k+1) +2) /(Ek +2) = 2 得出 Ek = 2^(k+1) -2</p>

<p><strong>问题4 A和B2人投硬币,正面A得1元,反面B得一元.起始时A有1元,B有100元.游戏持续进行,直到其中1人破产才终止.</strong></p>

<ol>
  <li>
    <p>如果硬币正反概率相同,游戏的期待长度(expected duration)是几次投掷?</p>

    <p>目前认为只有奇数次才可能破产。<code>1*0.5 + 3*0.5^3 + 5*0.5^5+...</code></p>
  </li>
  <li>
    <p>如果硬币是不公正的,正面概率为P,反面概率为Q.(P+Q=1), 那么游戏的期待长度(expectedduration)是几次投掷?</p>

    <p>那么问题的答案是计算E(T(n)),即该事件的期望值。</p>

    <p>第1次出现破产的概率是p  //只可能A破产</p>

    <p>第2次出现            0  //因为A第1次赢了1个，共2个了，最多只能输1个，还会剩1个</p>

    <p>第3次出现            <code>q×p×p</code></p>

    <p>第4次出现            0</p>

    <p>第5次                <code>q*q*p*p*p</code></p>

    <p>第99次               q(49次方)×P(50次方)</p>

    <hr />

    <p>在100次以下投掷次数时，不可能是B破产，只有可能是A破产</p>

    <p>第100次时            只有B破产可能  即  q（100次方）</p>

    <p>第101次              q(50次方)×P(51次方) </p>

    <p>第102次              q(102次方)*p</p>

    <p><strong>综上所述，奇数次时，唯A可能破产，偶数次&gt;=100时，唯B可能破产</strong>。</p>

    <p>E（T(n))=<code>∑ n*T(n)  n=1...+∞</code>
         =<code>∑奇数次  +∑偶数次</code>
          =<code>p/(1-p*q)+q(100次方)/(1-P*q)</code></p>

    <p>其中q=1-p
 问题1把p=q=1/2 代入即可。</p>
  </li>
</ol>

<h2 id="section-1">二、骰子问题</h2>

<p><strong>问题1 一个骰子，6面，1个面是 1， 2个面是2， 3个面是3， 问平均掷多少次能使1,2,3都至少出现一次？</strong></p>

<p>这是一个求数学期望的问题，最终是求1，2，3出现至少一次的最短长度的期望。</p>

<p>这样分叉树的每个节点是一个期望状态，而每个分叉是一次投掷结果。将后续期望出现1、2、3各至少一次的情形记作L123（即题目所求），将后续期望出现1、2各至少一次（3无关）情形记作L12，而1至少一次（2，3无关）情形L1，其余数值符号类推，则树结构如下（列出4级结构已经足够）：</p>

<pre><code>           L123
	   /1    |2    \3
      L23    L13    L12
   /1  |2  \3 
  L23  L3   L2
		  /1 |2 \3  
         L2  P2  L3  

L123 = p1 (L23+ 1) + p2 (L13+1) + p3 (L12 + 1) = p1*L23 +p2*L13+ p3*L12 + 1
L23 = p1*L23 +p2*L3+ p3*L2 + 1
L13 = p1*L3 +p2*L13+ p3*L1 + 1
L12 = p1*L2 +p2*L1+ p3*L12 + 1
L1 = p1 + p2*(L1+1) + p3*(L1 +1) =p2*L1+ p3*L1 + 1
L2 = p1*L2 + p3*L2 + 1
L3 = p1*L3 + p2*L3 + 1

解得：
L1 = 6， L2 = 3， L3 = 2
L12 = 7， L13 = 13/2， L23 = 19/56
L123 = 219/30 = 7.3
</code></pre>

<h2 id="section-2">其他</h2>

<p><strong>从n个数中生成m个不重复的随机数</strong></p>

<p>对于第一个数，可以用概率m/n选取；但是对于下一个，必须考虑之前的数是否被选取而以(m-1)/(n-1)或m/(n-1)的概率选取。</p>

<p>可用下列代码得到结果：</p>

<pre><code>void random_generate(int n, int m)  
{  
    int i=1,t，remain;  
    while(n-i&gt;m)  
    {  
        t = rand()%(n-i);  
        if(t&lt;m){  
            printf("%d ",i);  
            m--;  
        }  
        i++;  
    }  
    while(++i&lt;=n)printf("%d ",i);  
}  
</code></pre>

<p><strong>利用等概率Rand互换</strong></p>

<pre><code>#Rand5到Rand3
def Rand3():
  x = -1
  while not 0 &lt;= x &lt; 3:
    x = Rand5()
  return x

#Rand5到Rand7
def Rand7():
  x = -1
  while not 0 &lt;= x &lt; 21:
    x = Rand5() * 5 + Rand5()
  return x % 7
</code></pre>

<p><strong>单次遍历，等概率随机选取问题</strong></p>

<p><a href="http://www.gocalf.com/blog/random-selection.html">http://www.gocalf.com/blog/random-selection.html</a></p>

<p><strong>条件概率：两个都是男孩的概率</strong></p>

<p><a href="http://www.gocalf.com/blog/the-probability-of-two-boys.html">http://www.gocalf.com/blog/the-probability-of-two-boys.html</a></p>

<p><strong>平均要取多少个(0,1)中的随机数才能让和超过1</strong></p>

<p><img src="http://hi.csdn.net/attachment/201203/13/0_1331634834uu6L.gif" alt="" /></p>

<p><strong>一个口袋内有10个红色球，20个蓝色球，30个绿色球，你随机地
把球一个一个取出来，请问红色球最先被拿完的概率？也就是当第10个红
色球被取出时，口袋内至少还有一个蓝色球和一个绿色球的概率。</strong></p>

<p>60个球随机排列，红球先取完就等于说后面至少还有一个蓝球，
一个绿球。<strong>如果把这个排列倒过来看，就是说看见红球前先看见
蓝球和绿球</strong>。这样一来就容易了。总共有两种情况，先蓝后绿再
红，或者先绿后蓝再红。</p>

<p>先蓝的概率是<code>1/3</code>，绿红两色中先绿再红的概率是<code>3/4</code> （先蓝以后
其它蓝球不影响绿红的概率）。所以第一种情况的概率是<code>1/3×3/4=1/4</code></p>

<p>先绿的概率是1/2，蓝红两色中先蓝再红的概率是<code>2/3</code> （先绿以后
其它绿球不影响蓝红的概率）。所以第二种情况的概率是<code>1/2×2/3=1/3</code></p>

<p>所以，总概率是<code>1/4+1/3=7/12</code>.</p>

<p>仔细看一看上面的解法，我们会发现红蓝绿球的数量不重要，比例最重
要。也就是说如果有100红，200蓝，300绿，答案还是一样的。</p>

<p><strong>在圆环上随机取N个点，请问这N个点正好都在同一半圆环内的概
率是多少？要注意的是这个半圆环可以是任意半圆环。</strong></p>

<p>起来无从下手，但很多概率组合题都是如此，只要想对了思路就容易了。</p>

<p>一共N个点，固定一个点，从这点开始顺时针，逆时针各有一个半圆，其它N-1个点都落在同
一个（比如顺时针）半圆上的概率是1/2^（N-1). 总共N个点，所以总概率是N/2^（N-1）。</p>

<p><strong>你分别写好5封信给5个朋友，你在5个信封上分别写上他们的地址，
如果你把5封信随机地放进5个信封，请问所有5封信都寄错人的概率是多少？</strong></p>

<p>这题是著名的Derangement问题。关键步骤是要找到递推公式。</p>

<p>如果假设N个人有S_n种 derangement。考虑第N+1个与每一个的交换。我们可以证明<code>S_(n+1) = n*(S_n + S_(n-1))</code></p>

<p>有了这个递推公式以后，可以证明Derangement的概率是<code>p_n = sum((-1)^k/k!, k=0,n)</code></p>

<p>对这道题来说，N=6. 当N趋于无穷大时，<code>p_n趋于e^(-1)</code></p>

<p><strong>一个骰子6面分别是1到6，请问你平均要投多少次才能让每个数字都
投中过？</strong></p>

<p>掷第一次可以得到一个数，第二次掷出不同的数的概率是5/6，所以掷出第
二个数的期望长度是6/5，掷出第三个不同的数的概率是4/6，所以掷出第二
个数的期望长度是6/4，以此类推，所以掷出所有六个数的期望长度是</p>

<pre><code>1+6/5+6/4+6/3+6/2+6/1=6×（1/6+1/5+1/4+1/3+1/2+1/1） = 14.7
</code></pre>

<p>当然这个题也可以推广到任意N面的骰子。
在第一个数已经出现的情况下，抛出第二个数的期望次数是</p>

<pre><code>E(x) = 5/6 + 1/6*5/6*2 + 1/6^2 * 5/6 *3 + 1/6^3 * 5/6 * 4 +....
E(x) = 6/5
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zui-xiao-sheng-cheng-shu/"/>
    <updated>2013-05-14T01:09:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>算法使用的是二叉堆，时间为O(ElgV)。如果V小于E的话，使用Prim更好。</p>

<p>Kruskal算法：</p>

<p>O(ElgE): E&lt;V<sup>2&nbsp;</sup>,所以有 lgE=O(lgV)</p>

<p>集合A是一个森林，加入集合A中的安全边总是图中连接两个不同连通分支的最小权边。</p>

<p>使用不相交集合数据结构。</p>

<p>测试边时，即测试两端点是否在同一棵树上。</p>

<p>若不在则可以对集合进行合并。</p>

<!--more-->
<p>Prim算法：</p>

<p>集合A形成单棵树，添加集合A的安全边总是连接树与一个不在树中的顶点的最小权边。</p>

<p>使用最小优先队列。优先队列基于Key值，key[v]是所有将v与树中某一顶点相连的边中的最小权值。</p>

<p>一开始除了根节点，其他节点的key为无穷大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最短路径算法]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zui-duan-lu-jing-suan-fa/"/>
    <updated>2013-05-14T01:09:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zui-duan-lu-jing-suan-fa</id>
    <content type="html"><![CDATA[<p><strong>单源最短路径</strong></p>

<p>​1. Dijkstra</p>

<p>Dijkstra算法解决有向图上带权的单源最短路径问题，要求所有边的权值非负。</p>

<p>用到了顶点的最小优先队列，排序关键字为顶点的d值。即开始出了根为0，其他</p>

<p>顶点为正无穷，后来d值根据松弛算法变化。</p>

<p>总计运行时间为O((V+E)lgV)，如果所有顶点都可达的话，则为O(ElgV)。</p>

<p>​2. Bellman-ford</p>

<p>算法用来解决一般，即边的权值可以为负的单源最短路径问题。算法同时也可以检查</p>

<p>是否有从源点可达的负权回路。</p>

<p>算法的运行时间为O(VE)。</p>

<p><!--more--></p>

<p>在Dijkstra算法以及关于有向无回路图的最短路径算法中，对每条边执行一次松弛操作。</p>

<p>在Bellman-Ford算法中，对每条边要执行多次松弛操作。</p>

<p><strong>每对顶点间的最短路径</strong></p>

<p>​1. Floyd-Wallshall</p>

<p>属于动态规划方案，允许存在权值为负的边，但不存在权值为负的回路。</p>

<p>算法考虑最短路径上的中间顶点，自底向上利用中间顶点K值递增的顺序计算权值</p>

<p>利用的递归式为</p>

<p><span style="font-family: 'comic sans ms', sans-serif;"><em>D<sub>i,j,k</sub>&nbsp;= min(D<sub>i,k,k&nbsp;&minus; 1</sub>&nbsp;+&nbsp;D<sub>k,j,k&nbsp;&minus; 1</sub>,D<sub>i,j,k&nbsp;&minus; 1</sub>)　　K &gt;= 1</em></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><em>　　　= W<sub>i,j</sub>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　 &nbsp;K = 0</em></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><em><br /></em>算法运行时间为&Phi;(n<sup>3</sup>)。</span></p>

<p>利用Floyd算法可以计算出有向图的传递闭包，即确定对所有顶点对，图中是否都存在一条</p>

<p>从 i 到 j 的路径。</p>

<p>用相应的逻辑运算或和并来替换 min 和 + 用以增加运算速度。</p>

<p>​2. 稀疏图上的Johnson算法</p>

<p>对于稀疏图改算法在渐进意义上要好于矩阵的重复平方或Floyd-Wallshall算法。</p>

<p>Johnson算法吧Dijkstra算法和Bellman-Ford算法作为其的子程序。</p>

<p>通过重新赋权值保持最短路径和产生非负的权。</p>

<p>若采用斐波那契堆来实现Dijkstra算法的最小优先队列则运算时间是</p>

<p><span>O(V<sup>2</sup>lgV + VE</span>)。更简单的二叉堆实现，则可以得到O(VElgV)的运行时间。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google PageRank]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/google-pagerank/"/>
    <updated>2013-05-14T01:09:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/google-pagerank</id>
    <content type="html"><![CDATA[<p><strong>edited</strong> from <strong><em><a href="http://www.ams.org/samplings/feature-column/fcarc-pagerank">How Google Finds Your Needle in the Web’s Haystack</a></em></strong></p>

<hr />

<p>Google搜索的核心算法当然不止是PageRank，但PageRank确实是其中的核心部分。Google就曾经说过：“the
heart of our software is PageRank”.</p>

<p>Google的PageRank算法声称他们比较了一个月来网页的受欢迎程度从而确定哪个网页显得比较重要。根据Sergey
Brin和Lawrence
Page的说法，一个网页的重要性不仅仅包括他们自身的重要程度，还包括链接向这个网页的其他网页数目。</p>

<p>综合公式为：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_1.gif" alt="" /></p>

<p>呵呵，看到这个公式我第一反应就是，“我靠，这怎么整啊，这不是鸡生蛋，蛋生鸡”的问题吗？果然，下面就有解决办法。</p>

<p>我们将这个问题转化为一个数学问题。
<!--more-->
首先构造一个链接矩阵，<img src="http://www.ams.org/featurecolumn/images/december2006/index_2.gif" alt="" />。其中：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_3.gif" alt="" /></p>

<p>同时也创建一个向量<img src="http://www.ams.org/featurecolumn/images/december2006/index_4.gif" alt="" />，它的构成正是PageRank的值，也就是页面的相对重要程度。用数学表达式定义为：<img src="http://www.ams.org/featurecolumn/images/december2006/index_5.gif" alt="" /></p>

<p>这个表达式其实也就是向量 *I *为矩阵特征值为1的特征向量，也称呼它为H的固定向量。</p>

<p>下边是一个例子：</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/goodnet.jpg" alt="" /></p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/matrix.0.gif" alt="" /> </p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/eigenvector.0.gif" alt="" /></p>

<p>这样看来，问题貌似得到了解决，我们获得了这8个网页的PageRank值。但是在现实中，这个矩阵的n为250亿，其中的大部分值为0，实际上，研究表明每个网页链接的平均数量是10，这表明每一列只有10个数值不为0。下面我们用一个叫<em>power
method</em>的方法来寻找矩阵的固定向量。</p>

<p><img src="http://www.ams.org/featurecolumn/images/december2006/index_6.gif" alt="" /></p>

<p><strong>General principle:</strong> The sequence <em>I<sup>k</sup></em> will converge to the
stationary vector <em>I</em>.</p>

<p>通过这个方法解释上面的例子</p>

<p>                                                  <center>                           &lt;table cellpadding=5 border=1&gt;   <tr>   &lt;td bgcolor=#ffffcc&gt; <em>I <sup>0</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>1</sup></em>     &lt;td bgcolor=#ffffcc&gt; <em>I <sup>2</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>3</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>4</sup></em>    &lt;td bgcolor=#ffffcc&gt; ...     &lt;td bgcolor=#ffffcc&gt; <em>I <sup>60</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>61</sup></em>    </tr>   <tr>   <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0.0278</td> <td> ...</td>    <td>0.06</td>    <td>0.06</td>    </tr>   <tr>   <td>0</td> <td>0.5</td> <td>0.25</td> <td>0.1667</td> <td>0.0833</td> <td> ...</td>    <td>0.0675</td>    <td>0.0675</td>    </tr>   <tr>   <td>0</td> <td>0.5</td> <td>0</td> <td>0</td> <td>0</td> <td> ...</td>    <td>0.03</td>    <td>0.03</td>    </tr>   <tr>   <td>0</td> <td>0</td> <td>0.5</td> <td>0.25</td> <td>0.1667</td> <td> ...</td>    <td>0.0675</td>    <td>0.0675</td>    </tr>   <tr>   <td>0</td> <td>0</td> <td>0.25</td> <td>0.1667</td> <td>0.1111</td> <td> ...</td>    <td>0.0975</td>    <td>0.0975</td>    </tr>   <tr>   <td>0</td> <td>0</td> <td>0</td> <td>0.25</td> <td>0.1806</td> <td> ...</td>    <td>0.2025</td>    <td>0.2025</td>    </tr>   <tr>   <td>0</td> <td>0</td> <td>0</td> <td>0.0833</td> <td>0.0972</td> <td> ...</td>    <td>0.18</td>    <td>0.18</td>    </tr>   <tr>   <td>0</td> <td>0</td> <td>0</td> <td>0.0833</td> <td>0.3333</td> <td> ...</td>    <td>0.295</td>    <td>0.295</td>    </tr>                              </center>                         <p>

得到的结果只是网页重要程度的相对比值，如果要的到最终的PageRank数值，还需要对它进行线性增加，使得它们的总和为1。

 

有三个问题自然地就提出来了：

-    <em>I<sup>k</sup></em>是否会汇聚到1
-   向量是否与<em>I<sup>0</sup></em>的取值无关
-   是否包含了我们想要的信息，也就是达到充分统计

现在我们对这三个问题还只能说No，但接下来我们将会修改我们的方法使得对这三个问题的回答得到肯定。

![](http://www.ams.org/featurecolumn/images/december2006/dangling.jpg)

with matrix

![](http://www.ams.org/featurecolumn/images/december2006/matrix.3.gif)

结果如下：

 <p>                                                 <center>   &lt;table cellpadding=5 border=1&gt;   <tr>   &lt;td bgcolor=#ffffcc&gt;<em>I <sup>0</sup></em>   &lt;td bgcolor=#ffffcc&gt;<em>I <sup>1</sup></em>    &lt;td bgcolor=#ffffcc&gt;<em>I <sup>2</sup></em>   &lt;td bgcolor=#ffffcc&gt;<em>I <sup>3</sup>=<em>I</em></em>   </tr>   <tr>   <td>1</td>   <td>0</td>   <td>0</td>   &lt;td align=center&gt;0   </tr>   <tr>   <td>0</td>   <td>1</td>   <td>0</td>   &lt;td align=center&gt;0   </tr>                              </center>                         <p>

上面例子的问题是P2并没有链接，它在每次迭代中获取了P1的一些权重，但是却不传给其他网页。像这样没有链接的节点我们称它为悬挂节点，显然，真实环境中这样的网页还很多。要解决这个问题，我们可以转换一种思维方式来思考PageRank，或者说用另外一种视角。

设想我们随机的上网冲浪，我们会随机地从一个页面跳转到另外一个页面。设我们浏览的页面为Pj，它拥有j个链接，其中一个将我们链接到Pi这个页面，那么我们最终浏览Pi页面的概率为1/lj。因为是随机冲浪的，所以我们可以用时间来类比，我们是将在Pj上面浏览的一个时间碎片交给了Pi，也就是Tj/lj。如此叠加，我们可以确定Pi的时间为：

![](http://www.ams.org/featurecolumn/images/december2006/index_10.gif)

也就是说![](http://www.ams.org/featurecolumn/images/december2006/index_11.gif)。

利用这种视角考虑一个没有任何链接的悬挂节点。我们不可能在这个页面上终止我们的网上冲浪，我们会随机的浏览另外一个网页，可能是通过浏览器的地址栏输入或以其他方式跳转，那么我们可以得到我们跳转向某个页面的概率为1/n，n为总的页面数。下面我们重新定义下上一个例子：

![](http://www.ams.org/featurecolumn/images/december2006/dangling.jpg)

with matrix

![](http://www.ams.org/featurecolumn/images/december2006/matrix.4.gif)

and eigenvector

![](http://www.ams.org/featurecolumn/images/december2006/eigenvector.4.gif)

通常说来，*power
method*是用来寻找矩阵特征向量对应的最大特征值的。在我们上面的例子中使用了特征值为1，实际上我们可以用比1小的特征值。
假设S的特征值为![](http://www.ams.org/featurecolumn/images/december2006/index_14.gif)。有

![](http://www.ams.org/featurecolumn/images/december2006/index_15.gif)

则有：

![](http://www.ams.org/featurecolumn/images/december2006/index_17.gif)

![](http://www.ams.org/featurecolumn/images/december2006/index_18.gif)

Since the eigenvalues ![](http://www.ams.org/featurecolumn/images/december2006/index_19.gif) with ![](http://www.ams.org/featurecolumn/images/december2006/index_20.gif) have
magnitude smaller than one, it follows that ![](http://www.ams.org/featurecolumn/images/december2006/index_21.gif) if ![](http://www.ams.org/featurecolumn/images/december2006/index_22.gif)and
therefore ![](http://www.ams.org/featurecolumn/images/december2006/index_23.gif) ,
an eigenvector corresponding to the eigenvalue 1.

It is important to note here that the rate at which ![](http://www.ams.org/featurecolumn/images/december2006/index_24.gif) is
determined by ![](http://www.ams.org/featurecolumn/images/december2006/index_25.gif) .
When ![\$ |\\lambda\_2| \$
](http://www.ams.org/featurecolumn/images/december2006/index_26.gif) is
relatively close to 0, then ![](http://www.ams.org/featurecolumn/images/december2006/index_27.gif) relatively
quickly.

以上的讨论中，我们假设矩阵S的 ![](http://www.ams.org/featurecolumn/images/december2006/index_34.gif) 并且![](http://www.ams.org/featurecolumn/images/december2006/index_35.gif) ，但实际上不常是这样的。

下面的例子:

![](http://www.ams.org/featurecolumn/images/december2006/cyclic.jpg)![](http://www.ams.org/featurecolumn/images/december2006/matrix.1.gif)

那么有

 
 <p>                                                 <center>   &lt;table border=1 cellpadding=5&gt;   <tr>   &lt;td bgcolor=#ffffcc&gt; <em>I <sup>0</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>1</sup></em>     &lt;td bgcolor=#ffffcc&gt; <em>I <sup>2</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>3</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>4</sup></em>    &lt;td bgcolor=#ffffcc&gt; <em>I <sup>5</sup></em>    </tr>   <tr>   <td> 1 </td>   <td> 0 </td>   <td> 0 </td>   <td> 0 </td>   <td> 0 </td>    <td> 1 </td>   </tr>   <tr>   <td> 0 </td>   <td> 1 </td>   <td> 0 </td>   <td> 0 </td>    <td> 0 </td>   <td> 0 </td>   </tr>   <tr>   <td> 0 </td>   <td> 0 </td>   <td> 1 </td>    <td> 0 </td>   <td> 0 </td>   <td> 0 </td>   </tr>   <tr>   <td> 0 </td>   <td> 0 </td>    <td> 0 </td>   <td> 1 </td>   <td> 0 </td>   <td> 0 </td>   </tr>   <tr>   <td> 0 </td>    <td> 0 </td>   <td> 0 </td>   <td> 0 </td>   <td> 1 </td>   <td> 0 </td>   </tr>                            </center>                        </p>

the sequence of vectors <em>I <sup>k</sup></em> fails to converge。这是因为![](http://www.ams.org/featurecolumn/images/december2006/index_36.gif)，所以power
method就失效了。

为了保证![](http://www.ams.org/featurecolumn/images/december2006/index_37.gif) ,
矩阵**S** 必须 *primitive。*这意味着对于某个自然数*m*, <em>S <sup>m</sup></em>中的数值全为正。也就是说，对于两个页面，最多经过m个链接，可以从第一个页面跳转到第二个页面。显然，上个例子并不满足。

下面是另外一个例子：

![](http://www.ams.org/featurecolumn/images/december2006/reducible.jpg)

![](http://www.ams.org/featurecolumn/images/december2006/matrix.2.gif)

with stationary vector

![](http://www.ams.org/featurecolumn/images/december2006/eigenvector.2.gif)

有4个网页的PageRank为0，这显然不对，原因是上图中内涵一个更小的网络。

![](http://www.ams.org/featurecolumn/images/december2006/reduciblewithbox.2.jpg)

就像上面所说的悬挂节点一样，前4个页面的权值进入蓝色的区域后，就在内部消化而不返回出来，其余4个页面获得了前4个页面所有的权值。这是因为矩阵S是可约的，也就是如下形式：

![](http://www.ams.org/featurecolumn/images/december2006/index_39.gif)

要达到不可约，则网络图必须是强连通的，只有强连通图，才能保证有不可约的矩阵。

最终修改：

我们需要重新构造我们的上网行为：我们在浏览有链接的网站时，仍然有一定的几率不遵守这个网站上面的链接，而直接在地址栏上面输入我们想要去的网站，假设这个概率为![](http://www.ams.org/featurecolumn/images/december2006/index_42.gif)。

最终的公式为：![](http://www.ams.org/featurecolumn/images/december2006/index_44.gif)

显然![](http://www.ams.org/featurecolumn/images/december2006/xx.gif)值应该要非常接近1，根据大量的实验结果，Serbey
Brin和Larry Page选择了0.85。

使用*power method*则公式为：

 

![](http://www.ams.org/featurecolumn/images/december2006/index_52.gif)

 

![](http://www.ams.org/featurecolumn/images/december2006/index_53.gif)

 

![](http://www.ams.org/featurecolumn/images/december2006/index_54.gif)
</p></p></p></p>
]]></content>
  </entry>
  
</feed>
