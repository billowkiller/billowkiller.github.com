<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tags: Design Patterns | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/tags/design-patterns/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2016-06-30T22:40:33+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Design Pattern--Principle]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/design-pattern-principle/"/>
    <updated>2013-05-14T01:09:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/design-pattern-principle</id>
    <content type="html"><![CDATA[<p>Head First Design Patterns</p>

<hr />

<p>​1. Identify the aspects of your application that vary and separate them
from what stays the same.</p>

<p>　　Take the parts that vary and encapsulate them, so that later you can
alter or extend the parts that vary without affecting those that don’t.</p>

<p>​2. Program to an interface, not an implementation.</p>

<p>　　Our intuition to solve problems is relying on an implementation,
either in the superclass or in the subclass itself. We were locked into
using that specific implementation and there was no room for changing
out the behavior other than writing more code.</p>

<p>　　With a new design, the subclasses will use a behavior represented by
an interface, so that the actual implementation of the behavior won’t be
locked.</p>

<p>　　ps: *program to an interface *really means *program to a
supertype. *In JAVA, it means interface or abstract class.</p>

<p>　　　　Even better, you can assign the concrete implementation object
at runtime.</p>

<p><!--more--></p>

<p>​3. Favor composition over inheritance.</p>

<p>　　Creating systems using composition gives you a lot more flexibility.
Not only does it let you encapsulate a family of algorithms into their
own set of classes, but it also lets you change behaviror at runtime.</p>

<p>​4. Strive for loosely coupled designs between objects that interact.</p>

<p>　　When two objects are loosely coupled, they can interact, but have
very little knowledge of each other.</p>

<p>　　Loosely coupled designs allow us to build flexible OO systems that
can handle change because they minimize the interdependency between
objects.</p>

]]></content>
  </entry>
  
</feed>
