<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tags: probability | Billowkiller's Blog]]></title>
  <link href="http://billowkiller.github.io/blog/tags/probability/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2014-08-04T21:42:27+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Probability Problem]]></title>
    <link href="http://billowkiller.github.io/blog/2014/08/02/probability-problem/"/>
    <updated>2014-08-02T02:18:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2014/08/02/probability-problem</id>
    <content type="html"><![CDATA[<h2 id="section">一、抛硬币问题</h2>

<p><strong>问题1 有一苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面者吃。问先抛这吃到苹果的概率是多少？</strong></p>

<p>假设第一个人吃到苹果的概率是P。第一次抛硬币若为正面则先抛者赢；若为负面且后抛者也为负面，则主动权回到先抛者，回到原问题。</p>

<p>得到关系：P = 1/2 + 1/2 * 1/2 * P  </p>

<p>得出 P = 2/3</p>

<p><strong>问题2 游戏规则为，连续2次抛到硬币朝上，则游戏结束。问平均抛多少次游戏可以结束？</strong></p>

<!--more-->

<p>平均抛多少次，即是求问题的期望。</p>

<p>首先先抛一枚硬币，如果是花，那么需要重头开始；如果是字，那么再抛一枚硬币，新抛的这枚如果也是字，则游戏结束，如果是花，那么又需要重头开始。根据这个过程，设抛硬币的期望次数为T，可以得到关系：T = 1/2(1 + T) + 1/4 * 2 + 1/4(2 + T)</p>

<p>得出 T = 6 </p>

<p><strong>问题3 连续抛 k 次朝上的解法：</strong></p>

<p>假设连续k次正面朝上的期望为Ek，在连续出现k次正面朝上后，下次一也为正面的期望为</p>

<p>E(k+1) = 1/2 (Ek + 1) + 1/2(Ek + 1 + E(k+1))</p>

<p>推到出公式 (E(k+1) +2) /(Ek +2) = 2 得出 Ek = 2^(k+1) -2</p>

<p><strong>问题4 A和B2人投硬币,正面A得1元,反面B得一元.起始时A有1元,B有100元.游戏持续进行,直到其中1人破产才终止.</strong></p>

<ol>
  <li>
    <p>如果硬币正反概率相同,游戏的期待长度(expected duration)是几次投掷?</p>

    <p>目前认为只有奇数次才可能破产。<code>1*0.5 + 3*0.5^3 + 5*0.5^5+...</code></p>
  </li>
  <li>
    <p>如果硬币是不公正的,正面概率为P,反面概率为Q.(P+Q=1), 那么游戏的期待长度(expectedduration)是几次投掷?</p>

    <p>那么问题的答案是计算E(T(n)),即该事件的期望值。</p>

    <p>第1次出现破产的概率是p  //只可能A破产</p>

    <p>第2次出现            0  //因为A第1次赢了1个，共2个了，最多只能输1个，还会剩1个</p>

    <p>第3次出现            <code>q×p×p</code></p>

    <p>第4次出现            0</p>

    <p>第5次                <code>q*q*p*p*p</code></p>

    <p>第99次               q(49次方)×P(50次方)</p>

    <hr />

    <p>在100次以下投掷次数时，不可能是B破产，只有可能是A破产</p>

    <p>第100次时            只有B破产可能  即  q（100次方）</p>

    <p>第101次              q(50次方)×P(51次方) </p>

    <p>第102次              q(102次方)*p</p>

    <p><strong>综上所述，奇数次时，唯A可能破产，偶数次&gt;=100时，唯B可能破产</strong>。</p>

    <p>E（T(n))=<code>∑ n*T(n)  n=1...+∞</code>
         =<code>∑奇数次  +∑偶数次</code>
          =<code>p/(1-p*q)+q(100次方)/(1-P*q)</code></p>

    <p>其中q=1-p
 问题1把p=q=1/2 代入即可。</p>
  </li>
</ol>

<h2 id="section-1">二、骰子问题</h2>

<p><strong>问题1 一个骰子，6面，1个面是 1， 2个面是2， 3个面是3， 问平均掷多少次能使1,2,3都至少出现一次？</strong></p>

<p>这是一个求数学期望的问题，最终是求1，2，3出现至少一次的最短长度的期望。</p>

<p>这样分叉树的每个节点是一个期望状态，而每个分叉是一次投掷结果。将后续期望出现1、2、3各至少一次的情形记作L123（即题目所求），将后续期望出现1、2各至少一次（3无关）情形记作L12，而1至少一次（2，3无关）情形L1，其余数值符号类推，则树结构如下（列出4级结构已经足够）：</p>

<pre><code>           L123
	   /1    |2    \3
      L23    L13    L12
   /1  |2  \3 
  L23  L3   L2
		  /1 |2 \3  
         L2  P2  L3  

L123 = p1 (L23+ 1) + p2 (L13+1) + p3 (L12 + 1) = p1*L23 +p2*L13+ p3*L12 + 1
L23 = p1*L23 +p2*L3+ p3*L2 + 1
L13 = p1*L3 +p2*L13+ p3*L1 + 1
L12 = p1*L2 +p2*L1+ p3*L12 + 1
L1 = p1 + p2*(L1+1) + p3*(L1 +1) =p2*L1+ p3*L1 + 1
L2 = p1*L2 + p3*L2 + 1
L3 = p1*L3 + p2*L3 + 1

解得：
L1 = 6， L2 = 3， L3 = 2
L12 = 7， L13 = 13/2， L23 = 19/56
L123 = 219/30 = 7.3
</code></pre>

<h2 id="section-2">其他</h2>

<p><strong>从n个数中生成m个不重复的随机数</strong></p>

<p>对于第一个数，可以用概率m/n选取；但是对于下一个，必须考虑之前的数是否被选取而以(m-1)/(n-1)或m/(n-1)的概率选取。</p>

<p>可用下列代码得到结果：</p>

<pre><code>void random_generate(int n, int m)  
{  
    int i=1,t，remain;  
    while(n-i&gt;m)  
    {  
        t = rand()%(n-i);  
        if(t&lt;m){  
            printf("%d ",i);  
            m--;  
        }  
        i++;  
    }  
    while(++i&lt;=n)printf("%d ",i);  
}  
</code></pre>

<p><strong>利用等概率Rand互换</strong></p>

<pre><code>#Rand5到Rand3
def Rand3():
  x = -1
  while not 0 &lt;= x &lt; 3:
    x = Rand5()
  return x

#Rand5到Rand7
def Rand7():
  x = -1
  while not 0 &lt;= x &lt; 21:
    x = Rand5() * 5 + Rand5()
  return x % 7
</code></pre>

<p><strong>单次遍历，等概率随机选取问题</strong></p>

<p><a href="http://www.gocalf.com/blog/random-selection.html">http://www.gocalf.com/blog/random-selection.html</a></p>

<p><strong>条件概率：两个都是男孩的概率</strong></p>

<p><a href="http://www.gocalf.com/blog/the-probability-of-two-boys.html">http://www.gocalf.com/blog/the-probability-of-two-boys.html</a></p>

<p><strong>平均要取多少个(0,1)中的随机数才能让和超过1</strong></p>

<p><img src="http://hi.csdn.net/attachment/201203/13/0_1331634834uu6L.gif" alt="" /></p>

]]></content>
  </entry>
  
</feed>
