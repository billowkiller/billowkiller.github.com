<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tags: spanning tree | Tech Digging and Sharing]]></title>
  <link href="http://billowkiller.github.io/blog/tags/spanning-tree/atom.xml" rel="self"/>
  <link href="http://billowkiller.github.io/"/>
  <updated>2016-12-14T10:15:37+08:00</updated>
  <id>http://billowkiller.github.io/</id>
  <author>
    <name><![CDATA[wutao]]></name>
    <email><![CDATA[billowkiller@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://billowkiller.github.io/blog/2013/05/14/zui-xiao-sheng-cheng-shu/"/>
    <updated>2013-05-14T01:09:00+08:00</updated>
    <id>http://billowkiller.github.io/blog/2013/05/14/zui-xiao-sheng-cheng-shu</id>
    <content type="html"><![CDATA[<p>算法使用的是二叉堆，时间为O(ElgV)。如果V小于E的话，使用Prim更好。</p>

<p>Kruskal算法：</p>

<p>O(ElgE): E&lt;V<sup>2&nbsp;</sup>,所以有 lgE=O(lgV)</p>

<p>集合A是一个森林，加入集合A中的安全边总是图中连接两个不同连通分支的最小权边。</p>

<p>使用不相交集合数据结构。</p>

<p>测试边时，即测试两端点是否在同一棵树上。</p>

<p>若不在则可以对集合进行合并。</p>

<!--more-->
<p>Prim算法：</p>

<p>集合A形成单棵树，添加集合A的安全边总是连接树与一个不在树中的顶点的最小权边。</p>

<p>使用最小优先队列。优先队列基于Key值，key[v]是所有将v与树中某一顶点相连的边中的最小权值。</p>

<p>一开始除了根节点，其他节点的key为无穷大。</p>
]]></content>
  </entry>
  
</feed>
